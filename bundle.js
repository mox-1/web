/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	
	__webpack_require__(3);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery, $) {'use strict';
	
	/**
	 * jQuery || Zepto Parallax Plugin
	 * @author Matthew Wagerfield - @wagerfield
	 * @description Creates a parallax effect between an array of layers,
	 *              driving the motion from the gyroscope output of a smartdevice.
	 *              If no gyroscope is available, the cursor position is used.
	 */
	;(function ($, window, document, undefined) {
	
	  // Strict Mode
	  'use strict';
	
	  // Constants
	
	  var NAME = 'parallax';
	  var MAGIC_NUMBER = 30;
	  var DEFAULTS = {
	    relativeInput: false,
	    clipRelativeInput: false,
	    calibrationThreshold: 100,
	    calibrationDelay: 500,
	    supportDelay: 500,
	    calibrateX: false,
	    calibrateY: true,
	    invertX: true,
	    invertY: true,
	    limitX: false,
	    limitY: false,
	    scalarX: 10.0,
	    scalarY: 10.0,
	    frictionX: 0.1,
	    frictionY: 0.1,
	    originX: 0.5,
	    originY: 0.5
	  };
	
	  function Plugin(element, options) {
	
	    // DOM Context
	    this.element = element;
	
	    // Selections
	    this.$context = $(element).data('api', this);
	    this.$layers = this.$context.find('.layer');
	
	    // Data Extraction
	    var data = {
	      calibrateX: this.$context.data('calibrate-x') || null,
	      calibrateY: this.$context.data('calibrate-y') || null,
	      invertX: this.$context.data('invert-x') || null,
	      invertY: this.$context.data('invert-y') || null,
	      limitX: parseFloat(this.$context.data('limit-x')) || null,
	      limitY: parseFloat(this.$context.data('limit-y')) || null,
	      scalarX: parseFloat(this.$context.data('scalar-x')) || null,
	      scalarY: parseFloat(this.$context.data('scalar-y')) || null,
	      frictionX: parseFloat(this.$context.data('friction-x')) || null,
	      frictionY: parseFloat(this.$context.data('friction-y')) || null,
	      originX: parseFloat(this.$context.data('origin-x')) || null,
	      originY: parseFloat(this.$context.data('origin-y')) || null
	    };
	
	    // Delete Null Data Values
	    for (var key in data) {
	      if (data[key] === null) delete data[key];
	    }
	
	    // Compose Settings Object
	    $.extend(this, DEFAULTS, options, data);
	
	    // States
	    this.calibrationTimer = null;
	    this.calibrationFlag = true;
	    this.enabled = false;
	    this.depths = [];
	    this.raf = null;
	
	    // Element Bounds
	    this.bounds = null;
	    this.ex = 0;
	    this.ey = 0;
	    this.ew = 0;
	    this.eh = 0;
	
	    // Element Center
	    this.ecx = 0;
	    this.ecy = 0;
	
	    // Element Range
	    this.erx = 0;
	    this.ery = 0;
	
	    // Calibration
	    this.cx = 0;
	    this.cy = 0;
	
	    // Input
	    this.ix = 0;
	    this.iy = 0;
	
	    // Motion
	    this.mx = 0;
	    this.my = 0;
	
	    // Velocity
	    this.vx = 0;
	    this.vy = 0;
	
	    // Callbacks
	    this.onMouseMove = this.onMouseMove.bind(this);
	    this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
	    this.onOrientationTimer = this.onOrientationTimer.bind(this);
	    this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
	    this.onAnimationFrame = this.onAnimationFrame.bind(this);
	    this.onWindowResize = this.onWindowResize.bind(this);
	
	    // Initialise
	    this.initialise();
	  }
	
	  Plugin.prototype.transformSupport = function (value) {
	    var element = document.createElement('div');
	    var propertySupport = false;
	    var propertyValue = null;
	    var featureSupport = false;
	    var cssProperty = null;
	    var jsProperty = null;
	    for (var i = 0, l = this.vendors.length; i < l; i++) {
	      if (this.vendors[i] !== null) {
	        cssProperty = this.vendors[i][0] + 'transform';
	        jsProperty = this.vendors[i][1] + 'Transform';
	      } else {
	        cssProperty = 'transform';
	        jsProperty = 'transform';
	      }
	      if (element.style[jsProperty] !== undefined) {
	        propertySupport = true;
	        break;
	      }
	    }
	    switch (value) {
	      case '2D':
	        featureSupport = propertySupport;
	        break;
	      case '3D':
	        if (propertySupport) {
	          var body = document.body || document.createElement('body');
	          var documentElement = document.documentElement;
	          var documentOverflow = documentElement.style.overflow;
	          if (!document.body) {
	            documentElement.style.overflow = 'hidden';
	            documentElement.appendChild(body);
	            body.style.overflow = 'hidden';
	            body.style.background = '';
	          }
	          body.appendChild(element);
	          element.style[jsProperty] = 'translate3d(1px,1px,1px)';
	          propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
	          featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== "none";
	          documentElement.style.overflow = documentOverflow;
	          body.removeChild(element);
	        }
	        break;
	    }
	    return featureSupport;
	  };
	
	  Plugin.prototype.ww = null;
	  Plugin.prototype.wh = null;
	  Plugin.prototype.wcx = null;
	  Plugin.prototype.wcy = null;
	  Plugin.prototype.wrx = null;
	  Plugin.prototype.wry = null;
	  Plugin.prototype.portrait = null;
	  Plugin.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
	  Plugin.prototype.vendors = [null, ['-webkit-', 'webkit'], ['-moz-', 'Moz'], ['-o-', 'O'], ['-ms-', 'ms']];
	  Plugin.prototype.motionSupport = !!window.DeviceMotionEvent;
	  Plugin.prototype.orientationSupport = !!window.DeviceOrientationEvent;
	  Plugin.prototype.orientationStatus = 0;
	  Plugin.prototype.transform2DSupport = Plugin.prototype.transformSupport('2D');
	  Plugin.prototype.transform3DSupport = Plugin.prototype.transformSupport('3D');
	  Plugin.prototype.propertyCache = {};
	
	  Plugin.prototype.initialise = function () {
	
	    // Configure Styles
	    if (this.$context.css('position') === 'static') {
	      this.$context.css({
	        position: 'relative'
	      });
	    }
	
	    // Hardware Accelerate Context
	    this.accelerate(this.$context);
	
	    // Setup
	    this.updateLayers();
	    this.updateDimensions();
	    this.enable();
	    this.queueCalibration(this.calibrationDelay);
	  };
	
	  Plugin.prototype.updateLayers = function () {
	
	    // Cache Layer Elements
	    this.$layers = this.$context.find('.layer');
	    this.depths = [];
	
	    // Configure Layer Styles
	    this.$layers.css({
	      position: 'absolute',
	      display: 'block',
	      left: 0,
	      top: 0
	    });
	    this.$layers.first().css({
	      position: 'relative'
	    });
	
	    // Hardware Accelerate Layers
	    this.accelerate(this.$layers);
	
	    // Cache Depths
	    this.$layers.each($.proxy(function (index, element) {
	      this.depths.push($(element).data('depth') || 0);
	    }, this));
	  };
	
	  Plugin.prototype.updateDimensions = function () {
	    this.ww = window.innerWidth;
	    this.wh = window.innerHeight;
	    this.wcx = this.ww * this.originX;
	    this.wcy = this.wh * this.originY;
	    this.wrx = Math.max(this.wcx, this.ww - this.wcx);
	    this.wry = Math.max(this.wcy, this.wh - this.wcy);
	  };
	
	  Plugin.prototype.updateBounds = function () {
	    this.bounds = this.element.getBoundingClientRect();
	    this.ex = this.bounds.left;
	    this.ey = this.bounds.top;
	    this.ew = this.bounds.width;
	    this.eh = this.bounds.height;
	    this.ecx = this.ew * this.originX;
	    this.ecy = this.eh * this.originY;
	    this.erx = Math.max(this.ecx, this.ew - this.ecx);
	    this.ery = Math.max(this.ecy, this.eh - this.ecy);
	  };
	
	  Plugin.prototype.queueCalibration = function (delay) {
	    clearTimeout(this.calibrationTimer);
	    this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
	  };
	
	  Plugin.prototype.enable = function () {
	    if (!this.enabled) {
	      this.enabled = true;
	      if (this.orientationSupport) {
	        this.portrait = null;
	        window.addEventListener('deviceorientation', this.onDeviceOrientation);
	        setTimeout(this.onOrientationTimer, this.supportDelay);
	      } else {
	        this.cx = 0;
	        this.cy = 0;
	        this.portrait = false;
	        window.addEventListener('mousemove', this.onMouseMove);
	      }
	      window.addEventListener('resize', this.onWindowResize);
	      this.raf = requestAnimationFrame(this.onAnimationFrame);
	    }
	  };
	
	  Plugin.prototype.disable = function () {
	    if (this.enabled) {
	      this.enabled = false;
	      if (this.orientationSupport) {
	        window.removeEventListener('deviceorientation', this.onDeviceOrientation);
	      } else {
	        window.removeEventListener('mousemove', this.onMouseMove);
	      }
	      window.removeEventListener('resize', this.onWindowResize);
	      cancelAnimationFrame(this.raf);
	    }
	  };
	
	  Plugin.prototype.calibrate = function (x, y) {
	    this.calibrateX = x === undefined ? this.calibrateX : x;
	    this.calibrateY = y === undefined ? this.calibrateY : y;
	  };
	
	  Plugin.prototype.invert = function (x, y) {
	    this.invertX = x === undefined ? this.invertX : x;
	    this.invertY = y === undefined ? this.invertY : y;
	  };
	
	  Plugin.prototype.friction = function (x, y) {
	    this.frictionX = x === undefined ? this.frictionX : x;
	    this.frictionY = y === undefined ? this.frictionY : y;
	  };
	
	  Plugin.prototype.scalar = function (x, y) {
	    this.scalarX = x === undefined ? this.scalarX : x;
	    this.scalarY = y === undefined ? this.scalarY : y;
	  };
	
	  Plugin.prototype.limit = function (x, y) {
	    this.limitX = x === undefined ? this.limitX : x;
	    this.limitY = y === undefined ? this.limitY : y;
	  };
	
	  Plugin.prototype.origin = function (x, y) {
	    this.originX = x === undefined ? this.originX : x;
	    this.originY = y === undefined ? this.originY : y;
	  };
	
	  Plugin.prototype.clamp = function (value, min, max) {
	    value = Math.max(value, min);
	    value = Math.min(value, max);
	    return value;
	  };
	
	  Plugin.prototype.css = function (element, property, value) {
	    var jsProperty = this.propertyCache[property];
	    if (!jsProperty) {
	      for (var i = 0, l = this.vendors.length; i < l; i++) {
	        if (this.vendors[i] !== null) {
	          jsProperty = $.camelCase(this.vendors[i][1] + '-' + property);
	        } else {
	          jsProperty = property;
	        }
	        if (element.style[jsProperty] !== undefined) {
	          this.propertyCache[property] = jsProperty;
	          break;
	        }
	      }
	    }
	    element.style[jsProperty] = value;
	  };
	
	  Plugin.prototype.accelerate = function ($element) {
	    for (var i = 0, l = $element.length; i < l; i++) {
	      var element = $element[i];
	      this.css(element, 'transform', 'translate3d(0,0,0)');
	      this.css(element, 'transform-style', 'preserve-3d');
	      this.css(element, 'backface-visibility', 'hidden');
	    }
	  };
	
	  Plugin.prototype.setPosition = function (element, x, y) {
	    x += 'px';
	    y += 'px';
	    if (this.transform3DSupport) {
	      this.css(element, 'transform', 'translate3d(' + x + ',' + y + ',0)');
	    } else if (this.transform2DSupport) {
	      this.css(element, 'transform', 'translate(' + x + ',' + y + ')');
	    } else {
	      element.style.left = x;
	      element.style.top = y;
	    }
	  };
	
	  Plugin.prototype.onOrientationTimer = function (event) {
	    if (this.orientationSupport && this.orientationStatus === 0) {
	      this.disable();
	      this.orientationSupport = false;
	      this.enable();
	    }
	  };
	
	  Plugin.prototype.onCalibrationTimer = function (event) {
	    this.calibrationFlag = true;
	  };
	
	  Plugin.prototype.onWindowResize = function (event) {
	    this.updateDimensions();
	  };
	
	  Plugin.prototype.onAnimationFrame = function () {
	    this.updateBounds();
	    var dx = this.ix - this.cx;
	    var dy = this.iy - this.cy;
	    if (Math.abs(dx) > this.calibrationThreshold || Math.abs(dy) > this.calibrationThreshold) {
	      this.queueCalibration(0);
	    }
	    if (this.portrait) {
	      this.mx = this.calibrateX ? dy : this.iy;
	      this.my = this.calibrateY ? dx : this.ix;
	    } else {
	      this.mx = this.calibrateX ? dx : this.ix;
	      this.my = this.calibrateY ? dy : this.iy;
	    }
	    this.mx *= this.ew * (this.scalarX / 100);
	    this.my *= this.eh * (this.scalarY / 100);
	    if (!isNaN(parseFloat(this.limitX))) {
	      this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
	    }
	    if (!isNaN(parseFloat(this.limitY))) {
	      this.my = this.clamp(this.my, -this.limitY, this.limitY);
	    }
	    this.vx += (this.mx - this.vx) * this.frictionX;
	    this.vy += (this.my - this.vy) * this.frictionY;
	    for (var i = 0, l = this.$layers.length; i < l; i++) {
	      var depth = this.depths[i];
	      var layer = this.$layers[i];
	      var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
	      var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
	      this.setPosition(layer, xOffset, yOffset);
	    }
	    this.raf = requestAnimationFrame(this.onAnimationFrame);
	  };
	
	  Plugin.prototype.onDeviceOrientation = function (event) {
	
	    // Validate environment and event properties.
	    if (!this.desktop && event.beta !== null && event.gamma !== null) {
	
	      // Set orientation status.
	      this.orientationStatus = 1;
	
	      // Extract Rotation
	      var x = (event.beta || 0) / MAGIC_NUMBER; //  -90 :: 90
	      var y = (event.gamma || 0) / MAGIC_NUMBER; // -180 :: 180
	
	      // Detect Orientation Change
	      var portrait = window.innerHeight > window.innerWidth;
	      if (this.portrait !== portrait) {
	        this.portrait = portrait;
	        this.calibrationFlag = true;
	      }
	
	      // Set Calibration
	      if (this.calibrationFlag) {
	        this.calibrationFlag = false;
	        this.cx = x;
	        this.cy = y;
	      }
	
	      // Set Input
	      this.ix = x;
	      this.iy = y;
	    }
	  };
	
	  Plugin.prototype.onMouseMove = function (event) {
	
	    // Cache mouse coordinates.
	    var clientX = event.clientX;
	    var clientY = event.clientY;
	
	    // Calculate Mouse Input
	    if (!this.orientationSupport && this.relativeInput) {
	
	      // Clip mouse coordinates inside element bounds.
	      if (this.clipRelativeInput) {
	        clientX = Math.max(clientX, this.ex);
	        clientX = Math.min(clientX, this.ex + this.ew);
	        clientY = Math.max(clientY, this.ey);
	        clientY = Math.min(clientY, this.ey + this.eh);
	      }
	
	      // Calculate input relative to the element.
	      this.ix = (clientX - this.ex - this.ecx) / this.erx;
	      this.iy = (clientY - this.ey - this.ecy) / this.ery;
	    } else {
	
	      // Calculate input relative to the window.
	      this.ix = (clientX - this.wcx) / this.wrx;
	      this.iy = (clientY - this.wcy) / this.wry;
	    }
	  };
	
	  var API = {
	    enable: Plugin.prototype.enable,
	    disable: Plugin.prototype.disable,
	    updateLayers: Plugin.prototype.updateLayers,
	    calibrate: Plugin.prototype.calibrate,
	    friction: Plugin.prototype.friction,
	    invert: Plugin.prototype.invert,
	    scalar: Plugin.prototype.scalar,
	    limit: Plugin.prototype.limit,
	    origin: Plugin.prototype.origin
	  };
	
	  $.fn[NAME] = function (value) {
	    var args = arguments;
	    return this.each(function () {
	      var $this = $(this);
	      var plugin = $this.data(NAME);
	      if (!plugin) {
	        plugin = new Plugin(this, value);
	        $this.data(NAME, plugin);
	      }
	      if (API[value]) {
	        plugin[value].apply(plugin, Array.prototype.slice.call(args, 1));
	      }
	    });
	  };
	})(jQuery || window.Zepto, window, document);
	
	var letters = ['M', 'A', 'T', 'T'];
	var wrapper1 = $('<div></div>').addClass('wrapper');
	
	for (var i = 0; i < letters.length; i++) {
	  var scene = $('<div></div>').addClass('scene');
	  for (var j = 0; j < 10; j++) {
	    var el = $('<div></div>').text(letters[i]).addClass('layer').attr('data-depth', j * 0.03);
	    scene.append(el);
	  }
	  $(scene).parallax({
	    scalarX: 30,
	    scalarY: 20,
	    originX: 0.65,
	    originY: 0.5
	  });
	  $(wrapper1).append(scene);
	}
	
	var letters2 = ['O', 'X', 'L', 'E', 'Y'];
	var wrapper2 = $('<div></div>').addClass('wrapper');
	
	for (var i = 0; i < letters2.length; i++) {
	  var scene = $('<div></div>').addClass('scene');
	  for (var j = 0; j < 10; j++) {
	    var el = $('<div></div>').text(letters2[i]).addClass('layer').attr('data-depth', j * 0.03);
	    scene.append(el);
	  }
	  $(scene).parallax({
	    scalarX: 30 * -1,
	    scalarY: 20 * -1,
	    originX: 0.65,
	    originY: 0.5
	  });
	  $(wrapper2).append(scene);
	}
	
	//var eyeWrapper = $('<div></div>').addClass('scene eye-wrapper');
	
	// var eye1 = $('<div></div>').addClass('eye');
	// var pupil1 = $('<div></div>').addClass('layer pupil').attr('data-depth', 0.8);
	// var highlight1 = $('<div></div>').addClass('layer highlight').attr('data-depth', 0.3);
	// pupil1.append(highlight1);
	// eye1.append(pupil1);
	// var eye2 = $('<div></div>').addClass('eye');
	// var pupil2 = $('<div></div>').addClass('pupil layer').attr('data-depth', 0.8);
	// var highlight2 = $('<div></div>').addClass('layer highlight').attr('data-depth', 0.3);
	// pupil2.append(highlight2);
	// eye2.append(pupil2);
	// eyeWrapper.append(eye1);
	// eyeWrapper.append(eye2);
	
	var smile = $('<div></div>').addClass('smile');
	var sidePanel = $('.side-panel');
	
	$('.text').append(wrapper1);
	$('.text').append(wrapper2);
	$('body').append(sidePanel);
	//$('body').append(eyeWrapper);
	//$(eyeWrapper).append(smile);
	
	// $(eyeWrapper).parallax({
	// 	scalarX: -10,
	// 	scalarY: -10,
	// 	originX: 0.5,
	// 	originY: 0.5
	// });
	
	
	$(document).ready(function () {
	  $(wrapper1).addClass('loaded');
	  $(wrapper2).addClass('loaded');
	  $(sidePanel).addClass('loaded');
	  $('.logo-wrapper').addClass('loaded');
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.1.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-09-22T22:30Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var document = window.document;
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	
	
		function DOMEval( code, doc ) {
			doc = doc || document;
	
			var script = doc.createElement( "script" );
	
			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.1.1",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
	
			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}
	
			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {
	
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
	
			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&
	
				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
	
			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
	
			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
	
			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
	
					// ID selector
					if ( (m = match[1]) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
	
					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;
	
					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {
	
						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}
	
					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");
	
		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
	
		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {
	
				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {
	
					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}
	
					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||
	
						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}
	
				return elem.disabled === disabled;
	
			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}
	
			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});
	
		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
	
			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );
	
					if ( elem ) {
	
						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
	
						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}
	
					return [];
				}
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}
	
		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}
	
		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}
	
		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}
	
		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}
	
		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		if ( chainable ) {
			return elems;
		}
	
		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}
	
		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}
	
		if ( data === "false" ) {
			return false;
		}
	
		if ( data === "null" ) {
			return null;
		}
	
		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}
	
		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}
	
		return data;
	}
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			do {
	
				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";
	
				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );
	
			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
	
	var rscriptType = ( /^$|\/(?:java|ecma)script/i );
	
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;
	
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );
	
		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );
	
		} else {
			ret = [];
		}
	
		if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}
	
		return ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			contains = jQuery.contains( elem.ownerDocument, elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;
	
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			if ( delegateCount &&
	
				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&
	
				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
	
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
	
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}
	
				if ( button & 2 ) {
					return 3;
				}
	
				if ( button & 4 ) {
					return 2;
				}
	
				return 0;
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		/* eslint-disable max-len */
	
		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	
		/* eslint-enable */
	
		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = concat.apply( [], args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";
	
			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );
	
		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	function setPositiveNumber( elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;
	
		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;
	
		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
	
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
	
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
	
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					style[ name ] = value;
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;
	
		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];
	
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}
	
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
	
				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}
	
					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}
	
					return -1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}
	
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];
	
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( type === "string" ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}
	
					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;
	
					if ( index < 0 ) {
						i = max;
	
					} else {
						i = one ? index : 0;
					}
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );
	
	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	
	
	
	support.focusin = "onfocusin" in window;
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = jQuery.now();
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();
	
				if ( val == null ) {
					return null;
				}
	
				if ( jQuery.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}
	
				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var docElem, win, rect, doc,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			rect = elem.getBoundingClientRect();
	
			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;
	
				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}
	
			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
	
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );
	
	jQuery.parseJSON = JSON.parse;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	
	return jQuery;
	} );


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(4);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(9)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./../node_modules/sass-loader/index.js!!./main.scss", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./../node_modules/sass-loader/index.js!!./main.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, "html, body {\n  margin: 0;\n  padding: 0;\n  background-color: #e0e0e0; }\n\n.layer {\n  font-family: 'Bungee Shade', cursive;\n  color: #585858; }\n\n.scene {\n  display: inline-block !important; }\n\n.wrapper {\n  display: inline-block;\n  position: relative;\n  top: -500px;\n  transition: top 2s ease; }\n\n.wrapper.loaded {\n  top: 0px; }\n\n.eye-wrapper {\n  vertical-align: top;\n  padding-top: 72px;\n  /* width: 200px; */\n  max-height: 200px;\n  display: inline-block; }\n\n.eye {\n  width: 100px;\n  height: 120px;\n  border: 5px solid #585858;\n  display: inline-block;\n  border-radius: 71px / 77px;\n  margin: 0px -4px;\n  position: relative;\n  background-color: white; }\n\n.highlight {\n  height: 5px;\n  width: 5px;\n  background-color: white;\n  border: 2px solid white;\n  border-radius: 10px;\n  left: 40% !important;\n  top: 40% !important; }\n\n.pupil {\n  height: 35px;\n  width: 31px;\n  top: 35% !important;\n  left: 35% !important;\n  position: absolute;\n  border: 3px solid #585858;\n  border-radius: 24px / 24px;\n  background-color: #585858; }\n\n.smile {\n  background-image: './smile.png';\n  height: 140px;\n  width: 196px;\n  background-size: contain; }\n\n.text {\n  font-size: 155px;\n  display: inline-block;\n  width: 55%;\n  min-width: 700px;\n  padding: 100px 30px;\n  box-sizing: border-box; }\n\n.side-panel {\n  border-top-left-radius: 100px;\n  border-bottom-left-radius: 100px;\n  display: inline-block;\n  width: 0%;\n  float: right;\n  height: 100vh;\n  vertical-align: top;\n  background-color: #585858;\n  box-sizing: border-box;\n  transition: width 1.7s ease;\n  padding: 50px;\n  box-sizing: border-box;\n  box-shadow: 2px 2px 19px 2px black; }\n\n.side-panel.loaded {\n  width: 45%; }\n\n.logo-wrapper {\n  height: 125px;\n  position: relative;\n  top: 1000px;\n  transition: top 2s ease; }\n  .logo-wrapper .github {\n    height: 90px;\n    width: 270px;\n    background-size: contain;\n    background-image: url(" + __webpack_require__(6) + ");\n    position: relative; }\n  .logo-wrapper .github.loaded {\n    top: 0px; }\n  .logo-wrapper .twitter {\n    height: 90px;\n    width: 90px;\n    background-size: contain;\n    background-image: url(" + __webpack_require__(7) + ");\n    position: relative; }\n  .logo-wrapper .twitter.loaded {\n    top: 0px; }\n  .logo-wrapper .linkedin {\n    height: 76px;\n    width: 280px;\n    background-size: contain;\n    background-image: url(" + __webpack_require__(8) + ");\n    position: relative; }\n  .logo-wrapper .linkedin.loaded {\n    top: 0px; }\n\n.logo-text {\n  display: inline-block;\n  font-family: 'Bungee Shade', cursive;\n  transition: font-size 0.5s ease; }\n\n.logo-wrapper.loaded {\n  top: 0px; }\n\n.logo-wrapper:hover {\n  color: white;\n  font-size: 20px;\n  cursor: pointer; }\n  .logo-wrapper:hover .logo {\n    transition: opacity 1s ease;\n    opacity: 1; }\n\n.logo {\n  opacity: 0; }\n", ""]);
	
	// exports


/***/ },
/* 5 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB9AAAAKZCAMAAADXiUBIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjY4OEVFRjI2Q0QxMTFFNDhDODNBNTdFQkFDQzQ5NTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjY4OEVFRjM2Q0QxMTFFNDhDODNBNTdFQkFDQzQ5NTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCNjg4RUVGMDZDRDExMUU0OEM4M0E1N0VCQUNDNDk1NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCNjg4RUVGMTZDRDExMUU0OEM4M0E1N0VCQUNDNDk1NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PinFKSAAAAMAUExURQ4MDZza8Do5OoyMjOvY1cPCwlNsd6bd8axcUZybmxoZGSwrK6SkpH2ru7hxZsuijPj4+LKyso93aeS7pPX19Xx7e7mWg5HM6NLR0Ye6zWeJlmpZUYPA6I/G2mNiYmxra+Hg4Onp6XOr0pPR7U1MTaWJeebm5iMiIuvBqTlGTLJmXMOEeFJRUe3t7fDw8NXV1fv18qqpqsfHx8emkkRDQ1d1hbm5uVxbW9zy+vP7/dTv+Hd2dtuynJWUleC1npjV7brl9diyrVdKRIzJ6/vs44aFhsrKyuL0+tOqlB0cHNra2t3d3fv7+7a1tc3NzaGhocTp9vz8/IGBgTQyM4jF6vvy7HRiWJGQkfni1MGfjPbRvL29vbPj89u4tOTKxq2srNSrpmmZvMrr9/DGrYGyw2WTtfXNtvrl2dSZhklfaZuBcu34/MyblIC+58SKgvbVwfj8/vjczPLy8v349nFxcazg8vLl422ToS0yNURWXUQ8NwAAADg1NPro3prY7vz+/3Wfrvbs636857/l9bTb8k1CPaPT7v79/J/b8JbQ5i8tLScqK+j2/PTLskZFRujRzvfayfLJsPTKsffYxdCjncWch7ORfjE6PdigjL2bh9Gumf77+SYlJWyfxF2Go5rY8NiumF+AjcmUjcrl9uGsl717cV9RSTU/RDYwLsaPiN6+uiouMeDDv8eeic6ljwkJCXy65tymkvXPuPPo5ldVVni03s7s965gVfjf0P///4BrYCsoJ2KOrRAODz5NVcSbhi42OSQmJ2hnZxMREnRzc3275v/+/p6enllYWP7//7Cvr2BfX9DP0EA/P8C/v6urq//9/Lu6urOzs6emp9TU1KioqIiIiCAfHzk3OElISG9ubykoKOPj45OTk39+fjEwMLy7u2loaXl4eMTDw4OCg/zv6P///pmYmI+Pj4WEhNjX15aWlu7e3Hu55AwMDPTMs/7+/vDh33y55ayNfH675gUFBXu34s2OfRgiJoidpe/5/aK5wYbC6IvF4LKVhP///6HS3q8AAAEAdFJOU////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBT9wclAABtaklEQVR42uy9C1Rd1b3ovQET5VElycZGc+VxDrJjBJJQBCsmWmtQwkvgmFixjcd4tMaeqjHWF0ZbRwZKm9ikjVbl3KMd1dra2BdHmzgwFjgBeaUhCZtXwAQVQjypvY5ze79+9+v6eD82+7Eec732/v3a0Qpu9pprrjXXb805//M/HRIAAADYHgdVAAAAgNABAAAAoQMAAABCBwAAAIQOAACA0AEAAAChAwAAAEIHAAAAhA4AAIDQAQAAAKEDAAAAQgcAAIDgFvrW43HZmWUut9tdPdCWHN8/1NHq5BJrw9nafCYuPjl8oHq0Wl0DmU1xx7dSKwAACF1XTrjn03byxIdJXGc1JBVG1LV5qdITVA0AAELXFW/2GSd82/FErrUSEmMSunzVZhvVAwCA0PUk1+2P8Jwsxt9lkV6Y0+W3KjOoIwAAhK4jDe4AuLIbGX0PQEpjkytQPW6jmgAAELp+OHvdMkiNTOGq+7T5ULKcOuxlqAMAAKHrxyK3TGpi0rnw80krTpVbg83UFgAAQteNeLdsqhPaK7n2sykoP1ktv/5aqDAAAISuF+kutxK6Ihh6n6YvokJR5bkY4gAAQOh6cdStEFf8Arrpo1R+2KK06tzHqTYAAISuE9lu5bQ1hnx419bGNhUVl03LAQBA6DqJyeVWQ/TpvlC+/H390aqqjTF3AACErhPNbpW4ElaG6sVfmuBSW2ubaDoAAAhdF0661dOSG4qXfjBbQ5WdpOkAACB0PSiIdmshtT3ULnx7qqYKiy6g7QAAIHQ9uptujYSW0rOStdbXAtoOAABC14HTbjdKl907T9ZeWx/RdgAAELoO7HILoCYk5tIzUkXU1S7aDgAAQhdPilsM8UEf8b40W1BVkWgPAAChi6fZLYqeoF6X3tcjrKIO03gAABC6cHKEecpdvS5ok6akfeQSV08NNB4AAIQunHC3QAYag3JNVkFktMhaCqfxAAAgdNGkuMXS9mHwXekjbYIrqY/WAwCA0AWzyC2a7Pzg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"

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB9AAAAIfCAYAAAAovke/AAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd5hddZ0/8PedTHpPgIQQQifUhI6hCFJFkC5gWXAREazYsO4K6+ra14oiKqv8sICIroqKhSZFFLAiClKlhGYILUAy8/vjjIpskGTm3vnee+7r9TznmSHcufPOzTMzZ877fD/fBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4Jk1SgcAAAAAAIDaOOa0GeldunH6euYmmZv+xqQ0+qujr2dCevrHlI4IAC3V13gwPX0Ppb/xcJIHktyT/sbv09+4LqMe/0NOedVDpSP+Mwp0AAAAAAAYrGNP3SiN/l2TPCf9jV2SzCicCADa3e/T6L8g/Y0L88TIC3P60feUDvRkCnQAAAAAAFgZx316y/T1vDTJwUlmF04DAJ2tkavS1zgjI5Z9JZ85/u7ycQAAAAAAgH/upJN6cvusA9LT9/r0N3aK6+sA0GxLkpydRv+Hc+pxvyoVwg94AAAAAAB4Oi84a1Sm3X90+htvSLJB6TgA0AX6k/wwyfvy2VdcMNyfXIEOAAAAAADL84rPHJn+xntiTDsAlNHo/0n6el6b04793bB9yuH6RAAAAAAA0BGOOW12evo+lWT/0lEAgCxJ8sH8Zep/5uzDHm/1J1OgAwAAAADAX738s0ek0X9qkkmlowAA/+Da9DcOa/VqdAU6AAAAAAAce+rI9Dfel0b/6+PaOQC0q0XpbxyT0449p1WfwEkAAAAAAADd7dhTV0nyv0kWlI4CAKyQj+ezx56QNPqb/cQKdAAAAAAAutfLPrdWRiw7L8kmpaMAACuhv/GlLJry8mbviz6imU8GAAAAAAAd45WfWjNpXJRkg9JRAICV1Mj8jF2yaZ6/zTdy4YV9zXpaBToAAAAAAN3n2FNXT1/PxUnWKR0FABi0jbN40gbZf+tzc+GFTRnn3tOMJwEAAAAAgI5x7KmTk3wnybqlowAAQ9Tof2HuWP1DzXo6K9ABAAAAAOgeJ53UkwcnfiPJs0tHAQCaZkG22W9hrvrOL4b6RFagAwAAAADQPe6c+eYk+5SOAQA0WX/joznmtK2H+jSNZmQBAAAAAIC2d+yp2ye5JMnI0lEAgJb4Q3qXbpNTXvXQYJ/ACnQAAAAAAOrv9R8Zm+T/RXkOAHU2N8tGvH8oT6BABwAAAACg/h4e/44k65eOAQC0WH/juLz8szsM9sONcAcAAAAAoN6OP2Vulo34VZLRpaMAAMPimsy6c7ucdNLSlf1AK9ABAAAAAKi3pb3vj/IcALrJlrlz5lGD+UAr0AEAAAAAqK9XfGab9DeujOvhANBtbslfpm6Ysw97fGU+yAp0AAAAAADq7O1RngNAN1orUxa9ZGU/SIEOAAAAAEA9HffptdPfOKB0DACgkEb/61b2QxToAAAAAADUU1/PS+M6OAB0s3l5+We3XZkPcOIAAAAAAED9nHRST5KXlo4BABTW6D9qZR6uQAcAAAAAoH7uWH2HJGuVjgEAFHdYTjqpd0UfrEAHAAAAAKB+Gv3PKx0BAGgLq+b2Wdut6IMV6AAAAAAA1E9/Y4/SEQCAtrHC5wUKdAAAAAAA6uX4U6Ym2ap0DACgTTT6d1/RhyrQAQAAAACol2Ujtk0yonQMAKBtbJcXnLVC5wYKdAAAAAAA6maT0gEAgLYyJpMWr7MiD1SgAwAAAABQL/2NuaUjAABtpqdvoxV6WKtzAAAAAADAsGr0K9ABgH+0gucHCnQAAAAAAOpmVukAAEDbWX1FHqRABwAAAACgbiaWDgAAtJlG/6QVeZgCHQAAAACAulGgAwD/qL+xQucHCnQAAAAAAGqkv5FkfOkUAEDbUaADAAAAANBlXnB2T1z7BgD+r5Er8iAnEQAAAAAAAAAQBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAEASBToAAAAAAAAAJFGgAwAAAAAAAECSpLd0AICn6E0yO8naSVZNMibJ2CSTkowYeMyjSZYkeSDJY0luS3JzkvuGNyoAAAAA0AyNRjJr8viss8rErLPKxKw9fWJmTRmXUSNGZOKYkRk3qjeje6vLg48vW5aHH1uahx57Io8v7cudDzySm+59MDfdtzg33ftg7lj0SPr6+wv/jQDoVAp0oKRZSRYk2SHJFknWSbJmBv+9aXGSm5Jcn+TygePqVCU7AAAAANAmZk4alwXrrZYd1p2ZBeutlq3nrJoxI0c88weugCVPLMtVt96Ty/60MJf9aWEuv3FhFi5+tCnPDUD9KdCB4TQuyd5JDkiya5K1mvz8k5LMHzgOHfizx5L8Isl5Sb6R5Lomf04AAAAAYAVsNWeVHLTl2jloi3Wy6aypLfs8Y0aOyI7rzcyO683825/96s/35RvX3JRvXH1zfnvH/S373AB0vkbpAEDtjU5ySKpCe+9UJXpJ16Yq0r+Y5IbCWQAAAABothecNSJT/7K0dAwqa0+fmON22TiHb7Ne1p4+sXScJMkfFz6QM6+8Pqde/Hsr0wG6y/n57Cv2fqYHKdCBVtk4yQlJjki1MrwdXZrkY0nOTeKXKgAAAIA6UKAX19vTk4O2XDuv232zf1gF3m76+vtz3m9uy8d+8pv86Pe3l44DQOutUIFuhDvQbOsneXeqFeft/j1mx4Hj2iT/nuScsnEAAAAAoLPtsfEaef/B22erOauUjvKMehqN7DdvTvabNyff++1tefM5V+R3d/yldCwACmv3cgvoHGsl+WCqce09hbOsrE2SfD3JVUnemOSisnEAAAAAoLPstP7MfOCQ7bNg3RmlowzKPputmeduuma+fvWNOfGcn+Xm+x4sHQmAQgZToO+cpDN/Apb1WJJvlw4BLdBI8qok70n7jmpfUVsnuSDJl5K8NsnisnEAitkoyealQ3SoHyZZVDoEAECbeU6S9l+K2n4eSfLd0iHgmYzuHZGT9986b9pzfkb0dPausY1G8oKt181em8zO8Wf+NF/5+Q2lIwFQwGAK9H9Lsmezg3SBe5OsWjoENNn6qcrmBaWDNFEjyVFJ9k5ydJLvlY0DUMRBSd5bOkSH2iIKdACAp/qPJDuVDtGBbk018Q/a1jZrrZozjn5ONpo5pXSUppo8dlS+fMxuOXTrdXLsGZfkvoeXlI4EwDDqtDHLQPs4NMmVqVd5/mQzU02NOCm+VwIAAADAP3jlrpvkpyfuX7vy/MkO3nKd/OIdB2X+7OmlowAwjJRCwMrqSfKxJGcnmVo4S6uNSPKuJOclmVg4CwAAAAAUN3JETz535LPzqRfulNG9I0rHabm1p0/MpScekAPmr106CgDDRIEOrIxxSc5KtT94N9k7yU+TzC4dBAAAAABKmThmZM49fq+8bMeNSkcZVuNH9+brx+2Rl+/cXX9vgG6lQAdW1NhUI80PKR2kkHlJfpxkRukgAAAAADDcpo4bnYvftH/23XxO6ShF9Pb05LMveXbetNe80lEAaDEFOrAixic5P8lupYMUtmGSi6NEBwAAAKCLTBg9Mt99zXOzxZr2Av/Awc/KMTtZiQ5QZwp04JmMTnJukp1KB2kTGyb5fpIppYMAAAAAQKuN6u3JWcfukQXrWlOSJI1GcsqLdsp+87pzJT5AN1CgA8/ko0n2LB2izWyR5LTSIQAAAACg1T5xxI7ZZ7M1S8doKyNH9OSrx+yRTVafWjoKAC2gQAf+mWOSHFc6RJs6NMmbSocAAAAAgFb51x3m5tidNy4doy2NH92bs47dI+NH95aOAkCTKdCBp7N1kk+UDtHm/itG2wMAAABQQ5vOmpqPH7FD6RhtbdNZU/PfL/AaAdSNAh1YnlFJzkgypnSQNteb5PR4nQAAAACokZEjevKVY3bPhNEjS0dpey/feSP7oQPUjAIdWJ63JzGbacWsn+QdpUMAAAAAQLO8+jmbZvM1ppWO0TE+etgOGTNyROkYADSJAh14qrlJ3lo6RIc5MdXrBgAAAAAdbfbU8Tn5+duUjtFR1lt1Uk7ce37pGAA0iQIdeKoPJRldOkSHGZVqP3QAAAAA6Gjv3n/bTBxjdPvKOnGvLTJj0tjSMQBoAgU68GQ7JtmvdIgOdVASt+YCAAAA0LE2nDE5//KsDUrH6EjjR/fmTXtahQ5QBwp04MneVjpAh3tL6QAAAAAAMFgn7j0/I3oapWN0rON32SSrTBhTOgYAQ6RAB/5q6yT7lg7R4Q5OsknpEAAAAACwsmZNGZeXbG/1+VCMH92bY3feuHQMAIZIgQ781StLB6iBniTHlQ4BAAAAACvrFTtvktG9I0rH6Hiv2nVTq/gBOpwCHUiSCUkOLx2iJl6cZFTpEAAAAACwohqN5KgFG5aOUQuzpozLbnPXKB0DgCFQoANJsn+S8aVD1MS0JHuXDgEAAAAAK2rn9VfPWtMnlI5RG//yLKPwATqZAh1IqlXTNI/XEwAAAICO8cLt1isdoVYO3GLtjB3ZWzoGAIOkQAfGJtm9dIia2SeJM2QAAAAAOsI+m84pHaFWJo4ZmZ3Wn1k6BgCDpEAHdkoyunSImpmUZNvSIQAAAADgmaw1fYLx7S3wnLmzSkcAYJAU6MAupQPU1G6lAwAAAADAM9llA0VvK+w6d/XSEQAYJAU6oEBvDa8rAAAAAG3PqPHW2HrOqhk3yi6PAJ1IgQ7drZFkq9IhasoIdwAAAADa3uZrTCsdoZZG9fZkk9Wnlo4BwCAo0KG7rZFkXOkQNTUlidt3AQAAAGhrG8yYVDpCbW00c0rpCAAMggIdutsGpQPU3MalAwAAAADA05k2fnSmjx9TOkZtzZ05uXQEAAZBgQ7dbcPSAWpuo9IBAAAAAODprL+qgreV5s6wAh2gEynQobvNKh2g5tYsHQAAAAAAns5qk6w+b6VZU+yeCdCJFOjQ3SaUDlBz00oHAAAAAICnM2H0yNIRam3quNGlIwAwCAp06G4K9NaaWjoAAAAAADwdBXprTRuvQAfoRAp06G4K9NZSoAMAAADQthTorWUFOkBnUqBDd3MG11rjSwcAAAAAgKfTaJROUG+9PSoYgE7kuzd0t4dLB6g5ry8AAAAAbeuhx54oHaHWvL4AnUmBDt3todIBas7rCwAAAEDbemjJ0tIRak2BDtCZFOjQ3RS8rfVg6QAAAAAA8HQeflzB20oPLvH6AnQiBTp0t8WlA9Sc1xcAAACAtnX/w4+VjlBrXl+AzqRAh+52U+kANef1BQAAAKBtXX/3A6Uj1JrXF6AzKdChu91QOkDNXV86AAAAAAA8nYWLH83iJY+XjlFbCnSAzqRAh+6mQG8try8AAAAAbe2Gu+1C2CoKdIDOpECH7nb/wEHzLYsR7gAAAAC0ud/fuah0hNry2gJ0JgU6cFnpADV1VZIlpUMAAAAAwD9z0fV3lI5QS/c+tCS/vcPaJYBOpEAHLi4doKYuKh0AAAAAAJ7JxX+8q3SEWrrk+rvS3186BQCDoUAHFL2t4XUFAAAAoO39YeGi3LHokdIxasfKfoDOpUAHrknyYOkQNbM0yaWlQwAAAADAirjgD8reZvvR728vHQGAQVKgA08k+XrpEDXzvSSLSocAAAAAgBVx5pXXl45QK7+87b787o6/lI4BwCAp0IEkObN0gJrxegIAAADQMX547e1ZuPjR0jFq4ys/v6F0BACGQIEOJMkFSf5cOkRNPJDkW6VDAAAAAMCKWtrXl69ffWPpGLXQ19+fr1z5p9IxABgCBTqQJH1Jvlw6RE2ck2RJ6RAAAAAAsDK+cOkfSkeohR/87s+57S8PlY4BwBAo0IG/+kgSc5qGZlmS95YOAQAAAAAr6+pb7813fn1r6Rgd76RvX1U6AgBDpEAH/mphki+VDtHhzkliPhMAAAAAHek/z7u6dISO9uPrbs+VN99dOgYAQ6RAB57sv1ONc2dwPlg6AAAAAAAM1s9uujuXXH9X6Rgd67++98vSEQBoAgU68GR/SPLp0iE61BlJflE6BAAAAAAMxfFfviRL+6yxWVln/eLG/Pi620vHAKAJFOjAU709yZ2lQ3SYe5O8oXQIAAAAABiq393xl3z6omtLx+goi5c8ntd97bLSMQBoEgU68FSLk7y1dIgO885UJToAAAAAdLx3fvMXufOBR0rH6Bj/+d1rctdirxdAXSjQgeU5I8mPS4foEJck+VzpEAAAAADQLIuXPJ7XftWK6hVx+Y0L89Ef/6Z0DACaSIEOLE9/ksOS3FI6SJu7PcmhSZaVDgIAAAAAzfT1q2/Mh3/469Ix2tqdDzySgz59fp5YZs94gDpRoANP5/4kRyR5onSQNrU0yYuS3F06CAAAAAC0wlu/cWUu/dNdpWO0pWV9/XnR536ShYsfLR0FgCZToAP/zBVJ/q10iDb1ziQXlw4BAAAAAK2ytK8vL/rcT3L7oodLR2k7bz33Z7nwj3eUjgFACyjQgWfy/oGDv3tvvCYAAAAAdIFb738ou37421ZaP8lJ374qHzrfeHuAulKgAyvibUk+XzpEm/hYkneUDgEAAAAAw+WGuxdnv09+Pw8usdvjR37065z8natKxwCghRTowIroT3J8krNLBynsjCRvKh0CAAAAAIbbL265J/t98vu5/+HHSkcp5mM//m1OPOdnpWMA0GIKdGBFPZHk8CQnlw5SQF+SE5IcmWRp4SwAAAAAUMTF19+Zbd77jVx316LSUYbV40v7cvQXL8oJZ12WZX39peMA0GIKdGBl9Cc5KcmrkywrG2XYLEnyklSj2wEAAACgq91074PZ9cPfzuU3LiwdZVj85ZHHcsApP8jpl/2hdBQAhokCHRiMTyVZkORPpYO02DVJtkzyldJBAAAAAKBdLFz8aHb8wLdywlmX5fGlfaXjtMz//uqWbPTvZ+X7v7utdBQAhpECHRisnyfZKsmXSwdpgb4k7091k8B1hbMAAAAAQNvp76/2BN/xA9/KHxc+UDpOUz302BM56vQLc8ApP8jdDz5aOg4Aw0yBDgzF4lTjzY9NcnfhLM3yxyT7J3lrkscKZwEAAACAtvaLW+7J1u/5Rt73/V/msaWdv+vjOVfflC3efU6+dMUfS0cBoBAFOjBU/UlOS7JOqtJ5cdk4g3ZzksOSbJzku2WjAAAAAEDneOixJ/K2c6/Meu/4as644vr095dOtPIuuf6ubPvec3PoqT/Mn+7p1EucADSDAh1olkdSjT2fl+TUJJ0y2+iOJG9PsnmSs1ONbwcAAAAAVtLtix7OkadfkB0/8K2cc/VN6euAJv3CP96RA085P7t++Nv5xS33lI4DQBvoLR0AqJ1bkhyX5M1Jjk7yhiRziiZavh8l+Xiq1eZKcwAAAABokstvXJhDT/1h1lt1Uk7YffMcuWCDTBozqnSsv3nk8aU5+6ob89Ef/ya/vO2+0nEAaDMKdKBVHkzysVSr0Z+b5OAkz08ypWCm3yb5ZpJzk1xdMAcAAAAA1N6f7lmc13z10pxw1mVZsO6MvGDrdXPoVutm1pRxw57l9kUP55yrb8rZV92Yy29cmGV97b86HoAyFOhAqy1JVVp/M8moJLsl2SvJDkm2SjKyhZ/79iRXJLk0ybeT3NDCzwUAAAAALMeyvv789Ia78tMb7sobz74iC9ZbLTuuNzM7rDcjC9adkVUmjGn657xj0SO54qaFuexPC3PFjXfnZzfdnaV9BlEC8MwU6MBwejzJ9weOJBmbZNsk2yXZMMn6STZIMnsln/cvqcrxPw28/W2Sy5LcNvTIAAAAAECzLO3ryyXX35VLrr8rSdJoJOuvOjkbrDY566wyMeuuOjHrTJ+UNaaOy6QxozJxzMi/vf3rxz+45In85ZHH8tCSpXnwscdz870P5eb7Hvzb8ceFD+TW+x8q+dcEoIMp0IGSHk1y8cDxZOOSzEwyJlXJPinJiIH/159kUaoy/uGB9+8fjrAAAAAAQHP19yfX3/1Arr/7gdJRACCJAh1oT48kubF0CAAAAAAAALpLT+kAAAAAAAAAANAOFOgAAAAAAAAAEAU6AAAAAAAAACRRoAMAAAAAAABAEgU6AAAAAAAAACRRoAMAAAAAAABAEgU6AAAAAAAAACRRoAMAAAAAAABAEgU6AAAAAAAAACRRoAMAAAAAAABAEgU6AAAAAAAAACRRoAMAAAAAAABAEgU6AAAAAAAAACRRoAMAAAAAAABAkqS3dAAAAADoAuOSTEsydTlve5M0kkwZeOzogccvz6Ik/QPvL0ty38Bx/3Le72v2XwL4P0YkmTTw/qgk45fzmIeTPD7w/kNJnhiGXAAAwCAp0AEAAGBoGknWSLLuU451Bo5pqUrx4XZXkpuT3DLw9uYn/fef8vdCD/i/elN9Xc9JsnaStZLMSjIzySoDx6oDb1fWg6ludHnyjS8Lk9yW5PaBt39Ockd8nQIAwLBToAMAAMCKWzXJ/CRbJJk38P7clCnIn8nMgeNZy/l/TyT5fZLfJPl1kl8NvH/HsKWD9tCT6oaX+fn71/S8VMX5iBZ9zokDx1rP8LilSW5I8rtUX6+/S3LtwLG0RdkAAKDrKdABAABg+SYl2SHJTkm2TlWsrV40UfOMTFUSzkvy4if9+T1JLk1ycZJLkvwyijrqZWKSBUl2TPW1vV2SCUUTPb3eJBsNHE/2SJKrklw5cFyR5NbhjQYAAPWlQAcAAIDKjFSF2s4Dx/y0bgVqu1o1yYEDR1KNmr4sVZn+g1SlXf/yPxTa0qgkz06yT5JdU4+v63H5+/epv7o+yfmpvk4vSLXXOgAAMAgKdAAAALrViFQrzPdLsm+STcvGaUsTk+w9cPxnqv2Zv53kW6lKusfKRYOnNTvJ81KV5nukfVeYN9MGA8erUu2b/tMkX09yTpK7C+YCAICOo0AHAABa7egk25cO0YUeSfKOgbf83ZRUZfDzkzw3yfSycTrOGkmOGzgeTLXa9etJ/jfJowVzwZwkhyZ5QaqfOY2ycYoalWS3geMTSS5KcvbAcV/BXAAA0BEU6AAAQCvtluS0JD2lg3SZx1KtvFSeV0Yn2T/JUanKc78LN8fEVIXloanK9HOTnJnkx0mWFcxF95iR5CWpSvPt0t2l+dMZkb+X6f+d5Bupfi5fFNsxAADAcrmIBQAAtMr0JF+K3zuGW1+qoviC0kHawPZJPpXkziRnpRrTrjxvjYlJjky1Iv3PST6aZKOiiairRqoy+GtJbk3yoVhxvqLGJHlRqp8P1yV5Q5JJRRMBAEAbciELAABoldNSjXtmeL06VbHUraYneXOSa5NckeSVSaYWTdR9ZiZ5Xap/g++kKjthqCYneWOq4vfHSQ5LNaqcwdkwyYdT3YTwgVT7xgMAAHHnPQAA0BovT3JQ6RBd6L1JPl06RCF7JDk2yQFRqrWLRqpV//smuSHJJ1PdWGNrAVbGrCQnJHlFrJZuhcmpbjo6IcmXk7wryS1FEwEAbW/y2FHpaTQyZdyoNNLI1PHL/xXsiWV9uf/hx3L/w4/lkceXDnNKGDwFOgB0pxmpVoXOTrLWk96fkWpCzeRU+yVOSnW+MPEpH78o1Z6JjyZZ/KRjUZL7U41uvSXJbQPHfS392wDtZqNU45sZXp9P8s7SIYbZqFT7b786yYLCWfjn1k/1feFNqW70+HySx4smot1tm+TfkzwvJigOh5Gptv94UZLTU732C4smAgCG3dRxozN35uSsMWV8Zk8dnznTJmT2lAl/e3/m5LHp7RncqdmSJ5ZVZfojS3LHokdy5wOP5PZFD+euBx7NTfctzu/vXJSb73swy/r6m/y3gpWnQAeAepuTZF6SzZPMH3h/3SSjh/i8KzsKd1GS6590XJfkl0n+mGqvXqA+RqdawTaudJAu841UqzO75UrD2FR/3xOTrF44CytndpJTkrw1yXtSFXVPFE1Eu1knyX+kKnIV58NvZKppHockOTnV1+uyookAgKYb0dPIhjMmZ94a0zN/9vRsvsa0zJs9LXOmTWjZ5xwzckRmTRmXWVPGZbNZ05b7mCVPLMt1dy3KdXctyi9vuy9X33pvrr713tz38JKW5YLlUaADQH2MSLVS57lJdk1VlrfLnq9TUmXb9il//lCqIv2aJD9NckGSe4Y3GtBk70myZekQXeanSV6S7ig4xuXvxfnMwlkYmjlJTk1VpL87yRfjprput06S96cqbhXn5U1P8vFUW7Icl+SysnEAgKHabNa07LnJGtlz49nZZcPVM25U+1WEY0aOyBZrTs8Wa07PEduu97c/v/X+h3L5jQvzk+vuyE/+cHtuuHtxwZR0g/b76gAAVsbMJHunKs33THWhq5NMSLLTwPGaVCsnf5Pkx0nOT1AWE6MAACAASURBVFWoP1YsHbCy9k3yhtIhusyvkuyXakuNOpuSan/e1yRZ/lIFOtU6Sb6Q5C2p/o2/XzYOBUxIdVPM6wfep71snuTiJJ9ItU3Iw2XjAAArauKYkXn+vLWy1yazs9cms7P65M4dFDdn2oTMmTYhh29Tleq33v9QfvT723Peb2/N+df+OQ8uMdSK5lKgA0DnWTXJC1KNtdwhSaNsnKZqpFo5Py/VRdTFSb6X5JtJzhv4b6A9zUhVgtXpe1K7uyXVTQsPlA7SQo0kRyb5rxjVXndzU/2sPzNVmX5H2TgMgxFJXp3k39J5N4F2mxGpbnA5KNXvIFajA0Cb6u3pyZ6brJGXbL9BDtxi7bZcZd4Mc6ZNyNE7zs3RO87N40v7ctH1d+Tbv7o1Z191Y+5a/EjpeNRAPb9ygMHqTXJ06RAd6g9JLiod4imOSDKpdIgOdHeqsrbdTEhyYJIXJtkr3fMzfFKSwweOJakurH85yXcH/htoD41U+xivVjpIF7k71eSR20sHaaHtU40P3q50EIZNI9V2BAemGuv+kSRLiyaiVXZItaJ5q9JBWClrpfq99z2p9qm37QLU1GdevHPWW9UlpZV16/0P5WVfarfLg0/vxL3nZ8+NZ5eO0ZGe+/Hzsqyvv3SMfzBv9rT86w5zc8S262XmpM5daT4Yo3p7sufGs7PnxrPzkcOelR/87s8544rr861f3ZwlT3TDTme0QrdcfAdWzMhU+xCy8r6Q9ivQT06yYekQHejKtFeBvl6S1yX51xhpOSbJwQPHA0nOSXJKkqtKhgKSJK9Ksk/pEF3k4STPT3J96SAtsk6q4ny/0kEoZkKqvbCPTHWD75Vl49BEE1JNlDg+1apmOk9vkncl2SzJUTHSHWpp+3VWyxZrGg6ysn5/56LSEVbK3BlTssfGa5SO0ZEaaaTahbBwjkbyvM3m5PV7bJ7dN/JvmVQr8PfdfE723XxOFj3yeP7n8j/kUxf+zp7prDQFOkB92filczVSlQZvSbJj4SztanKqC+pHJ7kmyWeSnJH67wEM7Wh+kg+VDtFFlqaaylHHQnFEqpvGTo6bxqhsmuSnqVa7vjfObzvdfkk+G9sx1MUhqbZe2D/JTYWzADAIS/sMEulUY0f25l+etUFev8fm2WjmlNJx2taUcaNywu6b57W7bZbzfnNbPv6T3+ZH1/05/eXvfaAD9JQOAEDLGHfZmfZMcnmS/43yfEVtmWp6xh+TvCbVSnVgeIxNta3C6NJBukR/kpem2saibjZPtafuh6M85x+NTHJSkp8n2aJsFAZpbKqv7W9FeV43myW5NMm2pYMAsPKeWKZA7zS9PT05fpdNcvN/vTCnvmRn5fkK6mk0st+8OTn/hOflF28/OAfMXzuNRulUtDsFOkB9WaHTWXZIVRycn2rPV1be7FQjf/+c6kK73yKg9T6QZJPSIbrI25KcWTpEk01I8rEkV8de5/xz81OV6G8pHYSVsnWq7XbeENeg6mr1JD9OsnPpIACsnKXLLMPtJPvPXyu/edehOeVFO2W1iWNLx+lYW81ZJd985V655p2H5OAt11Gk87T88gJQX1agd4bVk5yW5OIkCwpnqYvpqfZlvDbJMbG/JrTK/qn2Pmd4fCTVntB1siDVKPrXxvZirJjeJO9LcnqqVc20r55UNzRekWTjslEYBhOT/DDVmH4AOoQV6J1hqzmr5II37pdvvXJvK86baP7s6TnnuD1z2YkHZsG6M0rHoQ0p0AHqywr09taTqnj6Q5S8rfLXmxOuSrJH4SxQN7OSfD6Je7WHxxeTvKl0iCYamWrV+aVRrDE4L01yTarx0bSfqUm+nuqGRjfHdI/RSb6WZNfCOQBYQfZAb29jR/bm/Qdvn5+97cDsuuGs0nFq61nrrpZLTzwgX3357ll7+sTScWgjCnSA+rICvX1tmOTCJJ9MtVqD1pqfakXMN1ONeQeGpifJ/yRZpXCObvH9JC9Ptf95HcxK8oNUq87dgMFQzE1ySZK9SgfhH2yfakuGg0oHoYhxqc653dwC0AGsQG9fe20yO9ee/IKcuPf89Pao8Vqt0UgO32a9/PHdh+d9B2+X0b3WOaFAB6gzK9DbT2+qfTt/FXsElnBAqrHur45zIBiKNyTZs3SILnF5kkNSn5/pRyT5fZLnlA5CbUxJdZPJSYVzUHltkp8mWbtwDsqanOT8JGuVDgLAP2cFevsZN6o3p7xop3z/tc+zGrqAkSN68pa9t8jP3nZgtl171dJxKMzFY4D6qsvF9rqYleRHqfbtHFM4SzebmOQTqcYGb1Q4C3Si7ZK8t3SILnFdqn3mHykdpAl6k3woyZeTTCqchfpppBoV/pHYEqeUniQfSLU1g5HtJNVWSuemWpEOQJuyAr29bDRzSn72tgNz/C6bpGFWV1HzZ0/P5W85MO8/ePuM6lWjdiv/8gD1ZYR7+3hekl8n2aV0EP7mWUl+mWoigPMhWDETk5yZav9qWuu2VGOp7y0dpAmmJvlukjfGyHZa6/WpCrvxpYN0mamppgC8uXQQ2s6WSb5QOgQAT2/psrrsEtX5Xrf7ZrnmnYdks1nTSkdhwIieRk7ce36ueechmT97euk4FOCCMUB9KdDL60ny70n+N4kzrfYzOtVEgLOT+A0FntlHkqxfOkQX+EuqG69uKx2kCbZKdQOZPaoZLs9PclGcdw2XNZNcHNt68PQOT/Li0iEAWD4r0Msb1duTU160Uz562A4ZM9IwpXa0yepTc+mJB+ToHeeWjsIwU6AD1JcR7mWNTVXMnhzjRNvdwUmuSbJF6SDQxo5IckzpEF1gSZIDk/y2dJAmOChVkTm7dBC6ztapts1ZpXSQmpubar/zzUoHoe19JsmrkswsHQSAf2QP9LJWnTgmF71x/xy/yyalo/AMxo/uzeeP3CVfPma3jB1px6JuoUAHqC8FejlrJvlZqmKWzjAnyRVJjiodBNrQWkk+XTpEF1iaaqXexaWDNMFrUt1ENqF0ELrWFkl+ECvRW2WHJJenOn+CZzIhySdjig1A27ECvZy5M6bk8rccmGetu1rpKKyEF267fn7yhv0yc9K40lEYBgp0gPoywr2MuUkuTLJ54RysvNFJTk/yrtinF/5qRJIzkkwpHaQLvCrVlh+drJHkPUk+HtNXKG+rJBckWbV0kJrZO8n5qfY+BwA6mD3Qy9h6rVVywRv3y3qrTiodhUF41rqr5bK3HJBNZzkdrjsFOkB9WYE+/LZKcmmSdUsHYdAaSU5K8j9JRhZNAu3hbUl2Lh2iC5yU5LOlQwzRyFQ3W7y9dBB4ks2T/CTK3mbZO8m5ScaXDgIADJ0V6MNvt41m5eI37Z/VJ1vB3MnWWWVirnjrgdl7UzuW1ZkCHaC+rEAfXgtSrXIyKrQejkw1+nVy6SBQ0IJUExlorY8nObl0iCEal6pUe3HpILAcmyU5L0rfoXp+qikZY0sHAQCawx7ow2uH9Wbk3OP3yrhR9tCugwmjR+bc4/fKAfPXLh2FFlGgA9TXstIBusg2Sb6bxOylenlOqhGlq5QOAgVMSnJmEr/Zt9bZSV5fOsQQTUjy7ST7lg4C/8SzknwxthYYrH2TfD3JqNJBAIDmWdZnhPtw2XG9mfn+a5+XSWOcTtXJ2JG9Oee4PXP0jnNLR6EFFOgA9eU20uGxZZIfxmjQutouyY+STCsdBIbZp5KsUzpEzf0wyUvS2T+vx6Uqz3crHQRWwCFJTikdogPtnupmH1d7AaBm+qNAHw7brb1avvfafTJxjJ0C62hETyOn/cuzc9SCDUtHockU6AD15Sy49eamKkCmlA5CS82P8fx0l5cMHLTONUkOTfJ46SBDMCHVlI5dC+eAlXFskneUDtFBtk21PYOx7QBQQ/2uHLbcFmtOz/knPE95XnM9jUZOP2rXHLvzxqWj0EQKdID6chrcWjOTfC9K1W4xL1ai0x02SPLp0iFq7vokeydZXDrIEIxJVartWDoIDMJ/JDmgdIgOsFGqc92JpYMAAK2hQG+tNaaMzzeP3zuTxxrk0w0ajeRTL9oxh2xlmF9dKNAB6stpcOuMS/LNGG/cbbZI8rUkbhumrkam2vd8QukgNbYwyT5J7ikdZAhGp/oZuEfpIDBIPUn+X5LNSwdpYzOTnBc3igJArfVp0Ftm8thR+cHrnpe1pvv1upv09vTkzJftlp03mFk6Ck2gQAeor07eU7WdjUhyTpLtSwehiD1SXXRvlA4CLfDvqcb10hoPJtk3yZ9KBxmCRpJTU62gh042IcnXYxue5ZmQ5DtxoygA1J490Fujt6cn5xy3ZzadNbV0FAoY3Tsi33n1czNvtiGWnU6BDlBfzoJb4z1Jnls6BEUdluTdpUNAkz0nydtLh6ixx1KNjL6qdJAheneSo0qHgCbZMMn/xE1xT9aT5EtJti4dBABoPQvQW+P9h2yX3Tdao3QMCpo0ZlTOe80+mT11fOkoDIECHaC+nAY33+FJTiwdgrbw9iRHlA4BTTItVWHid4PW6Evy0iQXFM4xVK9L8o7SIaDJDkjyxtIh2sj7khxUOgQAMDwU6M13xLbr5fW7zysdgzawxpTx+fLLds/IES61dCr/cgD15TS4ueYl+UKsUqLSSPK5JJuVDgJNcFqS2aVD1Nhrkny1dIghOjTJR0qHgBb5ryQLSodoA0ckeXPpEADA8DHCvbm2XHOVnH7Urmm4csiAnTeYmY8etkPpGAySAh2gvpwFN8/kJN9IMq50ENrK+FR7hE4vHQSG4GVJDi4dosbel+SU0iGGaNtUY6797khd9Sb5YpKJpYMUtFWqG0UBgC7SZwl600waMypfO3b3jBk5onQU2swrd90kL91hw9IxGAQXQQDqq690gBr5XJL1SoegLa2V6qK7cyo60UZJPlY6RI19Pp2/r/zMJOemumEI6myDJJ8sHaKQVVLdKDq2dBAAYHjpz5vno4cvyAarTS4dgzb1iSN2zMarTykdg5XkYi9AfTkNbo6jU42uhaezb5JXlg4BK2lUkjOjGG2Vc5O8Ip39s3h0km8mWaN0EBgmR6b7JnL8dUuatUoHAQCGnwK9OV647fr51x3mlo5BG5swemTOfNluGdWrku0k/rUA6stp8NBtkOQTpUPQET6UZF7pELAS/jPVyF6a76dJXpxkWekgQ/TZJNuXDgHD7FNJppUOMYxem+SA0iEAgDLsgT50c6ZNyKdfvFPpGHSALddcJe89cLvSMVgJCnSA+nIWPDQjUu35at9zVsToVKPcR5UOAitgzyRvLB2ipn6dZL8kj5YOMkSvSLUaF7rNzCQfKR1imMxP8v7SIQCAcqxAH5pGI/nCUbtk8liXglgxr99j8zxn7qzSMVhBCnSA+nIaPDSvSrJD6RB0lC3S+fsdU38zkpwRvwe0wi1JnpfkgdJBhmirJB8tHQIKOjLJ7qVDtNjYJF9OdQMgANCl+jToQ3L0Dhtl943seMWK62k0ctq/PDvjRvWWjsIKcOEMoL6cBQ/eZkk+UDoEHekdqYp0aEeNJKenKtFprvtTlee3lw4yRONTlWpjSgeBghpJPpN6T5X5YJJNSocAAMrSnw/eBjMm5WOHW3fDyltv1Uk5+fnblI7BClCgA9RXX+kAHWpkqlHcVuQwGL1JPpnq4ju0m1cm2ad0iBp6ONXrem3pIE3wySRzS4eANrB+kjeXDtEiu6T6eQAAdDl7oA9Of3/y6RftnPGjrSJmcF6722bZePUppWPwDBToAPXlLHjwtiodgI62Y5IXlw4BTzEvyYdKh6ihpUkOT3Jl6SBNcESSl5YOAW3k7UnmlA7RZOOT/E/c6AcAxAr0wfrdnfdn5w1mlo5BBxvV25NPvXCnNJyVtzW3yADUl9PgwdmydABq4YNJvpNkUekgkL/vdWssd3P1J/nXJN8tHaQJZiX5ROkQXeTeJDckuSXJ3QPHPVn+udu4JKsmmTnwdt2BY+ywJO1u45KcnOrrvC7+LcnapUMAAO3BCvTB2WzWtNIRqIHnzJ2VI7ZZP1/5+Q2lo/A0FOgA9eUsGMqZmeoi9RtLB4Ek706yaekQNXRykv9XOkQTNJKcnmSV0kFq6s4kP0pyVZKrk/w6yQNNeN45SRYk2SnJrkk2a8Jz8n8dmeSUJD8vHaQJtorzEgDgSfps/ghFffDQ7fOtX92cRx5fWjoKy2GEO0B9OQ2Gsl6dapUglLRvkjeUDlFDH0lVoNfBy5LsVTpEzfwmyTuSzE+1uv/IJB9LckmaU54nya1JvpbkNUk2T7JGqpXS30ryWJM+B9U1k/eXDtEEI5KcGosoAIAnsQIdylpjyvi8alfrHdqVAh2gvpwFQ1mjkryrdAi62owkX4i9bpvti0neVDpEk6yR5EOlQ9TEwlSv5WZJ5iV5b6rV5sPljlR7Wx+YagrKy5P8dhg/f509J51/k8nLkmxTOgQA0F7sgQ7lvX2fLTNt/OjSMVgOBTpAfTkNhvJekmSL0iHoWqcmWa10iJr5fqpisi4/Yz+dZHLpEB3u2iQvTrJmkjf/f/buO8yusvrb+D2phFBCh4BU6QhSlCKKoIAoYgOxK1gAQYqKYEFRUMGCBVREEFBBUUSx0ESp4qsg0muAhBYgCQlpJJOZyfvHM/xISE4yc87ee+1yf67rXIEk5zzfTGYmz9lrr/UAd8fGAWAacDapkL8PcGNsnFr4OtW9GWkV4JToEJIkqXzsQJfijVl2BJ9+49bRMbQYFtAlqb7cBUvxhgBfiA6hRvo48LboEDXzL+BdwLzoIBl5H/DW6BAV9jipcP4K4ELK+Xkxn3TTx2tJHdS3x8aptB2Ad0aHaNMJwErRISRJUvl4BrpUDse88RWstvwy0TH0EhbQJam+LKBL5bA/aaSvVJRNge9Fh6iZ+4H9gNnRQTKyKulMbg3eHNJ49s1IhfOqXHb8G6kIfBz1+Twu2klU7xrKlsDh0SEkSVI52YEulcOyI4bxqd29dFg2VXvzJ0kauKpc0JXqrgv4XHQINcYI4AJgdHSQGplIGoM9OTpIhr5GKqJrcP5CuiHqi8Cs4Czt6AG+BWwL3BScpYo2J50xXyXfBoZFh5AkSeXkGehSeRy5x1asOGpEdAwtwAK6JNWX22CpPN4HvDw6hBrhy8D20SFqZCpp9PUj0UEytBVpxL8Grhv4FGnk/UPBWbLwAPA6Uke1+8XBOTY6wCDsTrr5R/XwPOnfpKlU8wYeSVIJ2YEulceKo0Zw6Ou2iI6hBXgnsiTVl7tgqTyGAkf2P6S8vB74fHSIGpkDvAO4KzpIxk7D94GD8SjwbuDf0UEy1ku64eZu4FxgVGycytiJdPPB9dFBBuBr0QE0YE8Bt5Bu0Hmk/zGJNPnkaWB6i+etSPra3QDYiHSz5suBrYEtSPtPSZJasgNdKpdP7bElp119B/N6HSxbBl44kaT6chsslctBwAnAc9FBVEsrkIpgTpjKRg9wIHBddJCMvRXYMzpEhVwFvJ96je9/qYtIxxT8iVSM09IdS/kL6HsCu0aHUEv3kf59uZ50nML4Nl/nuf7HU8C/XvJry5Em0rwKeCOwBzC8zXUkSTXVZwVdKpW1x4xm/+025Nc3j4uOIrzAJkl15i5YKpflSIUYKQ9nAOtHh6iRw0kFxToZAXwnOkSFXAi8hXoXz19wPam45g1eA/MWUndvmZ0YHUAL6QNuIE0iWgfYHDiU9H1mfE5rziQV6b8DvAlYA/gwcCnpWApJkiSV0Cdet1l0BPWzgC5JklScTwFd0SFUO+8FPhgdoka+CpwVHSIHhwGbRIeoiO8BHyBNImiKW4G9SEU3LVkXcFR0iCXYG9glOoSANIb9m8CGpNH/pwNPBGWZCvwCeDvphruvkcbDS5IkqURev8lYtlt31egYwgK6JElSkTYjdflJWVkP+HF0iBr5IfXs3Fwe+FJ0iIo4Hvg0zZzk8x/gHcDc6CAV8D7KO/L+xOgA4mHgE8DLgC8AE2LjLGIi8BXSHuIjpLPXJUmSVBKHvG7z6AjCArokSVLRPhodQLUxFPglMCY6SE38DjgmOkROjgC8hX3pTgdOjQ4R7GrSEQZasuVI0z/KZndgp+gQDfYYcBCwKfAzyn8zylzgfNJI+U+SCuuSJEkKduAOG7HM8KHRMRrPArokSVKx3oEFT2XjM8Bro0PUxN9II7v7ooPkYBXguOgQFXAh5R7LXaRzgDOjQ1TAkZTvWJZPRwdoqJmkKR+bAudRveMf5gE/ATYGTu7/f0mSJAVZcdQI3v7K9aNjNJ4FdEmSpGItA7wzOoQq71Wki9zq3P+A/YHu6CA5+QzlHTVdFreQxi03cWx7K8cCD0aHKLnNgZ2jQyxga2Df6BANdDGp8Px14PngLJ2aBZwAbAFcE5xFkiSp0d7/6o2jIzSeBXRJkqTivT86gCptWdLI1eHRQWrgEeAtwPToIDlZldQlq9YeBd5KKhzpRTNJ53zbibpkB0UHWICj94s1g3R++AHAU7FRMjcO2It0fnvVuuklSZJqYe8t12HV5ZaJjtFoFtAlSZKK93pgnegQqqxvkTof1ZmngT2p95mvhwOjo0OUWC+pSFy34ldWbgFOig5RcvuTJstEWxP4cHSIBrkR2JJ0M1td9QDfJE1ZmBCcRZIkqXGGDx3Cu7bbIDpGo1lAl6T6KtuZjJJeNATHuKs9+wKfjA5RAzNJH8uHooPkaDk803tpvgL8MzpEyZ0KPBAdosTGAPtFhwA+DoyMDtEQ5wJvBB6LDlKQW4Bdgf8XHUSSlL0uLx1KpXbgDhtFR2g0C+iSJEkx3h4dQJWzJvBzvEGqU3OBt5GKAnX2UWCl6BAldg2pu1JL1g0cFx2i5KKPZRlKKqArX33AZ4GDSf+ONMnjwBuAy6ODSJIkNclrN16TlZb1PtkoFtAlSZJivBaLWxq4LlLX22rRQSquj3Rm7T+Cc+RtKJ59viQzgY+RPh+0dH8EbogOUWJ7AysHrv9m4GWB6zfBPOA9wHejgwSaDbyVtBeRJEklN3PuPJ6e/jwPT57Ow5OnM2nGHJ6f1xMdS4M0bMgQ9t7SEyCjDIsOIEmSWpoA3AmM7//v8cA00pmEMxb4faNI52+uAAwH1gc2IZ2RvCmxF3XV2jDSRfffRAdRJRwCvCk6RA18imZ8ze0PbBgdosROAh6ODlExnwH+Ex2ipEaSpsr8PGj9jwSt2xTzSFMGfhcdpAR6SdMOhgIfCs4iSVLjPTZ1Jjc99DS3PjqZCVNmMn7KDCZMmclT02e3fM7QIV2ssMwI1lpxWTZbcwybrLEim64xhs3XGsMrX7YKI4cNLfBPoIHYb5v1+M3NdT59rrwsoEuSVB7jgD8DN5LOGXwyo9ddg3RW41uAvYBVMnpddW4/mlHMU2c2o9ldb1k5FfhxdIiCHBMdoMTuAE6LDlFBNwNXkfYRWtS7iCmgj6UcZ7DXVQ9wAHBpdJAS6QUOIt3Ae0BwFkmSGmXGnHlcftdj/PG28Vz/4ESemDZr0K/R2zefqbPnMnX2XO6ZOHWhXxs9chi7bTyWvbdch722WIfN1hyTVXR1YJ8t12X40CHM63WAWtEsoEuSFGsc8AvSeNQ7c1rjaeCC/sdQYEfgA/2P5XNaUwPzJtLfSW90EJXWCNLX7rLRQSru58Dno0MUZHvS93ktaj5wOKkopsH7DhbQW3kDaU81Y2m/MWPvx+s6eZkPHIrF88XpAz4MrAXsGpxFkqRa6+2bz1/unMDZN97H1fc+wZx5+V0+mjW3h8vuepTL7noUgC3HrsSRe2zFB3bcmGVHuOWMMmbZEey84Rpc/+DE6CiN4xnokiQVrw/4K+nMyk1Jo2TzKp6/VC9wE/BJYB3SOON7C1pbi1oJ2C46hErtRPwc6dQfgE+QiiFN8LHoACV2CWnKi9pzNXBXdIiSGgnsGbDuwQFrNsVXgXOiQ5TY86TpBw9GB5Ekta+rKzqBWnnu+W5OvfI2Xv6l3/D2H1/FX+54NNfi+eLc/eRUDvnVDax7/IV8/g//YeJzrUfDK197bDY2OkIjWUCXpPpyG1w+80kX77cB9gUuJxXTo0wHzgC2BN4HPBGYpcn2iA6g0todOC46RMXdSOrQbMqUhxVIf14tqg/4cnSIipsPfC86RIm9reD1diAd8aHsnUUqoGvJppLe00yPDiJJUl1Mm93N8Zf8h3WOu4DjL/kP46cUPeBoUVNmzeGUK25j/S9cyNG/vYnpc7qjIzXOGzdfOzpCI1lAlySpGNeSLnS+i/J1b80Hfk26CHsKMDc2TuNYQNfirEQ63sH9evvuAd5O6pJrCo/maO13pM8JdeZimvU1NRhvIR3LUpR3FrhWk9wOHBUdokIeAI6MDiFJUtXNnw/n3fQAm375Ik698jZmzp0XHWkR3T19/ODvd7H11y7mt7c8HB2nUV613uqMHukY/aJ5QU6SpHxNBg4iFUlvDc6yNDNJZwRvi0WGIu1KOudaWtDppGMW1J4JpLOap0QHKdgnogOUVB/puBR1bjrw5+gQJbUK6WbJory7wLWaYgbp4zonOkjFnA+cFx1CkqSquu+paexx2l846PxreWZG+e9VnTBlJgf+7GoOOv9anp/XEx2nEUYMG8JrNlozOkbjWECXJCk/lwGbky4oVens3XuBHYHfRAdpiGVJH2/pBe/DMdydeBZ4M807lmJr0hEhWtTvgbujQ9TIhdEBSqyoc9C3BzYqaK0mOZzUUa3BOwaYGB1CkqSqOfem+9nu5Eu49oEno6MM2nk3PcAup17KQ5M8zaUIr9/Ec9CLZgFdkqTs9QInkM4EnBycpV0zgfcCRxN7TntT7BwdQKWxHvDj6BAVNotUPG/iFA1vumjth9EBauZy0tnHWlRRBfT3FLROk/wB+GV0iAqbBnwsOoQkSVUxZ14vH//l9Rx8/nWV7uK+7bEp7PCNS7hx3FPRUWpvxw1Wj47QOBbQJUnK1nRS4fxkqtV13soPTXfoFAAAIABJREFUgIOxiJ63V0cHUCkMBX4FrBgdpKJ6gAOBf0cHCTCUdP65FnUrcGN0iJrpJhXRtahdKOZ7uOefZ2sG6aZRdeYy4JLoEJIkld1jU2ey4yl/4Owb74uOkolps7vZ+weXVbKLvkpevcFqDB3SFR2jUSygS5KUnftJIzWviA6SsfNJnU7VvSW2/BzhLoBjgV2jQ1TUfOAg4K/RQYK8FnCe2+L9PDpATf0tOkBJDQNel/MaWwMb5rxG03wGeDQ6RE18GpgbHUKSNDBd1uIKd+ujk9nplD9yx+PPRkfJ1OzuHvY94wpueNBO9LwsN3I4m6+5UnSMRrGALkn15Ta4WPcCuwPjooPk5HfAJ6ND1Ng6wJrRIRTq1cBJ0SEq7Iuk7v2mcnz74s3Ekcx5uZJ6TNrJw245v/4+Ob9+01wNnB0dokYmAD+KDiFJUhnd/vgU9vr+ZTw5bXZ0lFzMmtvDO35yFeOe8Uz0vGy/3qrRERrFArokSZ27i3SxdGJ0kJz9DDgtOkSN7RQdQGGWJU16GBYdpKK+B3wzOkSg4TjOuZVLSUerKHsTgTuiQ5TULjm//l45v36T9AJH4c0gWTsFv/dKkrSQWyZM4vXf/TNTZs2JjpKrKbPmsO8ZVzBjzrzoKLW004aeg14kC+iSJHVmAqkTaFJ0kIJ8nmaeL1yEbaMDKMzJwGbRISrqEtLo+ybbHVg5OkRJ/TY6QM3dEB2gpHYg3RiVh+XxqI8sXQjcEx2ihiYBP44OIUlSWYyfMoO3nnEl02Z3R0cpxP1PT+PIi/4ZHaOWtllnlegIjWIBXZKk9k0H9gUejw5SoG7gAGBydJAa2io6gEK8CTg6OkRFXQm8h9RB2GRviw5QUs+RPkeUn1uiA5TUcGD7nF77jcCInF67abqBE6JD1NgPSR9jSZIa7bnnu9n3jCt4ano9x7a3ct5ND3DOP++LjlE7W6y1El0e2loYC+iSJLWnBziQNL69aR4jjbtUtraIDqDCrUQ6d9W3P4P3L9LY8qbPhesC3h4doqT+AsyNDlFzN0cHKLG8xrh7/nl2ziVNklI+JgIXRYeQJClSb998DvzZ1dz95NToKCE+87v/17gbB/K24qgRrDNmuegYjWEBXZKk9hwHXBEdItCFNPvPn4eNgVHRIVSo7wNrR4eooPuB/QDficN2wNjoECX1l+gADXA/MCs6REntmNPrviGn122abtI53crXj6IDSJIU6UuX3syVdzdpaOXCnnu+m6Muuik6Ru1stfZK0REawwK6JNWXHY35+QPwvegQJXAkdvdlaSiwaXQIFWZ/4EPRISpoIqkD02MkEse3L9584B/RIRqgF7g3OkRJbZvDa44FNszhdZvoXGB8dIgG+Dfg7FZJKrEuLx3m5k+3T+DUK2+LjhHut7c8zGV3PRodo1a2HGsBvSgW0CVJGpyngE+QLs433YPAmdEhambz6AAqxBrAT6JDVNBUYG/gkeggJfLW6AAldRvwTHSIhnggOkBJrQ+snPFrvi7j12uq+cC3o0M0yAXRASRJKtqzs+Zy6AU3MN8rhwAc9/v/0OcHIzNbrGUBvSgW0CVJGpzDsPNxQacAc6JD1Igd6M3wU2DV6BAVMwd4B3BndJASWR3YJjpESV0dHaBBHowOUGJZf33umvHrNdW1wEPRIRrkQrzxWJLUMIddeAMTn/PEsRfc9eSzXPI/74PPysarrxgdoTEsoEuSNHC/Bv4YHaJkngLOiw5RI+tHB1DuPoBjtwerFzgQuC46SMnsjse1tHJDdIAGGRcdoMS2zvj1XpPx6zXV2dEBGuZh4PboEJIkFeUvdzzKb295ODpG6Xz3b3dER6iN9VZZLjpCY1hAlyRpYJ4DjooOUVKnAj3RIWrCs03rbV3gjOgQFXQ48KfoECW0d3SAEvtPdIAGeSw6QIlleQ76GLIvyDfRM8DF0SEa6PLoAJIkFWF2dw+HXei9vIvz/x5+hqvvfSI6Ri2sPWY0I4cNjY7RCBbQJUkamG8Dk6JDlNR44PfRIWpivegAyk0XcA7grK3B+Spp5L0WtUd0gJKaCDwdHaJB3Bu1tmWGr7UTXr/Jwi+B7ugQDfSP6ACSJBXhh/+4i8enzoqOUVo/+IcnsmVhSFcXL1t5dHSMRvANmCRJS/c4cFp0iJI7KzpATawNDI8OoVwcCrwxOkTFnA6cGB2ipDbBG25auTU6QMM8Ex2gxDbJ8LV2yPC1mszx7TFuBJ6PDiFJWlSXB0JlZvLMOXzj8v9Fxyi1K+56nKenuyXIwvqrLB8doREsoEtSfbkNzs6JeNFnaa4hnXGozgzFolgdbUyaYqGBuxg4JjpEie0aHaDEbosO0DDPAr3RIUpqBWBsRq+1TUav02R3AfdFh2ioOcDN0SEkScrTd/92BzPmzIuOUWo9fX38+uZx0TFqwQJ6MSygS5K0ZONJ4x61ZPOBi6JD1MTa0QGUqaHAeYDztQbueuCDWJRbktdEByixB6MDNEwfMDs6RIltmtHrZHmeelNdEh2g4ZzZKkmqrSmz5vCja++OjlEJv/q3b9eyMHbMstERGsECuiRJS3YqnpU4UL+IDlATa0QHUKYOA3aJDlEh9wLvJHWrqTU/p1pzGkrx/HptLYsC+orAhhm8TtNdGh2g4awqSJJq6yfX3WP3+QD9d8Jk7p04LTpG5a2xvAX0IlhAlySptanYfT4Y95HGY6ozFtDrY2PSTTgamPGkc+KnBOcouzFke7Zy3TwSHaCB5kYHKLGNM3iNrfBopk49Dngoaax7owNIkpSHuT29nP4P7xMbjD/eNj46QuWtueKo6AiNMCw6gCRJJfZzYFZ0iIq5inShV+2zgF4PXcDPAG8LHpingT2BJ6ODVMBOeCP0kpxPGiuu4qwSHaDE1s/gNRzf3rk/kI4bUpzHowNIkpSHS2+bwDMzno+OUSl/v+8JPr/PK6NjVNrqy1tAL4IFdEmSWjszOkAFXQl8OjpExVlAr4fDgN2iQ1TETGBfYFx0kIrYOTpAye0RHUBawLoZvMYrMniNpvtLdADxTHQASZLy8POb7ouOUDk3jJvIzLnzWG7k8OgolbXGChbQi2DngiRJi/c/LOa040Yc5dqp1aMDqGNjgW9Eh6iIHuB9wC3RQSrEblSpOtbL4DU2y+A1mqwbuCE6hJgOzIkOIUlaWJenxHRkyqw5/OM+h6gNVndPHzeOeyo6RqXZgV4MC+iSVF/ugjvz5+gAFTWbVERX+1aLDqCO/RBYMTpEBfQBH8Lvt4O1TXQASQO2KtDp1a2XZxGkwe4AnKtaDs9GB5AkKUt/u+cJ5vV6elQ7/n7fE9ERKm3FUSMYNsTybt78CEuStHhXRgeosJuiA1TcCtEB1JE3A++KDlERRwK/jg5RMSuRzUhoScXoAl7WwfOXJ001UfvsPi+P7ugAkiRl6ep7LQK36+bxk6IjVN7yyzgCP28W0CVJWlQP8N/oEBV2e3SAils+OoA6cnx0gIqYAJwZHaKCtowOIGnQ1u7guRtllqK5/hkdQP+nJzqAJElZumWCReB2/e/RKfTNnx8do9JWGGUBPW8W0CVJWtQ4PMe7E9580Bk70KvNv7+BWQ/4SnSICnpldABJg7Z6B8/dOLMUzeXRQuUxLzqAJElZ6enr476npkXHqKzpc7p5aNL06BiVtvzIEdERas8CuiRJi7o7OkDFjQemRIeosOVJI1+luvsisFt0iIrZKjqApEFbtYPnev55Zx4Gno4Oof9jAV2SVBvjnpnO3J7e6BiVduujk6MjVJoj3PNnAV2SpEXdEx2gBu6IDlBhQ4FR0SGkAgwBzsWu/cHYJDqApEHrpAPdEe6duTU6gBbiCHdJUm3cO9Hu807d8fiz0REqzQJ6/iygS1J92cHaPgvonbsvOkDFeQ66mmID4AfRISrEblSpelbr4LkvyyxFM7mnLxc70CWpZLq8ctg2x7d37sFnnouOUGnLjbSAnjcL6JIkLeqJ6AA18HB0gIobGR1AKtBHgAOjQ1TAKGCd6BCSBq2TAvqamaVopvujA2ghdqBLkmrj6RmzoyNUnmegd2bksKHREWrPArokSYuaFB2gBiygd8bbSNU0ZwLrRocouQ1wuoxURSt18NyxmaVopnujA2gh86MDSJKUlckz50RHqLyHJ1tA78SwoV4eyJsFdEmSFjU5OkANPBIdoOKGRQeQCjYGOAffnyyJ559L1dTusSwjgFWyDNIwfdiBLkmScmIBvXPTZnczdfbc6BiVNWyIl0/y5kdYkqSF9QLPRoeoATvQO2MHuprojcBR0SFKbIPoAJLaslybz1sDp0504jHA2aqSJCkXU2Za+M3CI5NnREeorOFDLe/mzY+wJEkLm0bqWFFnngNmRoeoMDvQ1VTfBLaJDlFSa0cHkNSWdjvQPf+8M3afS5Kk3EyZZQd6FiY+5/2O7XKEe/4soEuStLBZ0QFqxFH47bMDXU01ErgQGBUdpIQ8C1mqpnYL6GtlmqJ5Ho0OIEmS6mvOvN7oCLXgjQjtswM9f36EJam+vA2tPfOiA9SIo/DbZwe6mmwL4OvRIUrIYppUTaPbfN6qmaZonqeiA0iSVHZdXjls27xeh1dm4dlZjsJv19Auy7t58yMsSdLCuqMD1Igd6O3zbaya7mhgn+gQJWMHulRNw4GhbTxvxayDNMzT0QEkSVJ9dfdYQM+CZ8m3zxtg8mcBXZKkhdmBnp0p0QEkVVYXcDawSnSQErGALlVXO5NlVsg8RbNYQJckSbmxAz0bjnBXmVlAlyRpYRbQs+MId0mdGAv8LDpESYwGlosOIalt7RTQ2z07XYkFdEmSlBsL6NmYNttBoCovC+iSJC2sNzpAjcyODiCp8t4BfCQ6RAmMiQ4gqSPD23iOHeidsYAuSZJyM5/50RFqYU5PT3QEqSUL6JIkKS/eRiopC6cDG0eHCOZZyFK1OcK9eM9EB5AkSdKSeZa8yswCuiRJyosFdElZWA44DxganCOSBXSp2tr5/uXXfWemRweQJKnsuuiKjqCGs4CuMrOALkn15S5Y0SygS8rKLsAXokMEcoS7VG3z2njOcpmnaI4ePJZJkiSp9Lp73bKpvCygS5KkvFhAl5SlLwM7RYcIYieqVG1z23hOO+emK5kTHUCSJElLZwe6yswCuiRJyosFdElZGgb8Clg+OkiAJv6ZpTppp4De5GMrOtXOx1uSJEkFswNdZWYBXZIk5WV+dABJtbMR8N3oEAFGRAeQ1LZe0kjxwbKA3j470CVJkiR1xAK6JEmSpCr5OLB/dIiCOcpZqq52J/IMyzRFs9iBLkmSJKkjFtAlSZIkVc1PgLWiQxTIArpUXe0Wc+1Ab58d6JIkSZI6YgFdkuqrKzqAJEk5WRU4j+b8W2cBXaqudou5FtDb5zFCkiQNQFdT3k1JUhssoEuSJEmqor2Aw6NDFMQCulRd7XagO8K9fctEB5AkSZJUbRbQJUmSJFXVt4FXRIcogO/bpOryPO7iWUCXJEmS1BEvxEiSJEmqqmWA84ER0UFy1hMdQFLbZrX5vHmZpmiWUdEBJEmSJFWbBXRJkiRJVbYt8LXoEDnrjg4gqW2T23yeBfT22YEuSZIkqSMW0CVJkiRV3bHAHtEhcmQhTaquKW0+z6/79llAlyRJktQRC+iSJEmSqm4IaZT7ytFBcmIhTaouC+jFG0L9j/aQJEmSlCML6JJUX13RASRJKtA6wOnRIXJiIU2qLgvoMZaNDiBJUtl1eelQklqygC5JkiSpLt7X/6gbC2lSdVlAj7FGdABJkiRJ1WUBXZIkSVKd/BhYLzpExrqjA0hqW7sF9DmZpmieNaMDSJIkSaouC+iSJEmS6mRF4FfA0OggGXouOoCktk1u83l+3Xdm7egAkiRJkqrLArokSZKkutkV+Gx0iAxZSJOqq90OdL/uOzM2OoAkSZKk6rKALkmSJKmOTgJeFR0iI9OiA0hq2xNtPs+v+86sFR1AkiRJUnVZQJckSZJUR8OB84Flo4NkwEKaVE1zgafbfO70LIM0kAX08umKDiBJWliX35klqSUL6JJUX26DJUlNtznwregQGbCALlXT40Bfm891hHtnHOFePsOiA0iSJEkDZQFdkurLArokSfBJYN/oEB2aQftFOElxHu3gud4405nNogNoESOiA0iSFmYHuiS1ZgFdkurLbbAkSenfw3OANaKDdKAPu1GlKnqsg+c+m1mKZloDWDU6hBZiAV2SSqbLS4eS1JIFdEmqL3fBkiQlqwNnRYfo0JPRASQN2oQOnvtEZimaa+voAFqIBXRJKhk70CWpNQvoklRfboMlSXrRfsAnokN0wAK6VD2Pd/DcpzJL0VxbRgfQQpaJDiBJWpgd6JLUmgV0Saovd8GSJC3sNGDT6BBtshtVqp5xHTx3EtCdVZCGekV0AC1kpegAkqSF2YEuSa1ZQJek+nIbLEnSwkYDFwDDo4O0wQK6VD0PdPDc+diF3ikL6OUxHFguOoQkaWEW0CWpNQvokiRJUjnNjg5QU9sDx0eHaIMj3KVqmUnnN75MzCJIg22B173KYkx0AEnSohzhLkmt+UZCkurLXbAkVVc3sCfw5+ggNXUisFt0iEGygC5Vy4OkLvJOWEDvzArA1tEhBFhAl6RSsgNdklqzgC5J9eU2WJKq63PATcARwKzgLHU0BDiXVFypiseiA0galE7OP3/BIxm8RtPtGR1AAKwTHUCStCg70CWptWHRASRJuXEXLEnVdC7wg/7/fhT4JnByXJza2gD4IfCR4BwD9WB0gIr4KfD5nF57KPnedDGG/PZvo4EROb32iP7Xz0MX+XauLk9+10VuzuA1/Lrv3O7At6NDiHWjA0iSJEmDYQFdkurLArokVc8twCdf8nPfBj4AbFZ8nNr7MHA5cFF0kAGYThrjPjY6SMmtBkzN8fUn5/ja0ktl0cXedK8j3eTRHR2k4SygS1IJOcJdklpzhLsk1ZfbYEmqlknAu4A5L/n5buBTxcdpjDOpzoX9B6IDVIBjglUnFtA7NxrYPjqE/N4sSWVkAV2SWrOALkn15TZYkqqjB3gvaWT74lwN/La4OI0yBjiHarw3ui86QAVsHB1AytAEFr2pSoPnOejxNo0OIElalGegS1JrVbhIJElqj7tgSaqOLwJ/X8rvOQp4roAsTfRG4OjoEANgB/rSrQSsHR1CykgfMD46RA28KTqA2CI6gCRpUXagS1JrFtAlqb7cBktSNVxEOud8aZ4CTso5S5N9A9gmOsRSPBgdoCK2jA4gZcgbZzq3E7BBdIgGWx1YLTqEJGlRdqBLUmsW0CWpvtwFS1L53Ql8FJg/wN//A+D2/OI02kjgQmBUdJAl8O9+YHaODiBl6M7oADXQBbwnOkSDeVOTJJWUHeiS1JoFdEmSJCnGFGA/YNYgntMDHMHAC+4anC2Ar0eHWILHgEnRISrgNdEBpAz9LzpATXwoOkCD7RodQJK0eBbQJak1C+iSVF9ugyWpvHqB99Le2bY3Ar/INI0WdDSwT3SIJbgtOkAF7AgMiw4hZcTJE9nYDNg6OkRDvSE6gCRp8RzhLkmtWUCXpPpyFyxJ5XUi8LcOnv85YGo2UfQSXcDZwCrRQVq4JTpABawA7BYdQsrIQ8D06BA18d7oAA00Go/VkKTSsgNdklqzgC5J9eU2WJLK6WI6HxP+DPClDLJo8cYCP4sO0cKt0QEq4m3RAaSMzAfujg5RE+8HhkeHaJjXACOiQ0iSJEmDZQFdkurLAroklc89wEFkc4b5mcC/M3gdLd47gI9Eh1gMR7gPzNvw/a7qw3PQs/EyUhFdxdk/OoAkqTVHuEtSa15QkKT6chcsSeXyHKkoOzOj1+sDDiedp658nAFsHB3iJR4Cno0OUQHr4rm7qg8nT2TnaHyfVJThpH2PJKmkHOEuSa1ZQJek+nIbLEnl0Qd8CHgg49f9L+UdNV4Ho4HzgGHBORY0H7gxOkRFHBwdQMrI9dEBamQb4E3RIRpib2DV6BCSpNYsoEtSaxbQJam+3AZLUnl8A/hTTq/9BdKZ6MrHLqSPcZlcEx2gIvYH1osOIWVgHDApOkSNHBMdoCEOjA4gSVoyR7hLUmsW0CWpvtwFS1I5/BX4So6vPxU4PsfXF5wA7BQdYgHXRQeoiGHAUdEhpAzMB26KDlEjewLbRoeoubWAA6JDSJKWzA50SWrNArok1ZfbYEmKNw74AGmEe57Ow6JqnoYBvwKWjw7S7w5genSIivgosEp0CCkDN0QHqJkz8P1Snj4NjIwOIUlaMjvQJak1C+iSJElSPqYDbwWmFbDWfOAIYF4BazXVRsB3o0P068UzkQdqBeBL0SGkDPwzOkDN7AK8KzpETY0BDokOIUlaOjvQJak1C+iSVF9ugyUpznzgI8B9Ba55F/CjAtdroo+TztUuA7tRB+4QYJ3oEFKHbgVmRYeomW8AI6JD1NAhlGdiiyRpCSygS1JrFtAlqb7cBktSnG8DfwhY98vAEwHrNslPSGe7RvtLdIAKGQWcFR1C6lA38I/oEDWzMWnUuLKzJk79kKTKcIS7JLVmAV2S6stdsCTFuAL4fNDaM4DPBq3dFKuSzpyP/nf2HmB8cIYq2QfYNzqE1KG/RQeooeOA1aJD1MgXgeWiQ0iSJEmdsoAuSfUVfWFfkproceDDQF9ghovwfOy87UUa5x7t0ugAFXMOsEZ0CKkDV0YHqKExwBnRIWpiMzz7XJIqxRHuktSaBXRJqi+3wZJUvI8DzwRnmA8cDswLzlF3pwGbBGdwjPvgrA78NDqE1IEHgIeiQ9TQu4H3R4eouOHABf0/SpIqwhHuktSaBXRJqi93wZJUvInRAfrdBXwnOkTNjQZ+A4wIzHADaWy/Bu5twKHRIaQOOMY9H98HXhYdosKOBLaLDiFJGhw70CWpNQvoklRfboMlqdlOAh6JDlFz25I+zlHmAlcFrl9VPwReGx1CatNl0QFqalXSTVF2UA/e5sDJ0SEkSYNnAV2SWrOALkn15TZYkprteeDT0SEa4LPAHoHrXxS4dlUNB35P/Ah+qR1/A6ZHh6ipXYBvR4eomOVINx4sEx1EkjR4jnCXpNYsoEtSfbkLliT9Ec/JztsQ4Hxg5aD1LwWeDVq7ylYDrgE2jA4iDdIc0te98nEU8KnoEBUxFLgY2Do6SM157VZSbuxAl6TWhkUHaJAhwNjoEKqEWcBz0SEkSVJtHEHqkF42OkiNrQP8FDggYO1u0o0SBwesXXVjgcuB3YEng7NIg/EH4IPRIWrsu8B9eN780pwA7B0dogEsoEvKjR3oktSaBfTirAw8ER1ClfBT4NDoEKoFd8GSJIAJwKnAV6OD1Nz+wPuBCwLW/gUW0Nu1CXATqYj+SHAWaaCuAGaSxmcre8NJNynsRfr+oEUdDHw5OkRDWECXlBs70CWpNTdhklRfboMlSS84Bbg/OkQD/AhYP2DdG4DHA9ati/WAq4GtooNIA/Q88NfoEDU3GrgM2CE6SAkdAJyF7zeL4rVbSbmxgC5JrbkJk6T6chssSXpBN57pWoQVgV+SzoUtUh9wYcFr1s2GpE7Tt0YHkQboN9EBGmBF4O/AbtFBSmQf4FcU/+9ck3ntVpIkKYCbMEmqLwvokqQF/Q24ODpEA+wKHBuw7pmkQrratzxwKWlig++VVXaXAZOiQzTACsDlwH7RQUrg/aTR9iOigzSM/x5Jyo1noEtSa27CJKm+3AVLkl7qGNK5ucrX14BXF7zmI6Qx5OpMF3AcqcNyheAs0pJ0kyZeKH+jgD8CJwbniDIE+AHp++LI4CxN5LVbSblxhLskteYmTJLqy22wJOmlHicVd5Wv4cD5wLIFr3t6wevV2XuBB4C3RweRlsACenG6gK+Qzv4eFZylSKOAnwNHRgdpMK/dSsqNHeiS1JqbMEmqL3fBkqTF+R5wR3SIBtgM+FbBa15G6kRXNtYgjSv+LbBycBZpcW4Dbo8O0TAfB/4NbBEdpABbAP8BPhwdpOE8b15SbuxAl6TWLKBLUn25DZYkLU4PcDgwPzpIA3wS2LfA9fqAcwtcrykOAG4G3hAdRFqM86IDNNArgFuAT1PP62pdwEdJ3/e2Cs6ien6OSSoJC+iS1JqbMEmqL7fBkqRWbiSdZap8dZFG365R4Jo/A+YUuF5TbEg6Y/6vpOKZ6mEIsHF0iA79ApgdHaKBRgHfBa4DtgnOkqUtgX8AZ1P8MSRaPK/dSsqNI9wlqTU3YZIkSVIzHQtMiw7RAKuRusKLujr1FOmMXuXjzaSR2b8FXh6cRe1ZAfgQ6e9wEmkcd5WvHj8LXBAdosF2Bf5LunlpreAsnViRdEPA/4DXx0bRS3jtVlJu7ECXpNbchElSfbkNliQtydPACdEhGmIf4BMFrncaMK/A9ZqmizTW/U7Sx3r90DQaiJWBDwIXA08A55P+DlcGVgLWi4uWidOjAzTcUOBjwDjgVGCV2DiDshzwReAR0kj64bFxtBheu5WUGzvQJak1N2GSVF/ugiVJS/Nj4D/RIRriNGDTgtaagCP6i7AMcAypaHYJdm2WyTBSZ/BXgOtJNwz9AngXqWD4UtsXFy0XdwLXRIcQywKfI30P/glpHHpZrQYcTyqcn0y6kUTl5LVbSbmxA12SWnMTJkn15TZYkrQ0fcDh/T8qX8uSxiyPKGi9U4DegtZquqHAO0gFzNuBj7L4Iq3y00U6m/4Y4C/AVOAG4ETgtaSC+pJUvYAO8MPoAPo/o4FDSTc2XA98uP/nonUBewC/Bh4DvgmsGppIA9GF7+0lSZIKZwFdkurLN9mSpIG4BTgnOkRDbE9xY/MfAH5X0Fp60dbA2cAzwEXA24GRoYnqaSSwM3A06eM8EbiDNOnhLQz+BoY6FND/DDwcHUIL6SLdwHEeaQrC74GDKfas9GWBfUkd8ROAvwPvwe9LVTM0OoCkerIDXZJaW9pd2JKk6nIbLEkZB0cwAAAZ9ElEQVQaqONJhb7VooM0wBeAq4HrCljrK6SR1Z5pW7xRwLv7H9NII94vInWjzgnMVVUbAjsBO/Y/tiXbaQ7bZfhaUXpJHcU/iw6ixRoNvLP/AekmpxuAfwO3kbrVs/jesDrpa2Sn/sfOpO9HqjYboCTlwjPQJak1C+iSVF/ugiVJA/Us8HlS56zyNQQ4F3glMD3ntR4AfgockfM6WrIxpK7Tg4HngRtJN1FcTSqceYTCi0YAW5A6+bcGtul/5H1zz6rAeqQO3So7H/gS6c+ictuk//HR/v/vAR4FxgEPAZNJRxE8C8x+yXOHAcuTupLXBjZY4LFm3sEVwgK6pFzYgS5JrVlAl6T6chssSRqMn5Mu5O8cHaQBNiCdV/yRAtb6GvAhYIUC1tLSjQL27H8ATCGdnf5v4L/ArcBzMdEKNZr0dbAhsBkvFsw3I25iwvZUv4A+DzgZu9CraBjp62HD6CAqJQvoknJhB7oktWYBXZLqy12wJGkw5gOHkAp4vk/I34eBK4Df5LzOJOBU4Os5r6P2rALs3/+A9HX4IKmYfgtwN6kjdQKpQ7UqViONkl6LhbtjX3isHhetpe1Jo/ar7nzSUREbRAeRlBkL6JJyYQe6JLXmhTFJqi+3wZKkwboT+DFwZHSQhvgJcBNpbG+evg8cBqyT8zrqXBcvjnZ+7wI/Pw94hFRMfwB4mDTieVL/Y3L/Y27GeVYkTS946WOl/h/XYuFi+Wr9jypea9g+OkBG5gHfBc6IDiIpMxbQJeXCAroktVbFN7WSJEmS8nMCqRt2bHSQBhhDGp2/F/megz0bOA64IMc1lK/hvFhYf/MSft8M0lj4Fz6f5pDOXW9lKIuO9x/W/3Nj2kpaXXUpoAP8FDgc2Dw6iKRMjIgOIKmeHOEuSa1ZQJek+nIXLElqx3TgWCy2FuUNwNHAaTmvcyGpo3nfnNdRrOX7Hxq8VYH1gfGxMTLRQ7oZ6uLoIJIyYQFdUi7sQJek1hwBJEn15TZYktSuC4F/RIdokG8A2xSwzhHArALWkaqqTl3ovwf+GR1CUiYsoEvKhR3oktSaBXRJqi93wZKkThxG9ucpa/FGkm5aGJXzOhOAU3JeQ6qyOhXQAT4LzI8OIaljFtAlSZIKZgFdkurLArokqRMPAN+PDtEgW5A60fP2LeDeAtaRqqhuBfT/B/w1OoSkjllAl5QLR7hLUmsW0CWpvtwGS5I69TXqcR5wVRwF7JPzGt3AJ4G+nNeRqmjb6AA58OgGqfosoEvKhQV0SWrNArok1ZfbYElSp2YDn4kO0SBdwNnAKjmvcy3wzZzXkKpoNWC96BAZmwCcGh1CUkcsoEvKhWegS1JrFtAlqb7cBUuSsnAJjgAu0lhSET1vJwL/LmAdqWrqNsYdUgH9vugQktpmAV1SLuxAl6TWLKBLUn25DZYkZeUoYE50iAZ5O3BQzmv0AB8AZua8jlQ1dSygdwOfig4hqW0W0CXlwg50SWrNArok1Ze7YElSVh7CEcBFOx3YOOc1xgGfy3kNqWrqWEAHuJo0UURS9VhAl5QLO9AlqTUL6JIkSZIG4pvAA9EhGmQ0cD4wLOd1zgQuzXkNqUq2jQ6Qo0OAp6NDSBo0C+iScmEBXZJas4AuSfXlNliSlKW5OAK4aDsDX8h5jfnA+4E7c15HqorVgfWiQ+RkMvCJ6BCSBs0CuqRcOMJdklqzgC5J9eUuWJKUtatwBHDRTgB2ynmNWcB+pOKapPqOcQf4E3BedAhJg2IBXVIu7ECXpNYsoEtSfbkNliTl4WhgZnSIBhkGXAAsn/M644H3Ar05ryNVQZ0L6ABHAROiQ0gaMAvokiRJBbOALkn1ZQFdkpSHx4CTo0M0zIbAaQWsczXw1QLWkcquzuegA0wnjXLviw4iaUCGRweQVE+OcJek1iygS1J9uQuWJOXle8A90SEa5mPAAQWscxLwowLWkcrsVdEBCnAV3jAjVcXI6ACS6skR7pLUmgV0Saovt8GSpLx0A4cC86ODNMyPgbUKWOco4I8FrCOV1arAutEhCvB14JroEGq8HwCH4BEiS2IHuqRcWECXpNYsoEtSfbkNliTl6Qbg19EhGmZV4Dzy/ze+F3gf8K+c15HKrO7noEP6Wj8QeCI6iBrr78AxwFnA5OAsZWYHuqRcOMJdklqzgC5J9eUuWJKUt08D06JDNMxewBEFrPM8sB/wYAFrSWXUhAI6wCTgg9j9q+J1kyaevDDNZlJglrKzA11SLuxAl6TWLKBLUn25DZYk5e1p4CvRIRroW8ArClhnMqmI/lQBa0lls210gAJdAxwbHUKN823g7gX+/5moIBUwIjqApHqyA12SWrOALkmSJKkTPwL+Fx2iYZYBzqeYC+r3ATsD4wtYSyqTV0cHKNj3gNOjQ6gx7gG+9pKfezoiSEWMig4gqZ7sQJek1iygS1J9uQ2WJBWhFzgE6IsO0jDbAicVtNZ4YHcsoqtZVgVeFh2iYJ8hdaNLeeoDDieNcF+QHeitWUCXlAsL6JLUmgV0Saovt8GSpKLcDJwbHaKBPgvsUdBa44E9gccLWk8qg6acg/6CecDbgLuig6jWTgSuXczPW0BvbdnoAJIkSU1jAV2S6ssCuiSpSJ8jnZmt4gwBfgGsXNB644C9gEcLWk+K1qRz0F8wA3gnFjOVjxuAb7b4NT/nWrMDXVIuPANdklqzgC5J9eUuWJJUpGeBL0SHaKC1gbMKXO9eYDvgXwWuKUV5VXSAIA+SpltMiQ6iWnkKOADoafHrFtBbswNdUi4c4S5JrVlAl6T6chssSSraOVhYjfAu4P0FrjeFNM79rwWuKUVo2gj3Bd0N7EPqSJc6NR84CHh6Cb9nSb/WdHagS8qFHeiS1JoFdEmqL3fBkqSi9QFHAL3RQRroR8D6Ba43i3RW8k8LXFMq2urAOtEhAt0M7A90RwdR5Z0EXLGU3zOpiCAVZQe6pFzYgS5JrVlAl6T6chssSYpwK/CT6BANtCLwS2BogWv2AocBJ5O6C6U62i46QLCrgHdjEV3t+xVw4gB+nyPcW7MDXVIuLKBLUmsW0CWpvtwGS5KifBGYGB2igXYFji14zfnACcBbgGkFry0VYYfoACVwKbAXMDM6iCrnKuBgBnaT1UzSdBMtyg50SblwhLsktWYBXZLqy12wJCnKdOC46BANdRLw6oB1L+9f996AtaU8Nfkc9AVdRzoTfXp0EFXG7aQjAOYN4jl2oS+eHeiScmEHuiS1ZgFdkiRJUh5+CVwTHaKBhgHnE9Ot9iCwI6lbVaoLC+gvuhHYD5gRHUSl9yjwdgb/uWIBffEsoEvKhR3oktSaBXRJqi93wZKkaEcwuM4zZWMz4NtBa88gdRx+FegJyiBlaQ1gbHSIErkOeAPwdHQQldYE4PXA+DaeawF98RzhLikXdqBLUmsW0CWpvtwGS5Ki3QN8PzpEQx0G7Bu0dg9wIrAtcEdQBilLr4oOUDI3A9sBt0UHUencA+wEPNLm870xY/GWwff3kiRJhbKALkn15RtsSVIZnEjqRlOxuoCfA2sGZriLNNL9VKAvMIfUKce4L+pJYHfg2uAcKo+7gT2Apzp4DTvQF68Lx7hLyoEd6JLUmgV0Saovt8GSpDKYDXw2OkRDrQacS+yeYA5wPPBOYGJgDqkT20YHKKlpwJuB30cHUbi7gDfReQf5pAyy1JUFdEmZ8wx0SWrNArok1Ze7YElSWVwMXBYdoqHeBHwiOgRwKfByUjd6b3AWabAc4d7a88D+wCHAvOAsinEpaWz74xm8liPcW/McdEmZswNdklqzgC5J9eU2WJJUJkeRupFVvNOATaNDkKYRHA/sQDpDWaqKNYC1o0OU3Fmk8d1OmmiWU4F3AbMyej1HuLdmB7qkzNmBLkmtWUCXpPpyFyxJKpNxwLeiQzTUssCFwIjoIP1uA3YFTiB1r0pV4Bj3pbsR2Bn4b3QQ5a4POI50U1SWU0Uc4d6aHeiSMmcHuiS1ZgFdkurLbbAkqWxOAR6ODtFQ2wFfjg6xgG7gZGAjUueqY91Vdo5xH5gJwGuA75CKrKqfycB+5HNTnCPcW1suOoCk+rGALkmtWUCXpPpyGyxJKpvngU9Gh2iwzwO7RYd4iYmks5NfBVwbG0Vaou2jA1TIXOBYUjf6g8FZlK3LgS2Av+b0+pPxhqpWVogOIKl+HOEuSa1ZQJckSZJUpCuBP0aHaKghwLmU8yL8/0jnJ7+P1MEqlY0j3AfvP8A2wA+jg6hj84CjgbeQ75j1XmBKjq9fZctHB5BUP3agS1JrFtAlqb7cBkuSyupIYFZ0iIbaADg9OkQL84FfA5sAh2EhXeUyFxgdHaKCngeOAt4GPBqcRe0ZD+wN/ID0fTpvnoO+eBbQJWXODnRJas0CuiTVl7tgSVJZPQZ8PTpEg30IeE90iCXoBs4ENgTeDdwXG0cNNgs4C9iB9PnojT/t+xOwKfBV0s0IKr+5wPGkm5quKXBdz0FfvDJOj5EkSaotC+iSVF8W0CVJZfZd4N7oEA32E2Dd6BBL0Qf8DtgaOBi4PzaOGuQO4DOkiQ2HAP+NjVMbc4ATgVcD/4yNoqX4L7ALcCppfHuR7EBfPDvQJWXOEe6S1JoFdEmqL7fBkqQy6wYOpZhxsFrUGOCXVOM94TzS2e2bkTqBfwn0hCZSHd1P6rZdj3Ru92lYyMvLHcBrSZMwHgnOooVNBT4N7AjcGpThmaB1y84OdEmZs4AuSa1V4WKJJKk9boMlSWV3PXBRdIgGex1wTHSIQfovaQT9FsAPgemxcVRxTwA/AnYjfU6diud0F2U+6fv/JqQuf8d2x5pOuoHkZcD3gN7ALH4uLJ4d6JIy5xnoktSaBXRJqi93wZKkKjgGeC46RIN9ndRtWzUPAkcB65CKb//EaQYamIeB75DGU68LHEG6macvMlSD9ZDOmd+S1PXvOfPF6gPOB15BuoGkDB9/O9AXzw50SZmzA12SWrOALkn15TZYklQFT5HOxFWMkcCFwKjoIG2aQSq+7UrqZP0ajoTWwnqA64DjSEXCjYBjgX9h0bxMpvDiufPfxOkSeesFfgO8EvgI5Zq8YAF98exAl5Q5O9AlqTUL6JJUX+6CJUlVcTpwW3SIBtsC+EZ0iAyMA75CKpDuBvwUmBiaSFHGAecA7wZWA14PfAu4KzCTBmYS8AVgfdLNVZMjw9TQHOBM0g1H7wXujI2zWBbQF88CuqTM2YEuSa1ZQJek+nIbLEmqil7SGGVHcMc5CnhzdIiMzCeN5D4UGAtsRTrb1zHv9TSP9Hd7KrAnaczxxsDHgN8B0+KiqQNTga+SzuQ+CLglNk7lPQucQrox4TDSUQZlZQF98RzhLilzFtAlqbVh0QEkSZIkiVQAO49UKFHxuoCfAVuTRinXyd39j1NJ5yy/Ddgb2BkYHphL7ekD7iDdJHEdcAOpa1n1NIf0b8N5wI6km632B5aJi1QZ84FrgbOBS0gfyyqwgL54dqBLypwj3CWpNQvoklRf7oIlSVVzLPBWYNXoIA01llRoeUd0kBy9UEz/BrAcsDupa3kvYNPAXGrtYeB/wK39P/4Lu8qb6t/9j08BBwIfAnYJTVROE0k3HPycdJxB1cwAngdGRQcpGTvQVajpc7qZOntudIzKmT6nOzrCoMzu7vHvWaF6euf7OdimOfN6oyPUXjvFla2BlbMOIun/PAk8ELT2EGDboLWrbjIwITrES2wFjIwOUUGzgPuiQ9TEasC60SEq6n5gZuD6awJrB65fZfeQLvqqfRsCK0WHaLjbgZ7oEAHWJRXUdyYV5bbEY8+K1Et6H/RCofyFHy2Wa0k2AT5IOu9+k+AskSaQuswvAW4iTWqosq1xQshL9ZG+J2qgDvjtUFaa2sT9jCRJWrKrOOuQvZf2m+xOlCRJkiRpUSsAO5EK6jsBO+B0hCx0A+NJnbEPkormt5Fu3JgVF0s1sDFpism+wK7UuwDbB9wJ/JVUNP9vbByphCygS5KkxRtQAd0R7pIkSZIkLWo6cFX/4wUrkIp0WwJbLPDjBniD+oKmk4rj95BG5j+8wGNqYC7V24PAaf2PMaSJErsBrwW2AYbGRcvEPcA1/Y/rSFPQJEmSJOXAArokSZIkSQMzndTp+dJuzzWAjYCX9/+44GO1IgMWYDbwOOmc5cf6f3yi//Fk/689QRrJLkWZBvyh/wHp5pfX9D+2JRXUy3xczaOkcd0vHGdwM/BUaCJJkiSpQSygS5IkSZLUmaf7Hzct5tdGA2uSiuyrveS/1wBWJnXLjgFW7H/kPXr6eWBG/2Ma6caAGQs8nut/vPD/CxbJPZNcVTQduLz/8YLVgFf2PzYGNiTd9PIyiulW7+HF4wweWOBxKzClgPUlSZIktWAB/f+3d3+hdZ4FHMd/T2LbtdXCNm8cXsguBG+GOHEgiAjeDFa8WvEPKtMtCZs6NvHCm1G8kTFopxebSVedIgxXGMwVBKduFzIcozKZQzM3BQfTLbS1f9KGhpzHi5yxUHScJCd5Tt/z+cAhaXne9/xuQsP5pjkAAACwdRaTvNZ/DGpv3onpe9b8/a7L/rzWcpLz/c97WQ3gb/tPktr//FxWwx2Mu4UkT/cfa+1I8qEkH0xy7ZrHNf3He5NclWR3Vr8ed6259nxWvxYXk1zqfzyZ1V+3vtD/eDLJW0n+0T8LAACMGAEdAAAARsti//FG6yEwhpaz+n7qf2s9BAAAaGOi9QAAAAAAAAAAGAUCOgAAAAAAAABEQAcAAAAAAACAJAI6AAAAAAAAACQR0AEAAAAAAAAgiYAOAAAAAAAAAEkEdAAAAAAAAABIIqADAAAAAAAAQBIBHQAAAAAAAACSCOgAAAAAAAAAkERABwAAAAAAAIAkAjoAAAAAAAAAJBHQAQAAAAAAACCJgA4AAAAAAAAASQR0AAAAAAAAAEgioAMAAAAAAABAEgEdAAAAAAAAAJII6AAAAAAAAACQREAHAAAAAAAAgCQCOgAAAAAAAAAkEdABAAAAAAAAIImADgAAAAAAAABJBHQAAAAAAAAASCKgAwAAAAAAAEASAR0AAAAAAAAAkgjoAAAAAAAAAJBEQAcAAAAAAACAJAI6AAAAAAAAACQR0AEAAAAAAAAgiYAOAAAAAAAAAEkEdAAAAAAAAABIIqADAAAAAAAAQBIBHQAAAAAAAACSCOgAAAAAAAAAkERABwAAAAAAAIAkAjoAAAAAAAAAJBHQAQAAAAAAACCJgA4AAAAAAAAASQR0AAAAAAAAAEgioAMAAAAAAABAEgEdAAAAAAAAAJII6AAAAAAAdMmxAytJLrWeAQCMnAuDHBLQAQAAAADomvOtBwAAI6aWs4McE9ABAAAAAOiagV4gBwDGSKnnBjkmoAMAAAAA0DUCOgBwuTODHBLQAQAAAADomldbDwAARkwtrw1yTEAHAAAAAKBr/tp6AAAwcgb6/kBABwAAAACgW0qdbz0BABgxvQkBHQAAAACAMVTLn1tPAABGyhs5evupQQ4K6AAAAAAAdMt1/3oxyULrGQDAiKjlN4MeFdABAAAAAOiWgwd7SZ5tPQMAGBETvd8OfHQrdwAAAAAAQCPPtB4AAIyIyZWBvy8Q0AEAAAAA6J7exBNJllvPAAAaK/UPeeiu1wc9LqADAAAAANA9j9zxZpJft54BADT30/UcFtABAAAAAOiqdb1gDgB0zsXU8th6LhDQAQAAAADopks7n0qy0HoGANDMk5mbPrOeCwR0AAAAAAC66dHblpLc33oGANBEL72J7633IgEdAAAAAIAuezjJW61HAADbrJZf5JE7/rLeywR0AAAAAAC6a276QpLDrWcAANtqJaV+fyMXCugAAAAAAHTb6asPJXm59QwAYNs8mLnplzZyoYAOAAAAAEC3HTtwKcnXk/RaTwEAttzfk9y30YsFdAAAAAAAum9u+vnU8pPWMwCALVbqvf23cNkQAR0AAAAAgPGwvOMbSf7UegYAsEVK/UFmZ57czC0EdAAAAAAAxsOjty2llgNJzrWeAgAM3XOp5TubvYmADgAAAADA+Dgy9UpKvbv1DABgqE4n+Urmppc3e6PJIYwBAAAAAIArx4njL+bG/aeT3Nx6CgCwaedS6mczN/PyMG4moAMAAAAAMH5OHH8+H79lV1I+1XoKALBhS0n2Z27muWHdUEAHAAAAAGA8nXjqd7nxxPuTfKL1FABg3ZZSyxdzZPpXw7xpGebNAAAAAADgijM1+60kh5NMtJ4CAAzkzdSyP0emXhj2jQV0AAAAAACY/tEXUsuPk1zVegoA8K5ezeTKLXn4zvmtuLmfpgMAAAAAgNmZxzK58tEkf2w9BQD4v36YvYs3bFU8T/wPdAAAAAAAeMc9h3Znce8DSe6M19ABYFScTal3ZXbm51v9RP7xBwAAAACAy03NfizJQ0luaj0FAMZYTXIkK5PfzdHbT23HEwroAAAAAADwv0zN7kgtd6fU+5K8r/UcABgz8yn1m5mdeXo7n1RABwAAAACAd/Pln+3NnotfSs23k3y49RwA6LRSj6eW+zM3/fsmT9/iSQEAAAAA4Ipz6+M7c82pA6nlq0k+k2Sy9SQA6IizKfWJ1HK0VTh/m4AOAAAAAADr9bWj12XH8udTy+ey+j7pu1pPAoArzMkkz6bUY9lz4Zc5fO/F1oMSAR0AAAAAADbnnkO7c2HPJ1PLp1PLDSn1I0muT/Ke1tMAYEScT8l8auaTvJBSn8kH/v1SDh7stR52OQEdAAAAAACG7dbHd+bq09dnorcvK5P7MtHbl1r8yncAxkOpS1mZXExyJhO9hcxN/7P1JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYuP8CqWOPJQvVLuAAAAAASUVORK5CYII="

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(true) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjBkZjBlYzhmNjQ0ZjVjYmU4ZDUiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL21haW4uc2Nzcz9mZTcyIiwid2VicGFjazovLy8uL3N0eWxlcy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9naXRodWIucG5nIiwid2VicGFjazovLy8uL3R3aXR0ZXIucG5nIiwid2VicGFjazovLy8uL2xpbmtlZGluLnBuZyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiXSwibmFtZXMiOlsiJCIsIndpbmRvdyIsImRvY3VtZW50IiwidW5kZWZpbmVkIiwiTkFNRSIsIk1BR0lDX05VTUJFUiIsIkRFRkFVTFRTIiwicmVsYXRpdmVJbnB1dCIsImNsaXBSZWxhdGl2ZUlucHV0IiwiY2FsaWJyYXRpb25UaHJlc2hvbGQiLCJjYWxpYnJhdGlvbkRlbGF5Iiwic3VwcG9ydERlbGF5IiwiY2FsaWJyYXRlWCIsImNhbGlicmF0ZVkiLCJpbnZlcnRYIiwiaW52ZXJ0WSIsImxpbWl0WCIsImxpbWl0WSIsInNjYWxhclgiLCJzY2FsYXJZIiwiZnJpY3Rpb25YIiwiZnJpY3Rpb25ZIiwib3JpZ2luWCIsIm9yaWdpblkiLCJQbHVnaW4iLCJlbGVtZW50Iiwib3B0aW9ucyIsIiRjb250ZXh0IiwiZGF0YSIsIiRsYXllcnMiLCJmaW5kIiwicGFyc2VGbG9hdCIsImtleSIsImV4dGVuZCIsImNhbGlicmF0aW9uVGltZXIiLCJjYWxpYnJhdGlvbkZsYWciLCJlbmFibGVkIiwiZGVwdGhzIiwicmFmIiwiYm91bmRzIiwiZXgiLCJleSIsImV3IiwiZWgiLCJlY3giLCJlY3kiLCJlcngiLCJlcnkiLCJjeCIsImN5IiwiaXgiLCJpeSIsIm14IiwibXkiLCJ2eCIsInZ5Iiwib25Nb3VzZU1vdmUiLCJiaW5kIiwib25EZXZpY2VPcmllbnRhdGlvbiIsIm9uT3JpZW50YXRpb25UaW1lciIsIm9uQ2FsaWJyYXRpb25UaW1lciIsIm9uQW5pbWF0aW9uRnJhbWUiLCJvbldpbmRvd1Jlc2l6ZSIsImluaXRpYWxpc2UiLCJwcm90b3R5cGUiLCJ0cmFuc2Zvcm1TdXBwb3J0IiwidmFsdWUiLCJjcmVhdGVFbGVtZW50IiwicHJvcGVydHlTdXBwb3J0IiwicHJvcGVydHlWYWx1ZSIsImZlYXR1cmVTdXBwb3J0IiwiY3NzUHJvcGVydHkiLCJqc1Byb3BlcnR5IiwiaSIsImwiLCJ2ZW5kb3JzIiwibGVuZ3RoIiwic3R5bGUiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnRPdmVyZmxvdyIsIm92ZXJmbG93IiwiYXBwZW5kQ2hpbGQiLCJiYWNrZ3JvdW5kIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJyZW1vdmVDaGlsZCIsInd3Iiwid2giLCJ3Y3giLCJ3Y3kiLCJ3cngiLCJ3cnkiLCJwb3J0cmFpdCIsImRlc2t0b3AiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtYXRjaCIsIm1vdGlvblN1cHBvcnQiLCJEZXZpY2VNb3Rpb25FdmVudCIsIm9yaWVudGF0aW9uU3VwcG9ydCIsIkRldmljZU9yaWVudGF0aW9uRXZlbnQiLCJvcmllbnRhdGlvblN0YXR1cyIsInRyYW5zZm9ybTJEU3VwcG9ydCIsInRyYW5zZm9ybTNEU3VwcG9ydCIsInByb3BlcnR5Q2FjaGUiLCJjc3MiLCJwb3NpdGlvbiIsImFjY2VsZXJhdGUiLCJ1cGRhdGVMYXllcnMiLCJ1cGRhdGVEaW1lbnNpb25zIiwiZW5hYmxlIiwicXVldWVDYWxpYnJhdGlvbiIsImRpc3BsYXkiLCJsZWZ0IiwidG9wIiwiZmlyc3QiLCJlYWNoIiwicHJveHkiLCJpbmRleCIsInB1c2giLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJNYXRoIiwibWF4IiwidXBkYXRlQm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJkZWxheSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZGlzYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNhbGlicmF0ZSIsIngiLCJ5IiwiaW52ZXJ0IiwiZnJpY3Rpb24iLCJzY2FsYXIiLCJsaW1pdCIsIm9yaWdpbiIsImNsYW1wIiwibWluIiwicHJvcGVydHkiLCJjYW1lbENhc2UiLCIkZWxlbWVudCIsInNldFBvc2l0aW9uIiwiZXZlbnQiLCJkeCIsImR5IiwiYWJzIiwiaXNOYU4iLCJkZXB0aCIsImxheWVyIiwieE9mZnNldCIsInlPZmZzZXQiLCJiZXRhIiwiZ2FtbWEiLCJjbGllbnRYIiwiY2xpZW50WSIsIkFQSSIsImZuIiwiYXJncyIsImFyZ3VtZW50cyIsIiR0aGlzIiwicGx1Z2luIiwiYXBwbHkiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImpRdWVyeSIsIlplcHRvIiwibGV0dGVycyIsIndyYXBwZXIxIiwiYWRkQ2xhc3MiLCJzY2VuZSIsImoiLCJlbCIsInRleHQiLCJhdHRyIiwiYXBwZW5kIiwicGFyYWxsYXgiLCJsZXR0ZXJzMiIsIndyYXBwZXIyIiwic21pbGUiLCJzaWRlUGFuZWwiLCJyZWFkeSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3BDQTs7QUFFQSx3Qjs7Ozs7Ozs7QUNKQTs7Ozs7OztBQU9BLEVBQUMsQ0FB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O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRixxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUYsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsaUJBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxnQkFBZ0I7QUFDM0IsY0FBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxpQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZTs7QUFFZixVQUFTOztBQUVUO0FBQ0EsU0FBUSxpQ0FBaUM7QUFDekMsU0FBUSxvQkFBb0I7QUFDNUIsU0FBUSxzQ0FBc0M7QUFDOUMsU0FBUTtBQUNSLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZEQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsMENBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDhDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRSx1Q0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsV0FBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxXQUFVLFVB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Q0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTs7QUFFQSxFQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsU0FBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXdDLHNDQUFzQztBQUM5RSxxQ0FBb0MsdUNBQXVDO0FBQzNFLHFDQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixRQUFPO0FBQ1A7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQztBQUNwQyxzQ0FBcUM7QUFDckMscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixhQUFhO0FBQ3BDLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRTtBQUNGOztBQUVBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsdUJBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGVBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnRUFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNO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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7O0FBRUEsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7OztBQUtEOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUgsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLE1BQUs7QUFDTDs7QUFFQSxZQUFXO0FBQ1gsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7O0FBRWhCLGlEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQWtDOztBQUVsQztBQUNBLHVCQUFzQjtBQUN0Qiw0QkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUEsb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyx1QkFBdUI7QUFDbEMsWUFBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkIsNkRBQTRELGVBQWU7QUFDM0U7QUFDQTs7QUFFQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RDtBQUN2RDs7QUFFQSw4QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBiMGRmMGVjOGY2NDRmNWNiZThkNVxuICoqLyIsIi8vQWxsIHNjcmlwdHMgc3RhcnQgZnJvbSBzcmMvaW5kZXguanNcbi8vUGxlYXNlIGRvIG5vdCBhZGQgYW55dGhpbmcgaGVyZVxuaW1wb3J0ICcuL3NyYy9pbmRleCc7XG5cbmltcG9ydCAnLi9zdHlsZXMvbWFpbi5zY3NzJztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbWFpbi5qc1xuICoqLyIsIi8qKlxuICogalF1ZXJ5IHx8IFplcHRvIFBhcmFsbGF4IFBsdWdpblxuICogQGF1dGhvciBNYXR0aGV3IFdhZ2VyZmllbGQgLSBAd2FnZXJmaWVsZFxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBwYXJhbGxheCBlZmZlY3QgYmV0d2VlbiBhbiBhcnJheSBvZiBsYXllcnMsXG4gKiAgICAgICAgICAgICAgZHJpdmluZyB0aGUgbW90aW9uIGZyb20gdGhlIGd5cm9zY29wZSBvdXRwdXQgb2YgYSBzbWFydGRldmljZS5cbiAqICAgICAgICAgICAgICBJZiBubyBneXJvc2NvcGUgaXMgYXZhaWxhYmxlLCB0aGUgY3Vyc29yIHBvc2l0aW9uIGlzIHVzZWQuXG4gKi9cbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgLy8gU3RyaWN0IE1vZGVcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENvbnN0YW50c1xuICB2YXIgTkFNRSA9ICdwYXJhbGxheCc7XG4gIHZhciBNQUdJQ19OVU1CRVIgPSAzMDtcbiAgdmFyIERFRkFVTFRTID0ge1xuICAgIHJlbGF0aXZlSW5wdXQ6IGZhbHNlLFxuICAgIGNsaXBSZWxhdGl2ZUlucHV0OiBmYWxzZSxcbiAgICBjYWxpYnJhdGlvblRocmVzaG9sZDogMTAwLFxuICAgIGNhbGlicmF0aW9uRGVsYXk6IDUwMCxcbiAgICBzdXBwb3J0RGVsYXk6IDUwMCxcbiAgICBjYWxpYnJhdGVYOiBmYWxzZSxcbiAgICBjYWxpYnJhdGVZOiB0cnVlLFxuICAgIGludmVydFg6IHRydWUsXG4gICAgaW52ZXJ0WTogdHJ1ZSxcbiAgICBsaW1pdFg6IGZhbHNlLFxuICAgIGxpbWl0WTogZmFsc2UsXG4gICAgc2NhbGFyWDogMTAuMCxcbiAgICBzY2FsYXJZOiAxMC4wLFxuICAgIGZyaWN0aW9uWDogMC4xLFxuICAgIGZyaWN0aW9uWTogMC4xLFxuICAgIG9yaWdpblg6IDAuNSxcbiAgICBvcmlnaW5ZOiAwLjVcbiAgfTtcblxuICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xuXG4gICAgLy8gRE9NIENvbnRleHRcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLy8gU2VsZWN0aW9uc1xuICAgIHRoaXMuJGNvbnRleHQgPSAkKGVsZW1lbnQpLmRhdGEoJ2FwaScsIHRoaXMpO1xuICAgIHRoaXMuJGxheWVycyA9IHRoaXMuJGNvbnRleHQuZmluZCgnLmxheWVyJyk7XG5cbiAgICAvLyBEYXRhIEV4dHJhY3Rpb25cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNhbGlicmF0ZVg6IHRoaXMuJGNvbnRleHQuZGF0YSgnY2FsaWJyYXRlLXgnKSB8fCBudWxsLFxuICAgICAgY2FsaWJyYXRlWTogdGhpcy4kY29udGV4dC5kYXRhKCdjYWxpYnJhdGUteScpIHx8IG51bGwsXG4gICAgICBpbnZlcnRYOiB0aGlzLiRjb250ZXh0LmRhdGEoJ2ludmVydC14JykgfHwgbnVsbCxcbiAgICAgIGludmVydFk6IHRoaXMuJGNvbnRleHQuZGF0YSgnaW52ZXJ0LXknKSB8fCBudWxsLFxuICAgICAgbGltaXRYOiBwYXJzZUZsb2F0KHRoaXMuJGNvbnRleHQuZGF0YSgnbGltaXQteCcpKSB8fCBudWxsLFxuICAgICAgbGltaXRZOiBwYXJzZUZsb2F0KHRoaXMuJGNvbnRleHQuZGF0YSgnbGltaXQteScpKSB8fCBudWxsLFxuICAgICAgc2NhbGFyWDogcGFyc2VGbG9hdCh0aGlzLiRjb250ZXh0LmRhdGEoJ3NjYWxhci14JykpIHx8IG51bGwsXG4gICAgICBzY2FsYXJZOiBwYXJzZUZsb2F0KHRoaXMuJGNvbnRleHQuZGF0YSgnc2NhbGFyLXknKSkgfHwgbnVsbCxcbiAgICAgIGZyaWN0aW9uWDogcGFyc2VGbG9hdCh0aGlzLiRjb250ZXh0LmRhdGEoJ2ZyaWN0aW9uLXgnKSkgfHwgbnVsbCxcbiAgICAgIGZyaWN0aW9uWTogcGFyc2VGbG9hdCh0aGlzLiRjb250ZXh0LmRhdGEoJ2ZyaWN0aW9uLXknKSkgfHwgbnVsbCxcbiAgICAgIG9yaWdpblg6IHBhcnNlRmxvYXQodGhpcy4kY29udGV4dC5kYXRhKCdvcmlnaW4teCcpKSB8fCBudWxsLFxuICAgICAgb3JpZ2luWTogcGFyc2VGbG9hdCh0aGlzLiRjb250ZXh0LmRhdGEoJ29yaWdpbi15JykpIHx8IG51bGxcbiAgICB9O1xuXG4gICAgLy8gRGVsZXRlIE51bGwgRGF0YSBWYWx1ZXNcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGFba2V5XSA9PT0gbnVsbCkgZGVsZXRlIGRhdGFba2V5XTtcbiAgICB9XG5cbiAgICAvLyBDb21wb3NlIFNldHRpbmdzIE9iamVjdFxuICAgICQuZXh0ZW5kKHRoaXMsIERFRkFVTFRTLCBvcHRpb25zLCBkYXRhKTtcblxuICAgIC8vIFN0YXRlc1xuICAgIHRoaXMuY2FsaWJyYXRpb25UaW1lciA9IG51bGw7XG4gICAgdGhpcy5jYWxpYnJhdGlvbkZsYWcgPSB0cnVlO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwdGhzID0gW107XG4gICAgdGhpcy5yYWYgPSBudWxsO1xuXG4gICAgLy8gRWxlbWVudCBCb3VuZHNcbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5leCA9IDA7XG4gICAgdGhpcy5leSA9IDA7XG4gICAgdGhpcy5ldyA9IDA7XG4gICAgdGhpcy5laCA9IDA7XG5cbiAgICAvLyBFbGVtZW50IENlbnRlclxuICAgIHRoaXMuZWN4ID0gMDtcbiAgICB0aGlzLmVjeSA9IDA7XG5cbiAgICAvLyBFbGVtZW50IFJhbmdlXG4gICAgdGhpcy5lcnggPSAwO1xuICAgIHRoaXMuZXJ5ID0gMDtcblxuICAgIC8vIENhbGlicmF0aW9uXG4gICAgdGhpcy5jeCA9IDA7XG4gICAgdGhpcy5jeSA9IDA7XG5cbiAgICAvLyBJbnB1dFxuICAgIHRoaXMuaXggPSAwO1xuICAgIHRoaXMuaXkgPSAwO1xuXG4gICAgLy8gTW90aW9uXG4gICAgdGhpcy5teCA9IDA7XG4gICAgdGhpcy5teSA9IDA7XG5cbiAgICAvLyBWZWxvY2l0eVxuICAgIHRoaXMudnggPSAwO1xuICAgIHRoaXMudnkgPSAwO1xuXG4gICAgLy8gQ2FsbGJhY2tzXG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24gPSB0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uT3JpZW50YXRpb25UaW1lciA9IHRoaXMub25PcmllbnRhdGlvblRpbWVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNhbGlicmF0aW9uVGltZXIgPSB0aGlzLm9uQ2FsaWJyYXRpb25UaW1lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25BbmltYXRpb25GcmFtZSA9IHRoaXMub25BbmltYXRpb25GcmFtZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25XaW5kb3dSZXNpemUgPSB0aGlzLm9uV2luZG93UmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXNlXG4gICAgdGhpcy5pbml0aWFsaXNlKCk7XG4gIH1cblxuICBQbHVnaW4ucHJvdG90eXBlLnRyYW5zZm9ybVN1cHBvcnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHByb3BlcnR5U3VwcG9ydCA9IGZhbHNlO1xuICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gbnVsbDtcbiAgICB2YXIgZmVhdHVyZVN1cHBvcnQgPSBmYWxzZTtcbiAgICB2YXIgY3NzUHJvcGVydHkgPSBudWxsO1xuICAgIHZhciBqc1Byb3BlcnR5ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudmVuZG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnZlbmRvcnNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgY3NzUHJvcGVydHkgPSB0aGlzLnZlbmRvcnNbaV1bMF0gKyAndHJhbnNmb3JtJztcbiAgICAgICAganNQcm9wZXJ0eSA9IHRoaXMudmVuZG9yc1tpXVsxXSArICdUcmFuc2Zvcm0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzUHJvcGVydHkgPSAndHJhbnNmb3JtJztcbiAgICAgICAganNQcm9wZXJ0eSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuc3R5bGVbanNQcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wZXJ0eVN1cHBvcnQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICBjYXNlICcyRCc6XG4gICAgICAgIGZlYXR1cmVTdXBwb3J0ID0gcHJvcGVydHlTdXBwb3J0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzNEJzpcbiAgICAgICAgaWYgKHByb3BlcnR5U3VwcG9ydCkge1xuICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICB2YXIgZG9jdW1lbnRPdmVyZmxvdyA9IGRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGJvZHkpO1xuICAgICAgICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgYm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVtqc1Byb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgxcHgsMXB4LDFweCknO1xuICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKGNzc1Byb3BlcnR5KTtcbiAgICAgICAgICBmZWF0dXJlU3VwcG9ydCA9IHByb3BlcnR5VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eVZhbHVlLmxlbmd0aCA+IDAgJiYgcHJvcGVydHlWYWx1ZSAhPT0gXCJub25lXCI7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gZG9jdW1lbnRPdmVyZmxvdztcbiAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZVN1cHBvcnQ7XG4gIH07XG5cbiAgUGx1Z2luLnByb3RvdHlwZS53dyA9IG51bGw7XG4gIFBsdWdpbi5wcm90b3R5cGUud2ggPSBudWxsO1xuICBQbHVnaW4ucHJvdG90eXBlLndjeCA9IG51bGw7XG4gIFBsdWdpbi5wcm90b3R5cGUud2N5ID0gbnVsbDtcbiAgUGx1Z2luLnByb3RvdHlwZS53cnggPSBudWxsO1xuICBQbHVnaW4ucHJvdG90eXBlLndyeSA9IG51bGw7XG4gIFBsdWdpbi5wcm90b3R5cGUucG9ydHJhaXQgPSBudWxsO1xuICBQbHVnaW4ucHJvdG90eXBlLmRlc2t0b3AgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWR8QW5kcm9pZHxCbGFja0JlcnJ5fEJCMTB8bW9iaXx0YWJsZXR8b3BlcmEgbWluaXxuZXh1cyA3KS9pKTtcbiAgUGx1Z2luLnByb3RvdHlwZS52ZW5kb3JzID0gW251bGwsWyctd2Via2l0LScsJ3dlYmtpdCddLFsnLW1vei0nLCdNb3onXSxbJy1vLScsJ08nXSxbJy1tcy0nLCdtcyddXTtcbiAgUGx1Z2luLnByb3RvdHlwZS5tb3Rpb25TdXBwb3J0ID0gISF3aW5kb3cuRGV2aWNlTW90aW9uRXZlbnQ7XG4gIFBsdWdpbi5wcm90b3R5cGUub3JpZW50YXRpb25TdXBwb3J0ID0gISF3aW5kb3cuRGV2aWNlT3JpZW50YXRpb25FdmVudDtcbiAgUGx1Z2luLnByb3RvdHlwZS5vcmllbnRhdGlvblN0YXR1cyA9IDA7XG4gIFBsdWdpbi5wcm90b3R5cGUudHJhbnNmb3JtMkRTdXBwb3J0ID0gUGx1Z2luLnByb3RvdHlwZS50cmFuc2Zvcm1TdXBwb3J0KCcyRCcpO1xuICBQbHVnaW4ucHJvdG90eXBlLnRyYW5zZm9ybTNEU3VwcG9ydCA9IFBsdWdpbi5wcm90b3R5cGUudHJhbnNmb3JtU3VwcG9ydCgnM0QnKTtcbiAgUGx1Z2luLnByb3RvdHlwZS5wcm9wZXJ0eUNhY2hlID0ge307XG5cbiAgUGx1Z2luLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBDb25maWd1cmUgU3R5bGVzXG4gICAgaWYgKHRoaXMuJGNvbnRleHQuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgdGhpcy4kY29udGV4dC5jc3Moe1xuICAgICAgICBwb3NpdGlvbjoncmVsYXRpdmUnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYXJkd2FyZSBBY2NlbGVyYXRlIENvbnRleHRcbiAgICB0aGlzLmFjY2VsZXJhdGUodGhpcy4kY29udGV4dCk7XG5cbiAgICAvLyBTZXR1cFxuICAgIHRoaXMudXBkYXRlTGF5ZXJzKCk7XG4gICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5lbmFibGUoKTtcbiAgICB0aGlzLnF1ZXVlQ2FsaWJyYXRpb24odGhpcy5jYWxpYnJhdGlvbkRlbGF5KTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLnVwZGF0ZUxheWVycyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gQ2FjaGUgTGF5ZXIgRWxlbWVudHNcbiAgICB0aGlzLiRsYXllcnMgPSB0aGlzLiRjb250ZXh0LmZpbmQoJy5sYXllcicpO1xuICAgIHRoaXMuZGVwdGhzID0gW107XG5cbiAgICAvLyBDb25maWd1cmUgTGF5ZXIgU3R5bGVzXG4gICAgdGhpcy4kbGF5ZXJzLmNzcyh7XG4gICAgICBwb3NpdGlvbjonYWJzb2x1dGUnLFxuICAgICAgZGlzcGxheTonYmxvY2snLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0pO1xuICAgIHRoaXMuJGxheWVycy5maXJzdCgpLmNzcyh7XG4gICAgICBwb3NpdGlvbjoncmVsYXRpdmUnXG4gICAgfSk7XG5cbiAgICAvLyBIYXJkd2FyZSBBY2NlbGVyYXRlIExheWVyc1xuICAgIHRoaXMuYWNjZWxlcmF0ZSh0aGlzLiRsYXllcnMpO1xuXG4gICAgLy8gQ2FjaGUgRGVwdGhzXG4gICAgdGhpcy4kbGF5ZXJzLmVhY2goJC5wcm94eShmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgdGhpcy5kZXB0aHMucHVzaCgkKGVsZW1lbnQpLmRhdGEoJ2RlcHRoJykgfHwgMCk7XG4gICAgfSwgdGhpcykpO1xuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUudXBkYXRlRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMud3cgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLndoID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHRoaXMud2N4ID0gdGhpcy53dyAqIHRoaXMub3JpZ2luWDtcbiAgICB0aGlzLndjeSA9IHRoaXMud2ggKiB0aGlzLm9yaWdpblk7XG4gICAgdGhpcy53cnggPSBNYXRoLm1heCh0aGlzLndjeCwgdGhpcy53dyAtIHRoaXMud2N4KTtcbiAgICB0aGlzLndyeSA9IE1hdGgubWF4KHRoaXMud2N5LCB0aGlzLndoIC0gdGhpcy53Y3kpO1xuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ib3VuZHMgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5leCA9IHRoaXMuYm91bmRzLmxlZnQ7XG4gICAgdGhpcy5leSA9IHRoaXMuYm91bmRzLnRvcDtcbiAgICB0aGlzLmV3ID0gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgdGhpcy5laCA9IHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICB0aGlzLmVjeCA9IHRoaXMuZXcgKiB0aGlzLm9yaWdpblg7XG4gICAgdGhpcy5lY3kgPSB0aGlzLmVoICogdGhpcy5vcmlnaW5ZO1xuICAgIHRoaXMuZXJ4ID0gTWF0aC5tYXgodGhpcy5lY3gsIHRoaXMuZXcgLSB0aGlzLmVjeCk7XG4gICAgdGhpcy5lcnkgPSBNYXRoLm1heCh0aGlzLmVjeSwgdGhpcy5laCAtIHRoaXMuZWN5KTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLnF1ZXVlQ2FsaWJyYXRpb24gPSBmdW5jdGlvbihkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNhbGlicmF0aW9uVGltZXIpO1xuICAgIHRoaXMuY2FsaWJyYXRpb25UaW1lciA9IHNldFRpbWVvdXQodGhpcy5vbkNhbGlicmF0aW9uVGltZXIsIGRlbGF5KTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMub3JpZW50YXRpb25TdXBwb3J0KSB7XG4gICAgICAgIHRoaXMucG9ydHJhaXQgPSBudWxsO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlb3JpZW50YXRpb24nLCB0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24pO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMub25PcmllbnRhdGlvblRpbWVyLCB0aGlzLnN1cHBvcnREZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN4ID0gMDtcbiAgICAgICAgdGhpcy5jeSA9IDA7XG4gICAgICAgIHRoaXMucG9ydHJhaXQgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUpO1xuICAgICAgdGhpcy5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5vbkFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgUGx1Z2luLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcmllbnRhdGlvblN1cHBvcnQpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgdGhpcy5vbkRldmljZU9yaWVudGF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKTtcbiAgICB9XG4gIH07XG5cbiAgUGx1Z2luLnByb3RvdHlwZS5jYWxpYnJhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jYWxpYnJhdGVYID0geCA9PT0gdW5kZWZpbmVkID8gdGhpcy5jYWxpYnJhdGVYIDogeDtcbiAgICB0aGlzLmNhbGlicmF0ZVkgPSB5ID09PSB1bmRlZmluZWQgPyB0aGlzLmNhbGlicmF0ZVkgOiB5O1xuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuaW52ZXJ0WCA9IHggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW52ZXJ0WCA6IHg7XG4gICAgdGhpcy5pbnZlcnRZID0geSA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbnZlcnRZIDogeTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmZyaWN0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuZnJpY3Rpb25YID0geCA9PT0gdW5kZWZpbmVkID8gdGhpcy5mcmljdGlvblggOiB4O1xuICAgIHRoaXMuZnJpY3Rpb25ZID0geSA9PT0gdW5kZWZpbmVkID8gdGhpcy5mcmljdGlvblkgOiB5O1xuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUuc2NhbGFyID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuc2NhbGFyWCA9IHggPT09IHVuZGVmaW5lZCA/IHRoaXMuc2NhbGFyWCA6IHg7XG4gICAgdGhpcy5zY2FsYXJZID0geSA9PT0gdW5kZWZpbmVkID8gdGhpcy5zY2FsYXJZIDogeTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMubGltaXRYID0geCA9PT0gdW5kZWZpbmVkID8gdGhpcy5saW1pdFggOiB4O1xuICAgIHRoaXMubGltaXRZID0geSA9PT0gdW5kZWZpbmVkID8gdGhpcy5saW1pdFkgOiB5O1xuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUub3JpZ2luID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3JpZ2luWCA9IHggPT09IHVuZGVmaW5lZCA/IHRoaXMub3JpZ2luWCA6IHg7XG4gICAgdGhpcy5vcmlnaW5ZID0geSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcmlnaW5ZIDogeTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgdmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgbWluKTtcbiAgICB2YWx1ZSA9IE1hdGgubWluKHZhbHVlLCBtYXgpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHZhciBqc1Byb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eUNhY2hlW3Byb3BlcnR5XTtcbiAgICBpZiAoIWpzUHJvcGVydHkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy52ZW5kb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAodGhpcy52ZW5kb3JzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAganNQcm9wZXJ0eSA9ICQuY2FtZWxDYXNlKHRoaXMudmVuZG9yc1tpXVsxXSArICctJyArIHByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqc1Byb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGVbanNQcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucHJvcGVydHlDYWNoZVtwcm9wZXJ0eV0gPSBqc1Byb3BlcnR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbanNQcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLmFjY2VsZXJhdGUgPSBmdW5jdGlvbigkZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gJGVsZW1lbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9ICRlbGVtZW50W2ldO1xuICAgICAgdGhpcy5jc3MoZWxlbWVudCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgIHRoaXMuY3NzKGVsZW1lbnQsICd0cmFuc2Zvcm0tc3R5bGUnLCAncHJlc2VydmUtM2QnKTtcbiAgICAgIHRoaXMuY3NzKGVsZW1lbnQsICdiYWNrZmFjZS12aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oZWxlbWVudCwgeCwgeSkge1xuICAgIHggKz0gJ3B4JztcbiAgICB5ICs9ICdweCc7XG4gICAgaWYgKHRoaXMudHJhbnNmb3JtM0RTdXBwb3J0KSB7XG4gICAgICB0aGlzLmNzcyhlbGVtZW50LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcreCsnLCcreSsnLDApJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zZm9ybTJEU3VwcG9ydCkge1xuICAgICAgdGhpcy5jc3MoZWxlbWVudCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyt4KycsJyt5KycpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHg7XG4gICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IHk7XG4gICAgfVxuICB9O1xuXG4gIFBsdWdpbi5wcm90b3R5cGUub25PcmllbnRhdGlvblRpbWVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vcmllbnRhdGlvblN1cHBvcnQgJiYgdGhpcy5vcmllbnRhdGlvblN0YXR1cyA9PT0gMCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB0aGlzLm9yaWVudGF0aW9uU3VwcG9ydCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUGx1Z2luLnByb3RvdHlwZS5vbkNhbGlicmF0aW9uVGltZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuY2FsaWJyYXRpb25GbGFnID0gdHJ1ZTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLm9uV2luZG93UmVzaXplID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLm9uQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHZhciBkeCA9IHRoaXMuaXggLSB0aGlzLmN4O1xuICAgIHZhciBkeSA9IHRoaXMuaXkgLSB0aGlzLmN5O1xuICAgIGlmICgoTWF0aC5hYnMoZHgpID4gdGhpcy5jYWxpYnJhdGlvblRocmVzaG9sZCkgfHwgKE1hdGguYWJzKGR5KSA+IHRoaXMuY2FsaWJyYXRpb25UaHJlc2hvbGQpKSB7XG4gICAgICB0aGlzLnF1ZXVlQ2FsaWJyYXRpb24oMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvcnRyYWl0KSB7XG4gICAgICB0aGlzLm14ID0gdGhpcy5jYWxpYnJhdGVYID8gZHkgOiB0aGlzLml5O1xuICAgICAgdGhpcy5teSA9IHRoaXMuY2FsaWJyYXRlWSA/IGR4IDogdGhpcy5peDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5teCA9IHRoaXMuY2FsaWJyYXRlWCA/IGR4IDogdGhpcy5peDtcbiAgICAgIHRoaXMubXkgPSB0aGlzLmNhbGlicmF0ZVkgPyBkeSA6IHRoaXMuaXk7XG4gICAgfVxuICAgIHRoaXMubXggKj0gdGhpcy5ldyAqICh0aGlzLnNjYWxhclggLyAxMDApO1xuICAgIHRoaXMubXkgKj0gdGhpcy5laCAqICh0aGlzLnNjYWxhclkgLyAxMDApO1xuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdCh0aGlzLmxpbWl0WCkpKSB7XG4gICAgICB0aGlzLm14ID0gdGhpcy5jbGFtcCh0aGlzLm14LCAtdGhpcy5saW1pdFgsIHRoaXMubGltaXRYKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHRoaXMubGltaXRZKSkpIHtcbiAgICAgIHRoaXMubXkgPSB0aGlzLmNsYW1wKHRoaXMubXksIC10aGlzLmxpbWl0WSwgdGhpcy5saW1pdFkpO1xuICAgIH1cbiAgICB0aGlzLnZ4ICs9ICh0aGlzLm14IC0gdGhpcy52eCkgKiB0aGlzLmZyaWN0aW9uWDtcbiAgICB0aGlzLnZ5ICs9ICh0aGlzLm15IC0gdGhpcy52eSkgKiB0aGlzLmZyaWN0aW9uWTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuJGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBkZXB0aCA9IHRoaXMuZGVwdGhzW2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy4kbGF5ZXJzW2ldO1xuICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLnZ4ICogZGVwdGggKiAodGhpcy5pbnZlcnRYID8gLTEgOiAxKTtcbiAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy52eSAqIGRlcHRoICogKHRoaXMuaW52ZXJ0WSA/IC0xIDogMSk7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKGxheWVyLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5vbkFuaW1hdGlvbkZyYW1lKTtcbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLm9uRGV2aWNlT3JpZW50YXRpb24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgYW5kIGV2ZW50IHByb3BlcnRpZXMuXG4gICAgaWYgKCF0aGlzLmRlc2t0b3AgJiYgZXZlbnQuYmV0YSAhPT0gbnVsbCAmJiBldmVudC5nYW1tYSAhPT0gbnVsbCkge1xuXG4gICAgICAvLyBTZXQgb3JpZW50YXRpb24gc3RhdHVzLlxuICAgICAgdGhpcy5vcmllbnRhdGlvblN0YXR1cyA9IDE7XG5cbiAgICAgIC8vIEV4dHJhY3QgUm90YXRpb25cbiAgICAgIHZhciB4ID0gKGV2ZW50LmJldGEgIHx8IDApIC8gTUFHSUNfTlVNQkVSOyAvLyAgLTkwIDo6IDkwXG4gICAgICB2YXIgeSA9IChldmVudC5nYW1tYSB8fCAwKSAvIE1BR0lDX05VTUJFUjsgLy8gLTE4MCA6OiAxODBcblxuICAgICAgLy8gRGV0ZWN0IE9yaWVudGF0aW9uIENoYW5nZVxuICAgICAgdmFyIHBvcnRyYWl0ID0gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBpZiAodGhpcy5wb3J0cmFpdCAhPT0gcG9ydHJhaXQpIHtcbiAgICAgICAgdGhpcy5wb3J0cmFpdCA9IHBvcnRyYWl0O1xuICAgICAgICB0aGlzLmNhbGlicmF0aW9uRmxhZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBDYWxpYnJhdGlvblxuICAgICAgaWYgKHRoaXMuY2FsaWJyYXRpb25GbGFnKSB7XG4gICAgICAgIHRoaXMuY2FsaWJyYXRpb25GbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3ggPSB4O1xuICAgICAgICB0aGlzLmN5ID0geTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IElucHV0XG4gICAgICB0aGlzLml4ID0geDtcbiAgICAgIHRoaXMuaXkgPSB5O1xuICAgIH1cbiAgfTtcblxuICBQbHVnaW4ucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIC8vIENhY2hlIG1vdXNlIGNvb3JkaW5hdGVzLlxuICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICAvLyBDYWxjdWxhdGUgTW91c2UgSW5wdXRcbiAgICBpZiAoIXRoaXMub3JpZW50YXRpb25TdXBwb3J0ICYmIHRoaXMucmVsYXRpdmVJbnB1dCkge1xuXG4gICAgICAvLyBDbGlwIG1vdXNlIGNvb3JkaW5hdGVzIGluc2lkZSBlbGVtZW50IGJvdW5kcy5cbiAgICAgIGlmICh0aGlzLmNsaXBSZWxhdGl2ZUlucHV0KSB7XG4gICAgICAgIGNsaWVudFggPSBNYXRoLm1heChjbGllbnRYLCB0aGlzLmV4KTtcbiAgICAgICAgY2xpZW50WCA9IE1hdGgubWluKGNsaWVudFgsIHRoaXMuZXggKyB0aGlzLmV3KTtcbiAgICAgICAgY2xpZW50WSA9IE1hdGgubWF4KGNsaWVudFksIHRoaXMuZXkpO1xuICAgICAgICBjbGllbnRZID0gTWF0aC5taW4oY2xpZW50WSwgdGhpcy5leSArIHRoaXMuZWgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5wdXQgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQuXG4gICAgICB0aGlzLml4ID0gKGNsaWVudFggLSB0aGlzLmV4IC0gdGhpcy5lY3gpIC8gdGhpcy5lcng7XG4gICAgICB0aGlzLml5ID0gKGNsaWVudFkgLSB0aGlzLmV5IC0gdGhpcy5lY3kpIC8gdGhpcy5lcnk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5wdXQgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbiAgICAgIHRoaXMuaXggPSAoY2xpZW50WCAtIHRoaXMud2N4KSAvIHRoaXMud3J4O1xuICAgICAgdGhpcy5peSA9IChjbGllbnRZIC0gdGhpcy53Y3kpIC8gdGhpcy53cnk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBBUEkgPSB7XG4gICAgZW5hYmxlOiBQbHVnaW4ucHJvdG90eXBlLmVuYWJsZSxcbiAgICBkaXNhYmxlOiBQbHVnaW4ucHJvdG90eXBlLmRpc2FibGUsXG4gICAgdXBkYXRlTGF5ZXJzOiBQbHVnaW4ucHJvdG90eXBlLnVwZGF0ZUxheWVycyxcbiAgICBjYWxpYnJhdGU6IFBsdWdpbi5wcm90b3R5cGUuY2FsaWJyYXRlLFxuICAgIGZyaWN0aW9uOiBQbHVnaW4ucHJvdG90eXBlLmZyaWN0aW9uLFxuICAgIGludmVydDogUGx1Z2luLnByb3RvdHlwZS5pbnZlcnQsXG4gICAgc2NhbGFyOiBQbHVnaW4ucHJvdG90eXBlLnNjYWxhcixcbiAgICBsaW1pdDogUGx1Z2luLnByb3RvdHlwZS5saW1pdCxcbiAgICBvcmlnaW46IFBsdWdpbi5wcm90b3R5cGUub3JpZ2luXG4gIH07XG5cbiAgJC5mbltOQU1FXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgIHZhciBwbHVnaW4gPSAkdGhpcy5kYXRhKE5BTUUpO1xuICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgcGx1Z2luID0gbmV3IFBsdWdpbih0aGlzLCB2YWx1ZSk7XG4gICAgICAgICR0aGlzLmRhdGEoTkFNRSwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICAgIGlmIChBUElbdmFsdWVdKSB7XG4gICAgICAgIHBsdWdpblt2YWx1ZV0uYXBwbHkocGx1Z2luLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbn0pKGpRdWVyeSB8fCB3aW5kb3cuWmVwdG8sIHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbnZhciBsZXR0ZXJzID0gWydNJywgJ0EnLCAnVCcsICdUJ107XG52YXIgd3JhcHBlcjEgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCd3cmFwcGVyJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuXHR2YXIgc2NlbmUgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdzY2VuZScpO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IDEwOyBqKyspIHtcblx0XHR2YXIgZWwgPSBcblx0XHRcdCQoJzxkaXY+PC9kaXY+Jylcblx0XHRcdFx0LnRleHQobGV0dGVyc1tpXSlcblx0XHRcdFx0LmFkZENsYXNzKCdsYXllcicpXG5cdFx0XHRcdC5hdHRyKCdkYXRhLWRlcHRoJywgaiAqIDAuMDMpO1xuXHRcdHNjZW5lLmFwcGVuZChlbCk7XG5cdH1cblx0JChzY2VuZSkucGFyYWxsYXgoe1xuXHRcdHNjYWxhclg6IDMwLFxuXHRcdHNjYWxhclk6IDIwLFxuXHRcdG9yaWdpblg6IDAuNjUsXG5cdFx0b3JpZ2luWTogMC41XG5cdH0pO1xuXHQkKHdyYXBwZXIxKS5hcHBlbmQoc2NlbmUpO1xufVxuXG52YXIgbGV0dGVyczIgPSBbJ08nLCAnWCcsICdMJywgJ0UnLCAnWSddO1xudmFyIHdyYXBwZXIyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnd3JhcHBlcicpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMyLmxlbmd0aDsgaSsrKSB7XG5cdHZhciBzY2VuZSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3NjZW5lJyk7XG5cdGZvciAodmFyIGogPSAwOyBqIDwgMTA7IGorKykge1xuXHRcdHZhciBlbCA9IFxuXHRcdFx0JCgnPGRpdj48L2Rpdj4nKVxuXHRcdFx0XHQudGV4dChsZXR0ZXJzMltpXSlcblx0XHRcdFx0LmFkZENsYXNzKCdsYXllcicpXG5cdFx0XHRcdC5hdHRyKCdkYXRhLWRlcHRoJywgaiAqIDAuMDMpO1xuXHRcdHNjZW5lLmFwcGVuZChlbCk7XG5cdH1cblx0JChzY2VuZSkucGFyYWxsYXgoe1xuXHRcdHNjYWxhclg6IDMwICogLTEsXG5cdFx0c2NhbGFyWTogMjAgKiAtMSxcblx0XHRvcmlnaW5YOiAwLjY1LFxuXHRcdG9yaWdpblk6IDAuNVxuXHR9KTtcblx0JCh3cmFwcGVyMikuYXBwZW5kKHNjZW5lKTtcbn1cblxuLy92YXIgZXllV3JhcHBlciA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3NjZW5lIGV5ZS13cmFwcGVyJyk7XG5cbi8vIHZhciBleWUxID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnZXllJyk7XG4vLyB2YXIgcHVwaWwxID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbGF5ZXIgcHVwaWwnKS5hdHRyKCdkYXRhLWRlcHRoJywgMC44KTtcbi8vIHZhciBoaWdobGlnaHQxID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbGF5ZXIgaGlnaGxpZ2h0JykuYXR0cignZGF0YS1kZXB0aCcsIDAuMyk7XG4vLyBwdXBpbDEuYXBwZW5kKGhpZ2hsaWdodDEpO1xuLy8gZXllMS5hcHBlbmQocHVwaWwxKTtcbi8vIHZhciBleWUyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnZXllJyk7XG4vLyB2YXIgcHVwaWwyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVwaWwgbGF5ZXInKS5hdHRyKCdkYXRhLWRlcHRoJywgMC44KTtcbi8vIHZhciBoaWdobGlnaHQyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbGF5ZXIgaGlnaGxpZ2h0JykuYXR0cignZGF0YS1kZXB0aCcsIDAuMyk7XG4vLyBwdXBpbDIuYXBwZW5kKGhpZ2hsaWdodDIpO1xuLy8gZXllMi5hcHBlbmQocHVwaWwyKTtcbi8vIGV5ZVdyYXBwZXIuYXBwZW5kKGV5ZTEpO1xuLy8gZXllV3JhcHBlci5hcHBlbmQoZXllMik7XG5cbnZhciBzbWlsZSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3NtaWxlJyk7XG52YXIgc2lkZVBhbmVsID0gJCgnLnNpZGUtcGFuZWwnKTtcblxuXG4gJCgnLnRleHQnKS5hcHBlbmQod3JhcHBlcjEpO1xuICQoJy50ZXh0JykuYXBwZW5kKHdyYXBwZXIyKTtcbiAkKCdib2R5JykuYXBwZW5kKHNpZGVQYW5lbCk7XG4gLy8kKCdib2R5JykuYXBwZW5kKGV5ZVdyYXBwZXIpO1xuIC8vJChleWVXcmFwcGVyKS5hcHBlbmQoc21pbGUpO1xuXG4vLyAkKGV5ZVdyYXBwZXIpLnBhcmFsbGF4KHtcbi8vIFx0c2NhbGFyWDogLTEwLFxuLy8gXHRzY2FsYXJZOiAtMTAsXG4vLyBcdG9yaWdpblg6IDAuNSxcbi8vIFx0b3JpZ2luWTogMC41XG4vLyB9KTtcblxuXG5cblxuJCggZG9jdW1lbnQgKS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAkKHdyYXBwZXIxKS5hZGRDbGFzcygnbG9hZGVkJyk7XG4gICAgJCh3cmFwcGVyMikuYWRkQ2xhc3MoJ2xvYWRlZCcpO1xuICAgICQoc2lkZVBhbmVsKS5hZGRDbGFzcygnbG9hZGVkJyk7XG4gICAgJCgnLmxvZ28td3JhcHBlcicpLmFkZENsYXNzKCdsb2FkZWQnKTtcbn0pO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqLyIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4xLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOS0yMlQyMjozMFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMS4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHRcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0XHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRcdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0RE9NRXZhbCggY29kZSApO1xuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRcdHJlc29sdmUuY2FsbCggdW5kZWZpbmVkLCB2YWx1ZSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5jYWxsKCB1bmRlZmluZWQsIHZhbHVlICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGpRdWVyeS5jYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogalF1ZXJ5LmlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdGlmICggZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHR2YWwgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF07XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHJhZigpIHtcblx0aWYgKCB0aW1lcklkICkge1xuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJhZiApO1xuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmIG9yIGlmIGRvY3VtZW50IGlzIGhpZGRlblxuXHRpZiAoIGpRdWVyeS5meC5vZmYgfHwgZG9jdW1lbnQuaGlkZGVuICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByYWYgKSA6XG5cdFx0XHR3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aWYgKCB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aW1lcklkICk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblx0fVxuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLCByZWN0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGVsZW1lbnQgaXMgbm90IGhpZGRlbiAoZGlzcGxheTogbm9uZSlcblx0XHRpZiAoIHJlY3Qud2lkdGggfHwgcmVjdC5oZWlnaHQgKSB7XG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzISEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhIS4vbWFpbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzISEuL21haW4uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3N0eWxlcy9tYWluLnNjc3NcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlMGUwZTA7IH1cXG5cXG4ubGF5ZXIge1xcbiAgZm9udC1mYW1pbHk6ICdCdW5nZWUgU2hhZGUnLCBjdXJzaXZlO1xcbiAgY29sb3I6ICM1ODU4NTg7IH1cXG5cXG4uc2NlbmUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrICFpbXBvcnRhbnQ7IH1cXG5cXG4ud3JhcHBlciB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IC01MDBweDtcXG4gIHRyYW5zaXRpb246IHRvcCAycyBlYXNlOyB9XFxuXFxuLndyYXBwZXIubG9hZGVkIHtcXG4gIHRvcDogMHB4OyB9XFxuXFxuLmV5ZS13cmFwcGVyIHtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBwYWRkaW5nLXRvcDogNzJweDtcXG4gIC8qIHdpZHRoOiAyMDBweDsgKi9cXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLmV5ZSB7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDEyMHB4O1xcbiAgYm9yZGVyOiA1cHggc29saWQgIzU4NTg1ODtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDcxcHggLyA3N3B4O1xcbiAgbWFyZ2luOiAwcHggLTRweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB9XFxuXFxuLmhpZ2hsaWdodCB7XFxuICBoZWlnaHQ6IDVweDtcXG4gIHdpZHRoOiA1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlcjogMnB4IHNvbGlkIHdoaXRlO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIGxlZnQ6IDQwJSAhaW1wb3J0YW50O1xcbiAgdG9wOiA0MCUgIWltcG9ydGFudDsgfVxcblxcbi5wdXBpbCB7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICB3aWR0aDogMzFweDtcXG4gIHRvcDogMzUlICFpbXBvcnRhbnQ7XFxuICBsZWZ0OiAzNSUgIWltcG9ydGFudDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvcmRlcjogM3B4IHNvbGlkICM1ODU4NTg7XFxuICBib3JkZXItcmFkaXVzOiAyNHB4IC8gMjRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1ODU4NTg7IH1cXG5cXG4uc21pbGUge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogJy4vc21pbGUucG5nJztcXG4gIGhlaWdodDogMTQwcHg7XFxuICB3aWR0aDogMTk2cHg7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47IH1cXG5cXG4udGV4dCB7XFxuICBmb250LXNpemU6IDE1NXB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDU1JTtcXG4gIG1pbi13aWR0aDogNzAwcHg7XFxuICBwYWRkaW5nOiAxMDBweCAzMHB4O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcblxcbi5zaWRlLXBhbmVsIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDEwMHB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMTAwcHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMCU7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM1ODU4NTg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgdHJhbnNpdGlvbjogd2lkdGggMS43cyBlYXNlO1xcbiAgcGFkZGluZzogNTBweDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3gtc2hhZG93OiAycHggMnB4IDE5cHggMnB4IGJsYWNrOyB9XFxuXFxuLnNpZGUtcGFuZWwubG9hZGVkIHtcXG4gIHdpZHRoOiA0NSU7IH1cXG5cXG4ubG9nby13cmFwcGVyIHtcXG4gIGhlaWdodDogMTI1cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDEwMDBweDtcXG4gIHRyYW5zaXRpb246IHRvcCAycyBlYXNlOyB9XFxuICAubG9nby13cmFwcGVyIC5naXRodWIge1xcbiAgICBoZWlnaHQ6IDkwcHg7XFxuICAgIHdpZHRoOiAyNzBweDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vZ2l0aHViLnBuZ1wiKSArIFwiKTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAubG9nby13cmFwcGVyIC5naXRodWIubG9hZGVkIHtcXG4gICAgdG9wOiAwcHg7IH1cXG4gIC5sb2dvLXdyYXBwZXIgLnR3aXR0ZXIge1xcbiAgICBoZWlnaHQ6IDkwcHg7XFxuICAgIHdpZHRoOiA5MHB4O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIHJlcXVpcmUoXCIuLi90d2l0dGVyLnBuZ1wiKSArIFwiKTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAubG9nby13cmFwcGVyIC50d2l0dGVyLmxvYWRlZCB7XFxuICAgIHRvcDogMHB4OyB9XFxuICAubG9nby13cmFwcGVyIC5saW5rZWRpbiB7XFxuICAgIGhlaWdodDogNzZweDtcXG4gICAgd2lkdGg6IDI4MHB4O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIHJlcXVpcmUoXCIuLi9saW5rZWRpbi5wbmdcIikgKyBcIik7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLmxvZ28td3JhcHBlciAubGlua2VkaW4ubG9hZGVkIHtcXG4gICAgdG9wOiAwcHg7IH1cXG5cXG4ubG9nby10ZXh0IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtZmFtaWx5OiAnQnVuZ2VlIFNoYWRlJywgY3Vyc2l2ZTtcXG4gIHRyYW5zaXRpb246IGZvbnQtc2l6ZSAwLjVzIGVhc2U7IH1cXG5cXG4ubG9nby13cmFwcGVyLmxvYWRlZCB7XFxuICB0b3A6IDBweDsgfVxcblxcbi5sb2dvLXdyYXBwZXI6aG92ZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICAubG9nby13cmFwcGVyOmhvdmVyIC5sb2dvIHtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAxcyBlYXNlO1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLmxvZ28ge1xcbiAgb3BhY2l0eTogMDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyIS4vc3R5bGVzL21haW4uc2Nzc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQjlBQUFBS1pDQU1BQUFEWGlVQklBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlocFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TlMxak1ESXhJRGM1TGpFMU5UYzNNaXdnTWpBeE5DOHdNUzh4TXkweE9UbzBORG93TUNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElESXdNVFFnS0UxaFkybHVkRzl6YUNraUlIaHRjRTFOT2tsdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNlFqWTRPRVZGUmpJMlEwUXhNVEZGTkRoRE9ETkJOVGRGUWtGRFF6UTVOVFlpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2UWpZNE9FVkZSak0yUTBReE1URkZORGhET0ROQk5UZEZRa0ZEUXpRNU5UWWlQaUE4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnYzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBDTmpnNFJVVkdNRFpEUkRFeE1VVTBPRU00TTBFMU4wVkNRVU5ETkRrMU5pSWdjM1JTWldZNlpHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcENOamc0UlVWR01UWkRSREV4TVVVME9FTTRNMEUxTjBWQ1FVTkRORGsxTmlJdlBpQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNGdQQzl5WkdZNlVrUkdQaUE4TDNnNmVHMXdiV1YwWVQ0Z1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1BpbkZLU0FBQUFNQVVFeFVSUTRNRFp6YThEbzVPb3lNak92WTFjUEN3bE5zZDZiZDhheGNVWnlibXhvWkdTd3JLNlNrcEgycnU3aHhac3VpalBqNCtMS3lzbzkzYWVTN3BQWDE5WHg3ZTdtV2c1SE02TkxSMFllNnpXZUpsbXBaVVlQQTZJL0cybU5pWW14cmErSGc0T25wNlhPcjBwUFI3VTFNVGFXSmVlYm01aU1pSXV2QnFUbEdUTEptWE1PRWVGSlJVZTN0N2ZEdzhOWFYxZnYxOHFxcHFzZkh4OGVta2tSRFExZDFoYm01dVZ4Ylc5enkrdlA3L2RUditIZDJkdHV5bkpXVWxlQzFucGpWN2JybDlkaXlyVmRLUkl6SjYvdnM0NGFGaHNyS3l1TDArdE9xbEIwY0hOcmEydDNkM2Z2Nys3YTF0YzNOemFHaG9jVHA5dno4L0lHQmdUUXlNNGpGNnZ2eTdIUmlXSkdRa2ZuaTFNR2ZqUGJSdkwyOXZiUGo4OXU0dE9US3hxMnNyTlNycG1tWnZNcnI5L0RHcllHeXcyV1R0ZlhOdHZybDJkU1poa2xmYVp1QmN1MzQvTXlibElDKzU4U0tndmJWd2ZqOC92amN6UEx5OHYzNDluRnhjYXpnOHZMbDQyMlRvUzB5TlVSV1hVUThOd0FBQURnMU5Qcm8zcHJZN3Z6Ky8zV2ZydmJzNjM2ODU3L2w5YlRiOGsxQ1BhUFQ3djc5L0ovYjhKYlE1aTh0TFNjcUsrajIvUFRMc2taRlJ1alJ6dmZheWZMSnNQVEtzZmZZeGRDam5jV2NoN09SZmpFNlBkaWdqTDJiaDlHdW1mNzcrU1lsSld5ZnhGMkdvNXJZOE5pdW1GK0FqY21VamNybDl1R3NsNzE3Y1Y5UlNUVS9SRFl3THNhUGlONit1aW91TWVERHY4ZWVpYzZsandrSkNYeTY1dHlta3ZYUHVQUG81bGRWVm5pMDNzN3M5NjVnVmZqZjBQLy8vNEJyWUNzb0oyS09yUkFPRHo1TlZjU2JoaTQyT1NRbUoyaG5aeE1SRW5SemMzMjc1di8rL3A2ZW5sbFlXUDcvLzdDdnIyQmZYOURQMEVBL1A4Qy92NnVycS8vOS9MdTZ1ck96czZlbXA5VFUxS2lvcUlpSWlDQWZIemszT0VsSVNHOXVieWtvS09QajQ1T1RrMzkrZmpFd01MeTd1MmxvYVhsNGVNVER3NE9DZy96djZQLy8vcG1ZbUkrUGo0V0VoTmpYMTVhV2x1N2UzSHU1NUF3TURQVE1zLzcrL3ZEaDMzeTU1YXlOZkg2NzVnVUZCWHUzNHMyT2ZSZ2lKb2lkcGUvNS9hSzV3WWJDNkl2RjRMS1ZoUC8vLzZIUzNxOEFBQUVBZEZKT1UvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vd0JUOXdjbEFBQnRha2xFUVZSNDJ1eTlDMVJkMWIzb3ZRRVQ1VkVseWNaR2MrVnhEckpqQkpKUUJDc21XbXRRd2t2Z21GaXhqY2Q0dE1hZXFqSFdGMFpiUndaS205aWtqVmJsM0tNZDFkcmEyQmRIbXpnd0ZqZ0JlYVVoQ1p0WHdBUVZRanlwdlk1emU3OSs5K3Y2ZUQ4Mis3RWVjNzMyL3YzYTBRcHU5cHBycmpYWGI4MDUvL00vSFJJQUFBRFlIZ2RWQUFBQWdOQUJBQUFBb1FNQUFBQkNCd0FBQUlRT0FBQ0EwQUVBQUFDaEF3QUFBRUlIQUFBQWhBNEFBSURRQVFBQUFLRURBQUFBUWdjQUFJRGdGdnJXNDNIWm1XVXV0OXRkUGRDV0hOOC8xTkhxNUJKcnc5bmFmQ1l1UGpsOG9IcTBXbDBEbVUxeHg3ZFNLd0FBQ0YxWFRyam4wM2J5eElkSlhHYzFKQlZHMUxWNXFkSVRWQTBBQUVMWEZXLzJHU2Q4Mi9GRXJyVVNFbU1TdW56VlpodlZBd0NBMFBVazErMlA4SndzeHQ5bGtWNlkwK1czS2pPb0l3QUFoSzRqRGU0QXVMSWJHWDBQUUVwamt5dFFQVzZqbWdBQUVMcCtPSHZkTWtpTlRPR3ErN1Q1VUxLY091eGxxQU1BQUtIcnh5SzNUR3BpMHJudzgwa3JUcFZiZzgzVUZnQUFRdGVOZUxkc3FoUGFLN24yc3lrb1Axa3R2LzVhcURBQUFJU3VGK2t1dHhLNkloaDZuNll2b2tKUjVia1k0Z0FBUU9oNmNkU3RFRmY4QXJycG8xUisyS0swNnR6SHFUWUFBSVN1RTlsdTViUTFobng0MTliR05oVVZsMDNMQVFCQTZEcUp5ZVZXUS9UcHZsQysvSDM5MGFxcWpURjNBQUNFcmhQTmJwVzRFbGFHNnNWZm11QlNXMnViYURvQUFBaGRGMDY2MWRPU0c0cVhmakJiUTVXZHBPa0FBQ0IwUFNpSWRtc2h0VDNVTG54N3FxWUtpeTZnN1FBQUlIUTl1cHR1allTVzByT1N0ZGJYQXRvT0FBQkMxNEhUYmpkS2w5MDdUOVplV3gvUmRnQUFFTG9PN0hJTG9DWWs1dEl6VWtYVTFTN2FEZ0FBUWhkUGlsc004VUVmOGI0MFcxQlZrV2dQQUFDaGk2ZlpMWXFlb0Y2WDN0Y2pyS0lPMDNnQUFCQzZjSEtFZWNwZHZTNW9rNmFrZmVRU1YwOE5OQjRBQUlRdW5IQzNRQVlhZzNKTlZrRmt0TWhhQ3FmeEFBQWdkTkdrdU1YUzltSHdYZWtqYllJcnFZL1dBd0NBMEFXenlDMmE3UHpndXM3cnM0VlhVUWV0QndBQW9RdW1YN2l0M0s3VFc0UG5LbS90ZDRtdklWYWlBd0FnZE5Fa3UzV2diSk9lUlhZbTllV3ZYTG15S0NNam96MXJsTUhSZnlnYS9VVmlpdmlZdkUxbGV0UlBLcTBIQUFDaGl5WFc1ZGFGMVBVQ084bUpSZVdyaDlibEpNVFhkTGRWK0E5UHE2NEt6MHl1aVc4NHZTYW1jSEFrSlZiYmtWZW02bE03dmFSekJ3QkE2R0pwZGV1RWE1MVRXOG5TVm40WTA3a3RlMWVGcGxlTzNyYW1uczdHanFJK0ZXcmZXdXJTcTNaVzBud0FBQkM2VUdMY3VoR2VwYXBFS1Jtckl4cXlNNnVGVHdPazlrUWN6bFdRcEsyd1M3KzZPVXJ6QVFCQTZFSTU1ZGFSZUVVNVR0TnpqM2ZHNzZwMjYwdDFabnpwMGR6QWsrMHA4WHFXSW9mbUF3Q0EwSVdTcktzOW8yTmtxandtcm1iQWJTUVYyWDYxWHRJWXJldmhpWW9EQUVEb1l1blZXWnlwQVJhbEp4Wkd0SFM1emFJcmZtTjVrcGRTclUvVytjRFJOQjhBQUlRdWtqN2RuVm05MFZkRWQwcGhaMU8wMjN3cVBLMWVzTEZhOTRNbTBYNEFBQkM2UU5vTkVHYjMvSkJ1WjhhYStESzNsUWp2aVJtcG5DamNzVzREampkSSt3RUFRT2dDaVRSQ2xxN2gyWjMwdE1MK1pKZmJpa1Mzbk1od3hrWVlVcmhpMmc4QUFFSVhTSnd4cXB6cXBDY3RPcFhwdGpRdWd3WU80bWcvQUFBSVhTRFpSbmx5dUdEcmg2VVdsN21SWk5OK0FBQVF1a0RhREROWW1RdUx6eUtUOWdNQWdOQUZnbVZOb3BmMkF3Q0EwTVdSaEZuTklwMEdCQUNBMElXeEZMR2F4UWdOQ0FBQW9RdmpDR0kxaTNJYUVBQUFRaGRHREdJMWl4Z2FFQUFBUWhmR0dzUnFGbXRvUUFBQUNGMFlwWWpWTE5iUmdBQUFFTG93ZWhDcldiQWpPZ0FBUWhkSFBHSTFpNU0wSUFBQWhDNk1Hc1JxRmswMElBQUFoQzZNYnNScUZ0MDBJQUFBaEk3UUVUb0FBQ0QwR2NJUnExbUUwNEFBQUJBNlFrZm9BQUNBMEJFNlFnY0FBSVFPSW9pbUFRRUFJSFJoVkNCV2hBNEFnTkR0ZndyUmlOVXN5bWhBQUFBSW5SNDZjK2dBQUlEUVoyQU9IYUVEQUFDSlpVQTltVFFnQUFDRUxveGt4RXFtT0FBQWhHNy9VMkJ6RnROSXBRRUJBQ0IwWWJCOXFtbkUwNEFBQUJDNk1CSVFxMW4wMElBQUFCQzZNUG9ScTFuMDA0QUFBQkM2TUU0Z1ZyT0lvQUVCQUNCMFlSeEZyR1pSVEFNQ0FFRG93amlDV00waWl3WUVBSURRaFZHRVdNMmlsUVlFQUlEUWhaR0NXTTBpaVFZRUFJRFF4VkdOV2MzQlZVSURBZ0JBNk9MSVJLM20wRWI3QVFCQTZBSWhWWnhKdE5CK0FBQVF1a0RJTEdNU3BiUWZBQUNFTHBCRzFHb09qYlFmQUFDRUxwQU0xR29PZzdRZkFBQ0VMcEIwMUdvT2FiUWZBQUNFTHBJdTNHb0dYVFFmQUFDRUxoVEMzQWx5QndCQTZFRkFCSEkxQS9aYUF3QkE2R0pwUjY1bVVFN3pBUUJBNkVJaEtvNllPQUFBaEI0TWtQelZCRWo4Q2dDQTBFV1RnMTZONXhTdEJ3QUFvUXVtQTcwYXp5SmFEd0FBUWhkTUdubzFIalpEQndCQTZNTHB4cTlHMDAzakFRQkE2TUxwUkxDc1FnY0FRT2oycHhYQkdrMEdqUWNBQUtHTHB3TERHa3lOazlZREFJRFFoWE1Ld3hwTkUwWUhBRURvd3NsRnNJYVRYVUQ3QVFCQTZJS3BaQXRWNDZrcm9RRUJBQ0Iwd1JEbmJnSU5OQ0FBQUlRdW1FVDBhZ0tkdENBQUFJUXVsa2pzYWdiRk5DRUFBSVF1RXJLNW00TXJpellFQUlEUXhaRmJqVnZOb2ZjWWpRZ0FBS0dMWW4wMFpqV0xpaFJhRVFBQVFoZERFbXZXVENRNWxtWUVBSURRUlZDUWpGWE5wSWRtQkFDQTBFV3dEYWVheXhEdENBQUFvV3VIQld1bWg3cXo4eG9BQUVMWHpLQUxvNXBOV1JJdENRQUFvV3VqcndxZm1rOE5XZDBCQUJDNkpnaUlzd2JETkNVQUFJU3VoZE80bEdsMEFBQ3d2ZEEvUktVV29TdWR4Z1FBZ05EVmtqS0FTYTFDQW8wSkFBQ2hxNlNrQm85YWgyWmFFd0FBUWxmSEVCYTFFQU9zWFFNQVFPaXF5R2VMTlVzUlQzTUNBRURvS21ERm10VllSSHNDQUVEb3lqbUJRYTJXTUk1SWR3QUFoSzZZRVFiY0xVY09EUW9BQUtFckpSVi9XbzhpV2hRQUFFSlh4bkhzYVVHNnlla09BSURRRlpGR1NobExVa3lUQWdCQTZFckl3WjJXcElxNE9BQUFoSzZBSXRScFVVcHBVd0FBQ0YwK0xFRzNLcTU4R2hVQUFFS1hTd2ZpdEN3bmFWUUFBQWhkSmdYaGVOTzZ0TktxQUFBUXVqd2FzYWFGYWFKVkFRQWdkRm1rczJUTjBtVFFyQUFBRUxvY09uR21wYW1oV1FFQUlIUVpwUFhpVExyb0FBQmdlNkVQWTB5TGswMjdBZ0JBNkFGSmo4YVlWdWNZRFFzQUFLRUhnbTNRclU4Q0RRc0FBS0VId0VtSXUvVng5ZEd5QUFBUXVuOVlnMjRIVHRPeUFBQVF1bDhxMjdDbERZaDIwclFBQUJDNlA4cVJwUzJJb1drQkFDQjBmMlRqU2x2UVRkTUNBRURvZmxpUEttMUNFVzBMQUFDaCt5WU9VOXFFQnRvV0FBQkM5MGtzU1dYc1FpOWhjUUFBQ04wbnpZalNOcXltY1FFQUlIUmZFQkpuSDloekRRQUFvZnNpQlUzYWlCUmFGd0FBUXZmT0dpeHBJNFpvWFFBQUNOMDdaSW16RThtMExnQUFoTzZWbFVqU1ZyQkRDd0FBUXZkS0JJNjBGWkUwTHdBQWhPNk5YVGpTVnFUU3ZBQUFFTG9YOGxHa3ZYQ2wwYjRBQUJENmZNNmdTSnZSUWZzQ0FFRG84MG5Ga0RhRGZPNEFBQWg5UG1rSTBtNVUwTDRBQUJENlBEb1FwTzBZb1lFQkFDQjBUM0x3byswZ1dSd0FBRUtmUnpoK3RCM1pOREFBQUlUdVFTSjZ0Qis5SmJRd0FBQ0VQcGNZOUdoRGp0SENBQUFRK2x3U3NLTU5LYWFGQVFBZzlMa3doVzVIZW1oaEFBQUlmUTVKeU5HT2hOUENBQUFRK2h5T0lFZGJra1FUazBWQlNtN1c4VFdsMjFwcXVzUExvdk9pb2h4VFJPVkY1Ym1pbzhNems1dmlFM0pLSXlJM3RiZjJPYWt4QUxDdDBEdHhveTNKb29uNUYzbCsxcG1jN0xicVdvY3k2bDBWeVNmN0l6dHlVMWhJQUFBMkUzbzJiclFsRzJsaXZsUys4bmhjYWxXOVF5dTEwY2tKdzgydDZkUW9BRUszUnpFcm8zR2pMVGxKRTV0UHlkTElrMjNhVlQ0WGQzSkRZd1phQjBEb2xvZTBNallsa3lZMkYyZDVaM0tVUXpkNlV6dXppRnNBUU9oV3BodzEyaE5YQVcxc2h0YUk3bnFIL2tSbmJ5eGlhaDBBb1Z1VUlkUm9VMWJTeGliWWVyak83VENNczFHcEVSbElIUUNoVzVBR3pHaFRtbWxqbzZRZnJhbDNHRTVlUzNFS2RRK0EwQzFHTW1hMEtSRzBzZGpWWnRoOGt2RE85VndCQUlSdUpYb3hvMDFKQ1BVV3RyUWh6MkV1RmFmemVkQUJJSFNya0lJWTdVcHFTRGV2clpIaERpdVEyYmlWWngwQVFyY0V1WWpScmxTRWNPUEtiNGh5V0lXb0hyYXkxVVJTeGdLVkRDYnFYTFFSdFNWYmtCdnFpUXRLV29Pczd1d2g5RVVXc2RNYmI3eXhZNXlLTjk2d29qM2ZIU3ZmZGErLy92cXlaUnRHLzNlMG5PWW41SWtOMVdkRmJwUERXaVNYbzJYVlk0UTFtZ1pJOUh5WnlxclNVTEw2bnBEZUZxRFlGV3gxWncraG56RnZIZldPWlFlMmZIN2hpM3YzN2R1NzkrQmM5dTRkLysyTEZ6Ny8rYVZiRmgvWWNOMk9LbVAxL2RoMUd3NHMzbkxwOHhkZWVOQ3pmSHNuQ2pqMlAvdjJIYnp3K1MyTGwrMHdwd1lUUS9OUnNTRDVyTU55dEIxQnphcElpOVk0UGpLaVc5RTZhclVWclR1RU0wVnNkQVJkM2RsRDZIRW1pQ2g2MmVMblg5eTM5K0E4ai90anpLdWoraHp6KzdMckhoUGVQYTdZc1d6RGdTMlhUcjVnekZLM3pNSzkrUG1CNjF3RzErTmdLRDRwQnJzZDFxU2JnWGMxNUdnZUhkR3JaTEV1clVVckR0MWhsL3JncXp0N0NEM2U0Rzc1ZFlzdjNIZFFJMk12QW1QYWZYSEM3eHRldjY3clhhVUZxWHJzdW1Wam5mRFBueC9yZys4ZHQ3ZWlGd3d2cGRxNzkvTURSczRYckE2OUI4V3hWSWRscWUwbmQ1OXlxalhYZTVwT0pXdlhYTExRRFZ0dERNSzZzNGZRdXcwVTBHT0xMOXg3VUFjbWg3OUh0ZnppeENEOWxpMkxSemt3emRoUG83Kzg5UG5uTDN6eHhiM1RYZkM5KzNRb3p0NUxseG5WVXo4UmFvK0pwRHFIcFdHL0hCV1BTYzNvTlRJU296MVRRY2hlMVg3TmRUZUEwRlV4WUpUTmQxeXFpOHg5ZE9Cbi8vL1VQeGgxL0lQN25qZkc2UitGMWtNaWRqaktZWEZhRWJUeFFsK0swSU52SXNVUmpkQlZZVXh2OG8zRmh0blVHdXk3MUlCQXVZYVFla1lzS0hOWUhsSEoreXI3Qmc4UG5WZzN2T1pvMXZvZ1g4dUEwQkU2UWhlRzB3aWRYK2QzcEgzZkJSZGM4Tllrby8rNHo3THEzN3R2cktBM2p2NTNnckh5K2ludGl4djBydGY0RUhwQ3BOVTViRUNwZ0ROTmI4N0pqSm9WeDE5YlZoY1p4T3NaRURwQ1IrakNNQ0JSM0RLdkZuL3J4bGZXTGxteWZQUHVQZlBZdlhuejh1WExseXhaZS9Vcm85WTAwZkQ3TGhndDVTdFhqNVZ6K2ViTmU3eXplN1NvYTYrKzhTMHZvWDc3RHVnNy9oRkNNVGNkTGp2NDNGR28yZWFSeVY3WFNwVjlGS3g1NHhFNlFrZm93amltdDg1Zm43ZkUvSzFYUmoyK1J3bWJ4NTA1YXZjTDl1bmZEUitUK05XKzNqWDhsM0x0S3hkNDl1a1A2Rm0zbWFIeWVFaVBkOWdEalFIWHgrcWlmQyt4NzI2dVJPZ0lIYUVqZEQ4TTZod0pkK0Vjd1YxdzQ5cmxDalhwVSs1dmlldTVxNWY0L1A3NmtxdmZtbE91dmEvclY3c0RJZkowR095MWljKzFKZU5kR21oSlh0WHFJRlE2UWtmb0NGMFloWHJxdlByUzJXcDdhKzN5UFdMWnJYcGdmdSsrdDZaSDB6VkxmTDdVYjV3MWtyRDNjOTJTM0xsQzR0bFFzcTdXSmo1MzlHaVovSklUSkJDZWdkQVJPa0pINkw0NGJOQm8rMXRyTisvUm1mR3A5eVdqaGw5NzlkV3ZUREFSdkRiNXc5VlhyeDJmRFYrK1diakN2VGw5NXVUMzZSWWRGd3FQaHFSa2gyMDRydjQwaTJVdXllc0p0cjNkRURwQ1IrakNPS3BmVHJoTHB4ZCs3M3RsK1o2UVkvUGFtUW4xejZ2MXFlTVEyUDBodDlvK1BuZjBxVDNMTlBrYmxFVG5JblNFanRBUnVsY2FkY3NLTnpOeHZuYjNucEJrOTVLM3BzZmQ5Vm1WSHZ3N05NYlUyOGpudldyUHNsVkprRUQ5RUVKSDZBZ2RvUnNwOUdWVHZmTUxsb1NvenNlWlZ2cmVaUWhkT1NXbkhIWkNiVjZBUlZIS3RvL2JWb0xRRVRwQ1IranpXYU9Qenc5TStuemYybERXK2JqU0w1ak1QcnRZaDJydUMrNm5nclBKVmo1M1JLbzd6V0xGUVg5TlFaUTlEcUVqZElRdWpHRmRmTDVsTW52Nks1djNoRHk3cjU1OHVia1VvU3NqcWMxZVBsZTVTMGlraWlQVkJJL1JFVHBDUitqV0Z2cm5rNlB0eTlINUdNc254OTJmRjE3UitjSDhUT2dyczVuUDgxU3RFaitzYWxGZThHVDlSZWdJSGFFTG8xTUhuejgvNGE5WGR1UHlxVTc2UkkxY0tEb1Q3TW9nZmlUa1Y5dk01K3AyY0I1VUdmVVhoOUFST2tKSDZMcjMwRjBUeWVIMkxVSGtzekxnN05QRjZFRXM5SlcyODdtcXJkYjYzR3FQdGhxaEkzU0VqdEQxRnZxRXp5L1lUUDk4enFyMHQvUXdldkJ1d25YTWJUdWZPMVJrY1N2SVZIMjBxQ0RaclFXaEkzU0VibG1odXliRzIyOGtHczZ6azM2akRrWVAycUM0ZkJ2NnZGNUZvTm82TGJZb1FPZ0lIYUVqOU5sczFHWCtuT2x6TDd3eUh1MStJVUlQVEtMOXh0c2RqbDBxeGlFMHBjMkpDSXByamRBUk9rSVhodURFTWhPN3NWeU52YjB4RVJyM09VSVBSRktWRFgzdTZGZCtvcG5haGdTQ1lzWUZvU04waEc1Um9TOGVWOVphM08yZHRlUFZzd1doKzJkcnVCMTk3c2hTZktLSE5SNHhHNkVqZElTTzBQVVMrZ0Y4N3BlZDQwYmZld0NoKzZNZzJaWStkeWpPdzF1Z2VTQ2lGYUVqZElTTzBQVVIrc1IycWZqY1h4OTlyOUM4N2tFcDlBUjcrcnpMQkdFMElYU0VqdEFSK2d5ckJlNnZ0ZytmeSt1ajczdE1VSlduQmVHallLTTlmZTdZcHZoTUs3UWZOQWlXcmlGMGhJN1FoWEZZbU0rcjl4SVBKM2NlZlY4MHU2MzVJS3ZXcGtJL3JQUk0yd1VjdEFHaEkzU0VqdENuMlNSMndkb3JpZ1YzMTQvK2NQY1Qxei94eEMwLy9KM2QzSHpyRDI5NVlyVG9kLy9odnJ1VXhycGZpTkM5azU5blU1ODdGRTkveEFzNGFKNzlOMmxCNkFnZG9ZdnJFQWtOY0w5UjRmcnorNTVZdFgrR2w2Ly80Wi90SXZPN0hyais1VmxGWDNYM2ZmTFhvNC9WbEpqTlZKM0I5aHh3ZHRuVjU0cWZQMDZGbTZCN3B4bWhJM1NFanRDbkdCVGs4K3YySGp5NDl5MUZQci9ybGdmM2UvTHlFN2Zhb205Ky9aL21GWDNWSDJTK2pVemtqSHRkUkswSDNYT2d6cTQrVjc3OTJTSnpEb3ZRRVRwQ0QxNmhGNG54K2J2N3h2TzNLM0Rpbis5K2ViODNEbDF2K2FIM1d6LzJXdkw5TDkreVUxNWU5d3ZHcHRHckVQbzhqdHJXNTQ1SXBlZDZVc2hoM1pWMnYrWUlIYUVqZEdHTWlKdEEzNmRrKy9NZlByamZGMys2ZTZlVmRmN25Kdzc1S3ZrbkQvNUlWaGQ5OHo0eHU2TkhCOWxUWUgyVWZZV3VlT083WGpISHRmMVNkSVNPMEJHNk1QcUUrSHpaV0lUN0V2a2V2dXY2L2Y1WWRhdDFsWDdmZzUvNEsvb1Rza3ErZkd6UWZRTkNuMHRCdUgxOW5xZTQ0UWs2OEJCQ1IrZ0lIYUZQa2liQzU5SDdGQzFBMzNucmcvdjk4NmNIck9yeld3NEZLUG9xV1VFQVk0dlg5cjJodGQ2N2d1c2g4SkY5ZmU2b1VYcXlIWUlPWElmUUVUcENSK2lUeElvYWNMOVJ3WEI3NWY2QTNHM052REJQQkM3NXk3S0czVzhVc1hZdHVKNFh1YlUyRnZxdzByUHRGSFJnZGZkQS92RVk5U3dvUU9nSUhhRmJFeEVwWDVVRnhEMXdhTDhNcnJmZ3FQdWZQNVpUOGovOVVHNWduTllVc0puQjlBaUlMYk94engyNVNrODNYc3h4ejBhcHFlczRiUWN0UzBIb0NCMmhXeElCT2N2R0p0Q1h5MTZ4OXNCK2VWalA2RHR2L2tSV3lRL0pNZnJ5MFZyYlY2MnQ0cnNaY0xjSTlZbzdyYnRFSFZwRit0OFJyY2ZNUWVnSUhhRmJraTRoS1dYa1ozeDk0SlA5Y28xdU5aOS9MTGZraCtTTXVsK3RmU2ZWMUNCNkFoeXJ0N1BRbGI5YURZZzY5SWp5dXQ1ay9Pa2lkSVNPMEkxZ2wxYWZWKzNiZTFCK1Jwa2ZIZG92RzR2Tm96OGh2K1NWTXZMRzdYN3I0TUc5MnVMaXNvUG5BVkRaWm1lZk8wcVZUM1dKT3ZTZ0NhWkM2QWdkb1Z1VEdxMUN2M1RVUzdKWG9QL3U1ZjBLc0ZTcyt5MUtTdjVnNE96dU84Y0czVC9YVlBWMXdmTUFhTFMxengxSEZKK3dzQ1gzN1FnZG9TTjBoRDVKbmRhbFUvc1VETGp2WFBXSkVpMyt5VUxyMGU4N3BLVGsrMitXTStpKzkrQmVUUnVwTmdSTiswOXoyOXJudFZ0TjhOZ2tIUWdkb1NOMGhENVY4OXFYckYyd1c0ZFI2NGxGM1piWnJPV3VCeFVXL1JZWmcrNFhhRnk2MWg4MDdiL0gzaDEwRlE5dVlUMzBjb1NPMEJFNlFwK2tVNXZQSDFPU0l1NUgrNVh5aEZXRWZyM1NraCtTTVkyKy9PREJ2VHMwVkg1RXNEVC9rVnA3QzEzRlVJbXdiV0taUTBmb0NCMmhUeEdweWVkNW55dElLYU80bHp2S2ZkYncrUStWbDN4VjROZWNuVGRxUytsK0psaWFmNnE5ZmU3WXBQeVVxMFFkZXlWQ1IrZ0lIYUZQMHF4SjZHL3NQYmgzdWR3TytoTytKOUJ2L3NzNTUzeG5sVG90R3BGUnhzdXJ5S0h2ZmpwYTVnYy8wRExvdm5tMGkxNmh2dmFMZzZUMXQ5dmM1dzRWaVZhRVJmVW5JWFNFanRBUitpUUxOQWw5eThHRHI4ak80TzQ5ck95REIzLzFpeFhuamZQYXQ4NDVwRUtMK25PM1I2RStXL1hMYjArVitjZWYrbHE3Sm1NZjJLc1BIcnhVZmUxdkNwTFdIMjV6bjZ0NTlyUUlPbmE5aE5BUk9rSkg2RlBUbDVxRXZtL3ZYdGs1WDczblpibjV4NU5tbk9EOFgzb2tlbi81THZOOS9qdVAxNHp2ZnV1ZDJXVis3UnVIMUdiRzJieFBTN3E0ck9Cby9JdnMza0ZYczN4UVZHSzhMb1NPMEJFNlFwOGlTWXZQTnloWXN1WTFJcTd5NjNOMFBxNzBjeXlYWG1adVJOekx0Ny9qV2ViWC91TFY2REkyWGx0NzhPQUIxZFdmRVJSdHY5SzBKTzYxVVhsNTBkRlY0ZUhSWTBTcERqeHZWSEhXbXdTZFF3dENSK2dJSGFGUDQ5SWc5QmNQeXUrZzMrekZlTis5L0R3di9IaE9KLzFQcG5mUjU4NFZmT2MxTDBWKzV5dnF1K2dIVlZmL3lxQm8rNnVOdFhoMVprdmNpZU1mdGlhbXpjKy9YcENldEw2b3ZMbDRPSzR1dGMwbCt5dlhxempyZkVHbnN4R2hJM1NFanRCbkpqRFYrN3hpci93TytuMWVoUGZwK2VkNTVkdXJMTlZGbjlOQmYyNkY5ekovcTBSZEYvM3Fnd2RWSjVkSkNvYW1iMXdIUGJxcHMzbXBVMzdKQ2hJekRuZldkVmNIK2w2M3VoZHBNU2VWWVlhcDJoQTZRa2ZvMWtSRDd0ZkZDanJvSDg4UGNUL25uZk44OE5yVzJVUGNmN2JRRFBxdmZKYjUyMTRDM21Vc285KzhWLzBXTFFYQjBQU2JqWEI1ZmZkSEg2YXJMV0Y2Ym5GT3NwL3grQ1pWM3lwbS85U29Bak5NSlZKVUNCMmhJM1NCSktnWHVvSTE2TGQ2Nlordk9NOG5yODFlSi9ZSDY0UzRQL2VPN3pML29uSis3bG9aMHdXdkhOeXJzdnFqZzZMcDZ4L2lYbmFxUFZaN09STVBONFRYQ2h2MWxxVGpRczZ0eVJSVElYU0VqdEF0aXZwVWNWMEhEeTVYWThYSitYTS9QaC90Nzg2eTR5cHpkMDJkOVc3eDZUdit5dnd0Vld2Umx4ODhxREpiWEZzd3RQeHluVzFlMGJsZVhHR2Q1ZXU2NTIvejJxN3F1OUtGN0JkN0ZLRWpkSVNPMEdjbzFqRGkvcFpzSzg3YlphM2t0ZlA4Y3J0VjBzWE5KSW43WU5YNS9zdjhxL2w1Y1dRYzRDMjFZKzVCc1IxNnNwNDJqMm80SnJ6QVd6dDZvdWNPNTZzY3k2L1JmbjVubzdhYVlpcUVqdEFSdWtWcFZ5MzBDdyt1VmI5bTdjZm5CZUE1aTJSMG54VVM5NHNBUlg3bk8ycFMxeTQ1K0tLNitvOFBnb1ovVEVlZGg4YzRkU3IxU01Tc1JHODVLcitrMEtRVjhBZ2RvU1AwNEJWNnZscWZ1K1FubGRucHVjM2FvVThEK2Z5ODgyZUd1aDgwYzhSOVp1ei9Hd0hMZlBtOERETXlRdlIzNzkzN3Jxb0xrQk1FRGI5T041M3YwamZ0VHQ5UThzU01lckxhdDRhQ2FPMG5XWVRRRVRwQ1IraXppRlVyOUdYeVErTG1qYmhYamcrNHIvanA3YmYvMU9kVSt1MkhyRERtUGpQaXZtcEZRS0dmOTB0UG9jdDVGN2x4N3daVkY2RFQvdTArclY0bm5iZTFHMUQ0bUthQnRqUHFseHFjMFh5VzNTYVpDcUVqZElSdVZicFU1M0Zmb25yRS9aZGpBOVMzai9mQkM3N2lJOUxzbmU5T2ZmcVRKeXd3NHY3SjdaUGxXdkhqNXo1OTduYnZkbC94b1BKZFZIY3VVWm5QZmNqKzdYNVlweFhucSsxdzhrN05TOUVYSUhTRWp0QVIraHlhMUU2aDc5MHQxNHFlSSs0bDU0LzYrcmxBYThHK1pZVXg5K214aFpzbkZYNjVjM3prWUpYM0NmV3ZIRkllNTc1N3I3cEo5RVcyYi9hVjBYcm92TGJmYVkvVEg5SjRvc2xtbVFxaEkzU0VibFhpMUc3TUludkVmWS9ueHFoZkgxUGYzQis5ZGRGL1AvMkozNW5sOC9zOG8vaGVLNWg2S2JsY1RoZjlrNXZsakxudlUzVUJjbTNmN0xOMDBQblp0cVYyT2YyQ0NtMHZMc2ZNTWhWQ1IrZ0kzYW8wcXN6N2VuQ3QzTDNLNy9JY2h4N3RvSjlmTUd0RzNjZHlzQjlQZitJQnM0Uit5L1Fnd1dRSC9kUHBMdmgzdkE0c2ZOMHp0NHlNU2xxaWJpVjZuKzJiZmJZT1FpKzFVZjY4UVUxbmVzbzBVeUYwaEk3UXJZcktkV3NiOXNyT0t2T0FoK1NlbXlOcjMydllwcnU3aDY0M1MrZ2Z6NTcxSCt1Z3o5ckkzV3NYL2JWRHloZXViVmExNDVyTDlwbGZrOFNIeExuYWJWVURQUnBPdGNwcG1xa1FPa0pINkZhbFQyVmFtWDE3MUU2aC85U3pKL3ZMUUpsYVRKdEVuMTYwTnBrSDU2ZUhBcjJHbktOODRkcWVDN2JrcVJnaXNYMnJQeUhjNTVrMjI2L0dxWDVubXRwYzgweUYwQkU2UXJjczBhcUUvcno4S2ZTNU82ZCs4T0E3bmd1OGZ1VXJQZnIwSjB6YVEzVTZCZjN2NTZkM1BYUjdnSG1DaVVuMGoyVWM1cFhuUXpKUlhKZG9uOGZIMnEwS2pxbmVoUDJFaWFaQzZBZ2RvVnVXVkhWN29hOVYzczJkbGFCbGRtclgvVi94bFhwdGxja3IwWC9vV2NMTFB3aVVPTzc4RXVVcjBaZW8yUk05d2U2TlhuaVd1Tk0yckFTMW04M0ZtMmtxaEk3UUVicDFLMStWME9WUG9kL3FaY1I5OW1UMC9zOHU5NVdvNVJzbTc3aDJ0MmNKMzdsNUpyTzdqMFF6bjNxY3JvemRYNWVyQ1hNL2JmZEdIeWZZNTVHMnJJV042bExLeEpwcEtvU08wQkc2WlZFWDVyNXZ0K0p1N2lUbmUrWnFQeWZ3Qm1aUG1Cc1Q5K0IwUlB1M1BndVVqZjRyeXFQaWRxc1JlcVBOMjN4bEx6NGZvMTlOSXJ4MFUwMkYwQkU2UXJjc3VhcUVmb0h5cFY4VFU4K1QwOUhuVHllQzIrcDdFN1B6cDlPNm1DUDBCMmZGNVh0c0EvZDFuenUvZWdoZHp1RENXeXF5dVdmWnZNMFA0bk8xUnRmbWM0U08wQkY2RUF2ZHFjYm5iOGlQaWZNSWNwK0tnRHQvY216NkwvNDJKVjMxbWFsaDduK2FMUFBzK0xkdlAxZTUvN056Zk8rOHRxSlNlWmo3SzQ4cHZ3SWpObS96RFVKOXZ0SEdOYkZHNGJtbU9rMDJGVUpINkFqZHVtU3FFUHBqVnl0ZnkrMDVWUDJMWDUzejZhLzg3MGs2dFFqc2tDayt2OHQ3L05zN0s5N3hWK2J2emoxZk9iTUZWNnZJTEJOcjh6WmZMZExuRGJhdWlrSkZzZTQ1SldhYkNxRWpkSVJ1WFhwVUNIMkg3RHh4ZTFaOU1rZHdsNStuZ0srYm12ejExcm5UL2pMNXhseWh5MW0zdHVSMXhSZWd5K1pOUGxla3oydHNubVJuZmJqc1U0M2FaTDZwRURwQ1IraldKVktGMEsrVHZkWGFucmw3cDM2bVNJN2ZNblhkMmxRNDM0TktpdXdSRmZmSktobEJjY3VWQzczSjVrMWVaSXg3VmJyZEg0Q3gvYlh5VGpVNTBRS21RdWdJSGFGYnVMT2tRdWl2eTE2MXRtZHVCNzFFa1J5bkk4eCthSWJRLy9ESjNMUXlDbDlDSm5oWnhvRTJMMU44QWVKczN1UUh4UG04L2xnUVBBSmJNMldjcVN2R0VxWkM2QWdkb1Z1NGUrQlNJZlROY3EzNDU3bCsrNjRpT2I1bXJ0QW5KL0RQVVZUbVh5Z1grdTVsb2JacWJiM0FEbnBNY0R3RU53WEtBeHUxYnFzMVRJWFFFVHBDdHpESktvYmNkeXVPTEF1MDZOeHJ5TGlwbVdWdUNaQ2FOc0JMaUlKNFB1VkQ3b1AyYnZFQzg3aG5COHRUc0xMWlh5KzlOeUxkS3FaQzZBZ2RvVnVZVWhWUjdyS3QrTHY1VzYwcHdGU2gzeDFvemJuL3hmT1R5RG5TZFlvdlFKSzlXM3kzTUorN2tvTG9RWGpzbE5kME8yZWpXZ3BMckdNcWhJN1FFYnFGS1ZTeDE1ZnlVUEZabWR6bE03VzcyUzAyRXZvSGM4OVl6c1l5aXBldFJkdTd3VHZGN1p6YUVXVFB3dGFJMUx5NUlRSnRwN0tjSW8rQTBCRTZRZzltb2FlcFNDd2oyNHIzZWM4ckk1TlZaZ3A5TWlYT1oxOVJOMDJnUU9pS0U4dlUyTHZCRndyemVVc3dQZy83eWh2WE5kVFYxZlgwbitsWUtYeEpIa0pINkFnOW1JVXU3VklzOUdpMVBYUTdDZjF1TDRuaTlCRjZoZEw2TDdWM2d4ZVdKaTZxVHdLRWp0QVJPa0tmb1Y5NUYxM3RITHJDSWZlWExUQ0hma2ovT2ZRM2xGYi9hbnMzK0RKUlFvL0F6d2dkb1NOMGhENW5CRlM1MEdVdlc3dkx2a0Z4dDZpYlEvOU11ZENqbFZhL3ZaZGU5NG55ZVhTc0JBZ2RvU04waEQ2TE5PVXIwV1ZuaXB1N0R2MFRsY3ZXekZ5SC9vbW1aV3R5MXFIdlVWci8xZllXMlhGUlFsK0VuaEU2UWtmb0NIMHV5bGVpdnlSYmkzUDk5aDExdzllbVpvcFROcXJ3N2MrVVo0cFRXdnZKOW03dkNZSjhIcnBQVElTTzBCRTZRdmRGaEdLaGYwbGxMdmRWaXVSNHVTVnl1ZjlGUytwWE9ibmNsNFJZNHRjcWxxd2hkSVNPMEJHNlRoUXBGdnFGYW5kYlc2RkVqajgxZGJlMSt5Wkxmck1pb2Q5K1NQRnVheThwcmYxTnRtN3VLWFRRRVRwQ1IrZ0lYUzlLcXBRcTVWSzErNkcvcGtpTzF0Z1BYZEZMeUsvbVpuNjlYa1lQL1V0S2EzKzlyWnY3Sm1iUUVUcENSK2dJWFRlMktWWEtZdG5KM0orWUsvUnZxZGxiL0VGVGhMN25rSm85M0QrZGU3NTN5empPaFFvcmY4RGV6ZjJVb0JEM1N1U00wQkU2UWtmbzgxQzhjRzJENHZRc2FoWjEvMzd5cjI0MlIrZ1BUcGI1eDByS1hEQlg2RElXM08yK1ZHSGx4OXU3dVdlS0Vmb0ozSXpRRVRwQ242WWczYW5mT2RsTDZNNXFwZnVuN2xRYVdxWml1N1VWbFpOL2RMMDVRdjlZUlhxNzF6eFN1Y3NKNTF1c3NQS0hiTjNhWThVa2NvOUtsd0NoSS9TUUZucEt4dEdJVS9HcGJlL201VTArVnFMeVhBTnRxWFZ4WjVxWGJoVjVUdllTdXRTaTIzWnJIcmxmUzk1UnNiWDRMZVlJZlhKdzRSTWxtN2ovV0hubTE5MEhGRlora2ExYmU2NllEdm8yMUl6UUVYcW9DcjFrL2FiU21ySUFmUU4zZDBOamthRE5FR3dtOU5VS25mS3VmQzMrYWE3aHZpMWZqbCtmK3BzZm1TUDBCNmFPZjc3eWFYOGxzLy9MbE5WOWI0R3RXL3NaTVVJL0pnRkNSK2doS1BTVTVwdzIrY044OVpseFJ3UU14ZHRNNkZ1cjlVb1Z0MmZWWE1VcDJMdnNPMG8yT0JIUHpsdVZSL0s5NDNHMmNsYXQ3ZHdSVWxQb2RheFpRK2dJSGFHckVuclM4YnBvNVY5WDM3MHhQN1NFTHNVcnpTeWpOc3o5OS9Lbm96OVRrajVWRDZQL1NYRUcrbDhjVWg3a3JuUnZsa2g3dC9ZS1F1SVFPa0pINklxRlhwa2JGNjcrSzdzaU5HM05hSXJRdDZiM0phNWNtckVnSzZ2NThPSGl4c1kxdzZOMGxub1FNZmJib2NiRzQ0Y1haWDJZa1hGc1pYNWZTbnF4Ymd2Ukg5aXZjaVg2Vi9hYkd4TzNaOC9Oa3dYNGJJVzZWZWp5Smd1VVpuNWRPVGFGbEo3V2w3K3lkZlJTZDR4ZjZjaXhhN3F1MU51bGpteHNiRng5dURucnlNU2xUdHBxYm1OMzFvcndlVzBTWmtib0NEMTBoRjVTM2xPdDlWdVRqNnZmQkVOM29UdFQxdWVXTDRvNUUxSGFrQkJmMDUzWkZhMThpeFVOSEZDN2dhcjh6Y3QrYitwZWErTlJjVk5aN3VRdVhGdmhNZUorNk04eWpuSzF3cXJ2aW83V2R1MnFxOEl6dTJ0YTZocEtJNGFPTGlyUEhla3pVUElaUWpyb3FVSHcyRXVLeXd4WFM5UHhTdE5NVlI4dG03S2Fab1R1NndGZUhxT1dvd3UwaDlHa1o2aytlbnVzNFVJdnluRUplVzY0MWlWWlIraXhLVXNYTENyZTJOK1RuZHhXNVRhWjF4VXY1NTdrZzFVeXU3dmZudjZUVzgwUytuMUs1d2s4WTl6bExLRGZlYUhiZk1hV2VyVDA5RzhzYm01Zm1xSnIwRjJqa0lZWlkzK2ZaK1JwZTZXSk5jMVVpb2d2UWVoZXYxL1Q1YTh1MUhoNncxRWFqaDRvOTdSZ29hZXRxUkIzUDlibjlKa3E5TmpFb3F5WWpYRW5VOXNDZGN1aXU5cTZrMnV5NHhPMm5TbzlQVHc4M05qWWVQVHc0Y01kV2ZNWS9lM2htTWJHb2VHSTB0S0docFB4MlUycDNidTZsQm5nRGZsYTlKaEVseHRpOXR4K2MvUEV6WjVFbHh1Yi81MzlLcWJRdHlpMWIvUkErTmlsYm9udmFlZ2ZHMVdQYkd5TUdiMmttK1pmNlVXanZ6NDZlaU9jbWJqVUNmSHhOY25kNFdXQmJxV3F0dFNFdU9HWXdpSWQzTjRnWk1ROXpmWStUOG5UV0FkcWR1aUp6WWhJalRwcnJORTNJblFkdnI2MlhkUFpSV2c4ZkxOeFFzK05yeGQ3UTliM0pCa3Y5UFQxQzQ1dlBOWFNQZURybVI2K3F5YStKNjd6VEV6emtZeWw2L3ZTTmUrUVhSbXVWNWk3UjJxWi9iK1h0UlQ5dGVud3NpZE1FL3BNSXZwemxDMmNWNUpXUnVFeTlHb2h3K094NlNuNVN6T3lOaFd2Nll6YkZsL1QzZFhyNDNCbDNmR25OaDV2SHhHV3hxVmJSSnZjWmY4TytqYU5WWEEyU3VGYUhHZjdSOTMxRHVPcFJ1aGVMb1piNjdlWGFacnQwWG9qVkpjWUkvU0NUWms2M0pKUnc3RkdDVDF0YWVGUWYvd3ViNC9YNkxiVWs2YzZoNDRmeVYyZlZLTERIYnhSci8zV2RsYXE2YUkvdDkva1ZlaHpBL3ErcmFhRExtOXM0VHBMTEZxTFRWcWZlMlIxWkVST2ZHcWIxOXV2Tzc1L3FIQ3A1cTV4bm9nV3VkSCtRdGY4UkhlMEt1Z2ZGUGEzMVRwTUlnbWh6Nk5jKzRscldZZDFWUFBSYzQwUWVteGpsVTczWlBTSE9ndTlJTCs4MFp2SXE5dHFFa3JYSEMxdlRZblYrd21Ub2l5b2JyRjhMVjd2NGJudnlwaEZuOTRLZmYvTE84MFQrbDNUd3dTZkt0OEtmZjhuOHNZV2xNVkRyRGJDTnJFcHJlV3J6NVFtcEliUHkwL1FtOWxTMnRpZXFIWXN2azlJZTF4dmU1ODd0VmZDQXBtOXNlYWNjSWVaSkNKMFBRSVpCazBjY1hjNE92UVhlbXhrcjQ1M1pWMjZQa0l2NlZ2UVdOclM1aUhUNkYwdE9jTXg3U3NOblNwVXRoVDl1cDJxeDl4bEJMcS9NOVBaZmNKRW9jL2EvUFhITWtMY1AxTXg0cjVuaWJMb05hTlRtS2V0YkQ4NmZLb2wwK05kMDlVMjduWEZRMFh0SWhwamxmMDc2T21HQ0QzcGNFT0Z3MndRdWk1Q1g2RGg1TmJaUU9qTlZmcmVscTRzd1VJdldGODRuTkR0OGh6WExHM01PbWJPdmhNTGxDVi8zUzAvdHV4bEQ5RjlGbkF0K3UzN3JURGlQbnZNZmRYNVN0ZWd5eHh4ZjFGUnRXZWJwcUMwWTRXUnBmSGRjOGNUcXJzVE5oYXVWOUJkSHhMUkZuc1FldUFuZXQvaG5qS0hGVURvQ0YyeDBJdDI2WDlqOWhjSUV2cVl5azltemxGNVdVM09tY0tWSm04ZzFhWXNWNXo4bnJObm5Qdiszd2NZZEwrOFlMLzVNZTRlN3lLQjR1SitlbWkvbWhoM2hYdXRtYjllYSt1eHdoTU5OV1Z6dXV1Wko0YzdSbVExRHlGQjdvY1J1djhuZXQveGhDcUhWVURvQ0YxeEpMb2hkK2F1UHMxQ2QrWTI1aVRQbnBlc1NtMDRVWGpNYVltSFRLT2lzVi81aytnN2IvVlUzZjV2K0IrOC91N01KMjh4VmVpejMwWDhaNkUvLzBIUGN6ejBPMW1WbzJ4ckZzdGtTSE9PZVQxMWRuKzlPam1uT0RmUW5aeXNkNWhWeUF2ZHFTcmJOVUpINkJZU3VrRzRXalVJUGFYOHhNblpmZUNCbXJqaURFczltcHlLTXBBcFNDMHpuVU4xaHR2OVRhQ2ZNL081UDkxbHJ0QnYvV1JHMFA2aTgxZjhmdDRweXN4WSs0WTlSdHg5emRJT05wNnFtYjI0c3Uza2lmSVUzNThYRWVkU0ppRjBuMC8wWTlGV2Uyb2lkSVJ1VmFJV3FSZjZqQzJqYS9xTE02eVlHcU5UMFlMb3pYdlVoOFg1Q3pKNzU3bFpIM3RpajhuTWhNWHRyL3lGYjUvL1pmNFp5Z3FKMjYwc0ptNlROZldVbGhIVFh6UHJCdmY1d1ZpbTBQVVZlcHJMZ2RBUk9rS1h5eHJWUW04YWU5U0Z4dzluOVZuMkthTnM1ZHFGQ3NMUFYzMHliMERhVng5OXhYT0toNjBOU2Y4NlNvbXZQdnI1bjg3MytjZnl2djl6UlZ1aE82MHNxY1RDNGZqeGhJTk5Qajh5SXFJTkhrWG9QcC9vNnh3SUhhRWpkUG1zVXl2MHhtMlJHZWtXZjh3MEtMSExoajJhdXVqN2YrazFZOXo1Yy9xNnBuZlE1M1RSOTFkNm4wZC83YnY3VlhiUTkremNvS1RLRzJ4Z3FzSEliWTArLzIyaGlDYTRIcUg3ZktKM0kzU0VqdENWMEs4bEtNN2lKQ3Jwb3IreFI5TXMrdjc5My9HeWV1MWJEMzR3NnhOLytwMzVRcDhiMFhlT2w5VnJ0Nys4WDNVSGZjOWpTb1NlYTNlUG5SRXg3MVdDMEgwKzBjTVJPa0pINklyb0RGNmhTejJLRnE2cEhMbWVHY0wrcFljZUx6OUh6Y0l2blZldXpWMTA5K0JYUEpiYy9lSXYzazd0a013dDRoUk5vV2ZhM21NaW1ucTNoTkFST2tKSDZLSW9EaTZocHlmMXJTekt5R3BlM2JnbVFsRzJ1QU83RlhqeGVtL2EyLy9ncjJhU3BLLzQxam1mZlREMzMvN1pBa0xmYzVkSEIzelZMMmRHRmxiOCtGT3Y1eVY3cnVCU1JVTGYxdi9SOEpuRzFjMVpDekpXNWd2WWtjZHdhZ1EwdnppRWp0QVJPa0lYUm0yV2pZVmVrSmJmMnI1b2JKZXRudmlhN3ZDcWF2V2JhTCtoUk9pL2U5bTcrZmF2ZXU0clAvN1d0MjcvK3FjbDgvN1ZEL2RZZ2o5NGx1dURtNzh4WHVaZi9xWFN4MGs5S0hlMTNUSzNGbHdENGQwMUxRbW4xcTJKV2RSZWxKOVVZSFdQaWZETllZU08wS2VwcWRPSFhRZzlaSVIrTnFySVZrSXZTQm9aN0NqZTJKK1FuUndlN1JiSWkrcXlxSG9kb2o2MFgrMUNidjI1ZVY2TS92NVBQdkY3T25MejFlNnVjZ3VsTnp3NXU2ZC91SGpSZ3BHa1NndDZ6QzJnK1kwZ2RJUnVBeEM2ZmVoTnM3elFLNU9PdFk5dG1OV1VPZURQQU5FVmJkMDEyZkU5T2FVUkd4dGpEbWUxS3dsMFg2WklpOWZ2VjhhREduUEtMUC9KWHkvLzYwK1dDeEM2ejlFRlg4Z096dithRWxzdktNbzRVbmc0cG5GalJPbXBocnI0bXVTMkNyL3Zad09aMlFtbGE0NjNqMWdtNTRHSVplajFCUWdkb1NOMGhDNlM1QktMQ3QyNWZzR21OWEYxcVJVKzR0VUgycEt6RTA1MW5qbmFzYUJvSk1YTE1ybzBCWDE0MXhJbE82SGQ5YUFpS1g2aWJWZVc1WmRQQmRvdDBXNzBIeXJ6K1NyWmMvOEhGUGk4enVzRjM1cVMzN3FnSStaTVoxeENTMnFiajVjM1YxZHFYZHlhMVF2eVRaNTFYeStnNlFWRG5qaUVqdEFSdXFXSXM1YlFDMUp5RjUySjg5d0xhektsVzNoeWZNNjZNOGVQNU9hbnlSaUdIZElsbi90NHBQdWZsRmhSVXhMM25UK2JXZVQrenMrRXBuUVB6TXUzeXYzYTNVcnl2c3JLTzF5WmxsOVVmbmlvc3lFK09keGJlTVJBZDN6Y21lYmNQbk82dVNJMlQyMUM2QWdkb1NOMHdiUmJRK2hKUmMwYkcycTY1dlhIWFdYSjhhZUdZd3FMOHBVbUZ5c0lsKytZaXQxN3hFMmppNXhBWHpzbmFjMWE3V3ZYUHBaZjhrUHloeGFVakxqWHFCaXVTU3c2RWpOOEtqNjViUDc5RWQ2VWM2SzV5T0M5QkZZTGFIaWxDQjJoSTNTRUxub2FQZDFVb1Jja2xqZjJ4MmYyZXZiR003TnpJbUtPdENacFNMNVJxTUF5enl2ejRpMnlyZmp4VGswQ25ydFdmTVZtelVhLzYyYlpVd1Yva1ArdFN0TEV0V3VNcUNpUGlXakl6cXllZDhPMGxEWXU2RE1vVjh0R0FRM3ZLRUpINkFnZG9Zc20zaVNocHd6R2ZCVGY1dEhsNmtwTjZDdytja3hNOUZPTGZNdnNVT2pkdTJWYThXWnRLOUMvNlpITDdac0NWcU92a2xsMEJUN2YvSzc4bWs0VmRQdWtyU3lQNmV4SnJmRG9zR2ZHZnhRenFQc3VBM0VDMmwwUlFrZm9DQjJoQzJlUndVSXZXRis0TWFHNzEyTks5T1M2NG5iQnNVNkoxVHF0WEpOdGRJMCszK21abi9YOFBVWVpYVW4vZktlU2pWa3lSQWVjNTdmSHJFdEluaHRGMTl2ZGM2SXdYNy81OVhnQnpTNEpvU04waEk3UXhRKzZPNDBTZXV6SW9vaTZ6RG1kOG9IVWhoT0Z4M1RhN0NWQ3ZtZXVVNXlsNVJNWjgrZmF4dHYzYko2WGJsM0U0clc3Wk15akgzcEF5VGRlcCtzTXVzeDU5bU9GSnhwcXl1WjIxK3NpbWxmcW9mVms3YTJ1WGtMb0NCMmhJM1R4OUJzZzlKVHlOUWx6VkY2VnZHMjRlZWxXWFo4MnNabnlUZk0xcFY3OFVjQkYzWm96dUMrWkovUzFBb1R1bWRYZFMvZjg1ZnVVZk45TEZ0cVd4WGxzMGNhRzVObExGbDI3ZXM2VXA0ZzlTb1gyUmplQTBCRTZRa2ZvT2xDL1hrK2h4eTQ5WGxvemV4bmFRRTFjNDZBeEE0NUYrczJpNzluek8vL3haUy8vYUk5RmhiNW56d1ArWDBZK1ZwWUtaNFA4dmUxT0d1U1psTUhHdURuZDlhcWEvdU90d25aaGQybHZkTWtJSGFFamRJU3VCOGs2Q2QyWjI5Z3p1MXRlbGwxNk5OZlF2ZFJMNVJ2OTc4cTllSXVmQmVuWDM2WGR1OHQxR1hJZmZ4bnhNK3orOGgrVTlmZVh5QStKY3lVYWE1dmMxUjlsbDgwZWc5L1dtQ3ZDNnZYYTI5eEpoSTdRRVRwQzE0VjI0VUlmZGZtMldTNnY3bTZJSERRaGM2ZXpUZjVhZEJWcnduNTMvU0VmMFhBL0V1SmR6NkM0RlR2M2lPSkhxN3dIQVJ4NlF1bWJ5R0w1TDAybXJMMU9Hb3hzNks0V2FmV3RBcHJjT2cwbmxGT1dGMlhBZjZwVHl4RTZRa2ZvOXFOTnBOQUxqaFhQZG5sRlMrZWlFZFB5VmhmSkh3NWVyTWFMdHo3aFphT3lqMzhreUxwLzlSRDZYMFZ1MWZKREwxTUdMei94TzRYZnNudXovSDFaeXJhYWRSdElCZXM3SWxyS1psbTlJV1pFOWFMMVJBRk5ybGoxcVl5NGpIc3dkQ0owaEk3UTdVZUhJS0duSGVtc21WbVFWaEcvc2R6czFUbkRzblh6N2xwVi9kKzdIdmg0dHRNUDNYekxyY0tjdTN4T29yanozbG0rUnlpMzNqMm5tLzd5eHcrb1dHYW5vSVBlYlBZQWNjcVJqZkV6SzlkN216ckxWWTBhRlFsb2NZVnF6Nkd5d3NnSHd3S0VqdEFSdXUzb3F0UXM5TkdPZVUrYnBWdytVYXhVMmI1NVhYWFkrSDEvZU9MNmoyLysrT01uYnZuUlhVS1YrOXM1UXYrSitCMVY3L3JoTFU5OGZQUE5IMTkvOXgvdVUzWHF5NnZNWDdLbWNNUzZmR044MTNTaDJucUtqeWtkUHlvWDBPSlVoL3N2TVBUQjBJTFFFVHBDdHgrRm1vUWVtM3NpZTdwajNsdlRtV1dockJtSjhyZGQrM3puSHFzeE8xZmNOM2Z2c1I3eU8ralY2eTBVekpWVU9Hc29xVGY3VEs0U3FUY0xhSENxSzJQSTBPZENHVUpINkFqZGZ1eFNMWFRuNEhCTjlheit6bEtyN2ZPY0pWczVWVXVzSjh5ZlRRWEduZjh6QytwOGo0SVE5eE5XaTlBdVdEcHJUS20zWm5oUWJxaGNzWUFHcDNxeHh4cERud3ZSQ0IyaEkzUWJVcVJHNk03Mnp0U3BxTFBxbXM0amFaSVYrVWovUVhjZDJmMnp5MTg3Ly96TGY3YlppajVYc0MxTGNvRWxiNDYwOG9qcDkxRlhhbWU3SEttZjBON2MxQ2VLUStnSUhhRWpkSldUWmI2RlhsSzBzV1pLNXRIWkozS3QrYndlTDZuOGFmUXRsclRtN2owN2QxcXlZRHUvSkhzUlFmV0laZStQT1ROR3JwcU5yWUhDMzA5cmIyNHVoSTdRRVRwQzE0M2FQaVZDVHl5dW01cWFyb29mYXJXdXpDY21UTHRrYStkTDFqU25SZG05US9hcjBwQzFieEdwb0hVb2ZpcStyNm91SmxIbmh0NkYwQkU2UWtmbytyRk9ydERUQ2srRlQvWE02eHBYVmtyVzUxaXY3UFF5eTlHMGZMYkk5bm0yRGU0U3FYSmw0L1I3YXZpcFFwL1QzQ2UxdDdaTWhJN1FFVHBDMTdIcFZzb1VldDMwMkdSUmlXUVRPdVJQbysvRzAzSzVXdlo3MG9CdE5ndWROWk5VNStzekFuWlBUVWJvQ0IyaEkzUWRhWmNwOU9Pano3ck0wZytka3AzWUtOdm9CeEMxM0FGMytkdW10dHZxWm5GK1dEcTJUOTl4WC8rK1NYdGphMExvQ0IyaEkzUWRpWmNwOUpTZXd5bVM3Y2lSSHhqSE5Mck1KZWl5SStLRzdYZS9wQnp1OFhtWEM5Z092UTZoSTNTRWp0QjFwSDZyb2loM20xSFNJbnRMc0wvamFqbklqM0J2cVpTQ2lrenRqVzBiUWtmb0NCMmg2OG5SWUJhNjVKUzllSzM2YTloYVJwNzVDcm4xMlpZZVhENFhZWnM0aEk3UUVUcEMxNU9hb0JhNmxMNUw5all0WDhMWEFTZlFYNWRibTlIcmc4em4wb0QydHJZT29TTjBoSTdRZFIxemR3YTEwS1cwVEZzWS9XZC8vV3VnRkxSci8vclh0U1lML1lEc0dZekJZUE81RksyOXJhMUI2QWdkb1NOMFhka1UzRUtYVXRwc1lQU3hEZGJlOFcvMG43MHoraEZ6VTd0Zktqdkc4TGlFMEJFNlFrZm9DTjFvV29KYzZBcU1YdjJpV2JIdTQ1dXhYQjc0STYrWjZmTVgzVUVjNEI2UVBJU08wQkU2UXRmUXJwTHIrdGZFZEN3WXBmencwT202ektpek9od2xxaURJaFM2bHlCNTFyLzdjSkZldUdMUDFPLzRTMXEyZDJIM056QUQzYXJuVjJCK0VQcGVpRURwQ1IrZ0lYZFhFZG5oUGNldjh5ZTJTWTJkUzY0VWZMQ1BZaFM2bHlZNk1jeS8rc3lteXZIeGMxMy8xazdEdXRZbFBtT2h6Mlh1bWJwT0NVdWphMzZaakVEcENSK2loSnZTS1U0VitFcktsUjNZSlB0N3BvQmU2bENaLzY3VU5adXhZdXZObkU5dWYrNTVGRC9nQnZlUGJiNnlTVzRQeEpVRXBkQUV0RGFIN2Y2SW5XMDlzVG9TTzBMV3c2MHhpd0RNNjBpYjBrSm5CTDNUSktUdkRqSHVIS2RJOGYySkUzZGZieFBMeE1ma0FzK3pXNkovM0ZFZ0lIYUdyZWFKSFdNNXJiUkpDUitpcUdZaVFtVjQxSmsvZ1VXdTNCci9RcFJMNVdXQ3J2bVplRi8xeTc0UHV1ODgzdVlQK29ueWZCMmYvSEtFYklQVDBYb3RwcmJZZG9TTjB0ZlBtSnpQa24xUlNxc0NMMXhFQ1FsZXlVNHRyOFc2elp0RzlHMzN6eEFTNmVUUG9sOHFPaDlzV3JENUg2UG9MWFJvcHM1VFZvbzVLQ0IyaHE2STZJazNSV1ZXV2lydDRjU0VoZEtsRDlyNmZlZGNabjhGbGNsRDl2TmZtaDdvdm1leWZuNy9acFBuenhiTGZoVDZTSklTTzBGVS8wUXNXbmM3eGgrWlpkbmVPYk9LS2t5U0VqdERWVUJVVHEvaThHbXQxbTBRUFRxRkxTMlVuSW5lL2U2bmhuZlN4eERGanJQakozTVh3dTc4NStTL2VNV25BZmJuc2ZLL3VTQW1oSTNRZG4rZ3hlb3JLaERzQ29RZWowS3RpQ2t5NXVhY0grd3RDUStoU2l2eGdkN2Z4bmZTZm5EZkorVCtaNllvdi84bUtxVitibENYdXBjZGtUMVZza2hBNlFrZm9DRDJVaFo1M0lsYmxtVzBVZGZXS1FrVG9Va0cvZktQM0xqYk42T2U5ODlvM2Y3dDI3ZHJmZnZPMW1WLzlkcWZGcDg4SGNpV0U3cGNoaEk3UUVYcVFDejFIL2FuRkM3cDZRNkVpZEVscTdwV3Y5TWVNRG5mLzdUdm4rV0tGS2Yzem5VdVd5YTZ0WFgwU1F2Y1BtZUlRT2tKSDZENkpGUlFVR2g4NlFwZldkOHMzdW52WjFjWUtkQ3I4YlI2dkxkOWpSZ2Y5NzIvSXJxcDRwNFRRRVRwQ1IrZ0lYVFd0WWhMQmxvV1EwS1ZZQmNQdWJ0Y0JZeVBScGlQZzVuYlBmN0xialA2NWd1NjVhMGlTRURwQ1IrZ0lIYUZySUU3STFhdU5EU0doUzFMNWdBS2x2N3Q0dWFFMlhmN1hGWjQ2LzZZcHk5VjJiNG1XWFVsbEdSSkNEMHdFUWtmb0NCMmgrMlpydFpETHR6U2toQzRseFNzd3VydDNzY0c5OU45ZVB1UDBGWmYvekpUZStaNnZQU2EvaHJLVEpJUXVnMUtFanRBUk9rTDNRNlNReTNjOHRJUXVTYzBEaXBSK1lLM0JNOWpMZi9hVGIzN3ptei81MmZLZE8wMEpibjlKL3RwemQzV2pGQW9JMkQ0MUI2RWpkSVNPMFAxUVVDWGk4dldIbXRBVmR0TGRybVZmMmhNNnZMUk1RZFYwajBnSVhSNG5FVHBDUitnSVhmY3VlazNJQ1YyU3Nyb1VLZDI5NDlMbDZIeittMDVFYkdqNFhISnBiMll0Q0IyaEkzU0U3ZzlubnZnV0hCSkNsNXluWGNxVS91Nkc0TyttNzN6eE9pVlZraHdpM2ZOUm9vVy9OeU4waEk3UUVib0hRZ0xkWTBOUTZKSTBVdU5XeUdOYjF1NE1ZcDB2My9LWW90aUNvWUtROGJra1lHNnJHNkVqZElTTzBQMnlVc1QxeXc5Sm9VdFNZYmhTcGJ1djI3SWtPRzIrKzBzYjNsVlVFeWRUcEJBaVhITWpPOXVHMEJFNlFrZm8vbWtUY1AzS1ExVG9VdXlhWHNWS2R3V2owMTlhclBEZEpuT0JGRklJYUdaVkNCMmhJM1NFN3A5aEFkZXZNVlNGTGtsSi9TNjNjblljK05MdTRKazR2M3J4WXdyUGY2Q3hJTFI4TG5WcmIyVjVDQjJoSTNTRTdwOThBZGV2UDNTRkxrbDkyOXhxcUZyMmVUQk1xTy8ra21LYnU2czcwNlZRbzBsQU15dEE2QWdkb1NOMC93allvcVVsbElVdVNTTjFiblYwYmZoOHJaMXR2dVR6WlZYS3B4d2FVcVRRUThUV2hra0lIYUVqZElUdW54enRGZHdXMmtLWHBQVUpicmRxcVcreDVmRDdrczhQUEtiaWRGME5pVklva2lEZ01ia1NvU04waEk3US9WT292WUtyUTEzb28wcHZjS2wydXJ0Nng0SFBYN0tQMVRmZnVHVkRoYm96VGNpWFFoTUJyODJPUVlTTzBCRTZRdGU5ZmRVamRFbEtPUjN0MWtMMWpnMWJYbHhpOFduMXpWL2FzbUZIdGRvempFdVVRcFYxQWg2VHpRZ2RvU04waEI2QUN1MDFuSTdRUjlrNjFPWFdTdFYxR3hiLy9hWE4xbFA1OGk5ZGV1RDFDZzNERUZVUmFWTG9ja2JBWTNJSW9TUDBXUXlFNjBNdlFyZTEwQVZNNzYxSDZPTVVGRGE1UmVDcUdQWDY1MTliYTRGaCtOMXJ2M2JwNG1YWHZhSHhqREpqbkZJb2MxU0FLZnNST2tLZnhWS2Q3dFVZaEc1cm9UZHFyK0VNaEQ0OW1kNGY3UmFHcTJMSHNnT0xMNzN3cFNVR3EzM3prcGRlL0h6eGhtVTczbkNKT0kyNkRDbkVFUkNwNG9oSDZBZ2RvU1AwQUdRSW50MXpoUGl6MjNrODFTMmVxc2Qydkw3aHdPSXRuNy80dFpmV0xoYysxYjU4eWRVdmZlM3ZsMjVaZkdERDZ6c2VtMHppNmhKUzh2RGhGQ25rRWRESUhMc1FPa0pINkFnOTBOU3Y5aHFPUk9oenlPOHNjK3ZDdEdMZnJhcllzZU82MTVkdDJIRGd3T0xGVzdaY09zcmZSL21hRDE0Yys1ZC9IL3ZVbGxFV2ozTGd3SVlOeTE1Ly9ib2RPeXFxM25YclJYWENna3J1QnpGN0prUWpkSVNPMEJGNklMUnY3ZGhwRDZFbmZSZ1psNUJkVTFPVDNiTnU2RWhpaVo2ejZlMDl2VzZya2pmK1h3TklMVTdENVJPM25nQlQxbGNpZElTTzBCRjZBSkkxbitNcEd3aDlwRFRUcy9kWTAxbXVZNmlXYzFHOHl4M0M3RnJUaDhpbktCR2h5aFNFanRBUk9rSVBRSS9tYzB5d3ZOQlgrZ2cvcjI0cFR0THZxT21iNHF0RDFPYkRJMWg4Tm00QnFsU2JXV1lJb1NOMGhCNHlRdDhvTnY3V2lrSnY5dU5WVjN5aGpudC9PVHRPUm9lYXpWT0hFakc0QndLeVBUaUtWUjY3SGFFamRJUWVNa0xmcFBrY2F5d3U5S1VCeHI0clR1ZzUxMXV3b0xRdFpHUWVYYmM2Q1gzck1hL2xjTVNwdlFITEVEcENSK2loSW5UdFMycTZMUzcwd0h1bjlKYnFxNkg4eU96ZUVCaG9QNTFSZ0x1OTBpSkFsVFZxRDM3TWpkQVJPa0lQRWFIbmk3MkFGaFI2dHd3WjllcTlTM2ZzWUdkeUVNczhQS2VacnJsdlRnbFFaWm5xbzZmMFJFZmx5ZnBQUFVKSDZBamQxa0tQMVh5T1ZSWVhlcmE4M0MweEpYb1hKQzNybys0Z0RIMXYyM2FjV1hQL25CQWc5SG9EaGovV0lIU0VqdEJ0TFhRcFNtZ2J0cURRaS8zWjZNMUhIMzFrOGgrN1d3MG96TmJ5enRUZ0dYNTNkWmQyMERNUHpDWUJRbmNZc0hJQW9TTjBoRzV6b1d2ZVhpZlA0a0tQRGZkdHBFZWZEUXNMZStyOVNUMnRpeldrUUFXdHhUMzJENVJyUzRqTWRlSnFXZVNLRVBweGhJN1FFVHBDRDBDWDFsSkVXVnpvVXBIdmNlNkx0bzhLUGV5TEwweHRDOVpxV0tIU0ZwdzVHVzVUbDJjbW5Ha25DNXdDK2tRSVBVNy9jaUowaEk3UWJTNzA3cUFYdXRUaDAraDNobzN6MVBRWWNxT2hCVXNmakd4SXR0TUkvRUJOWEV3Ui9YTEZZeksxMmg5a1o1TVJPa0pINkFnOUFEWEJMM1NwMEZkcW1Yc21oUDdzekcvcTBvMHVYR1YrMW5CQ3Q5VzEzdFVVVjV4QnQxd2wybmRNOEpqYVF1Z0lIYUVqZEM5b1h5TnJmYUZMUlJVK2RpcDVkVnpvWDVnOW5weHZUaEZURmpUMnQ3UlpMd3ErcTZiaFRPRktldVdhRUpGWnhxSC9XZ0tFanRBUnVzMkZYaGNLUXBmU1duejQ2dWNQWDNUSnc0L01XY0NXWVdJNVMvb0dqM1ltcEhhWkx2YnE4SnFFaU9PRGllU0tFVUdDQ0tGdlF1Z0lIYUVqZFA4MGhJVFFKV20xN0t6cXJtWUx6THFtTEFnLzY2aXRyUjhscWo1cWxMeFI5TnBSZFpTeFE0d2VhUFJ3dFJVeEh4NWpNWnBRSWtRSXZRR2hJM1NFanREOWt4TWlRcGVTdHNrMlhMSDVwYzJxZmR3SC8vMzRmNC96NjBuT1R1QXJsbXFHWDg4dzhRMmozK1QxQ05FcEVnamxzQWloaCt0ZVRJU08wQkU2UXJlSDBPK1ZpbXI4YXZ5OXA1NTZkWElCMnhxekM5dnd1Sm44ZXBNRUlta1ZJZlJhM2VNMUVUcENSK2cyRjNwL2lBajkzanRHLzZmZFQyTDM5OGJXcEc5L2RlS0hNNmFXMVJuK3VNbjBJR0doRjFTRTBCMVpDQjJoSTNTRXJ2Tkoya1BvVnowMC9uK0xmT1pvdTNoaUNkdkZFejhObVRrNTRIN2NkTnBLSkJCSHJ3aWg5eU4waEk3UUVUcENIK1cyc0MrUC8zL0I0UzYvUWc5N2RPTEg0NmFWZEtUMmNRdFF2UlVOaTBQSXVqWGRKOUVST2tKSDZBamREa0svLzVtd3F5Yi9NWGFqMXl3dWowNzRmUHZrb25SWHUwa2xQZlpyK2RhZGlZNGJpM3FybmFaK2h2R2ZIV01oY1dOUmNBcUlJdEpkSEEwaWhPN1ErNG9nZElTTzBHMHVkTTE3TmRmYVF1aFhob1ZkTy8xRFNyeTMxV3FUZVdDL09MVkgrakZUQ3ByN2F6LzZIaFgzbUszSEZyS3BYTVdXRnhWVlgrODRLMGZ0OVJoZEdKRkNoQjZEMEJFNlFrZm91cGJDQnFsZlI3a3BMT3laSjJkK0xCeVk3N3IzTHhudm9WOHk5WE9aR1VLYjN6OGYxYmlqZnN6Z2doZWZqNG85Z05jeHVqQXloQWk5QmFFamRJU08wQkc2ZE82b3EyK1k5WE9hbDA3NkkxOFlDM1JmT1AxenF2R0JZWWxuWjY4ZU96c3FjcDB6d2tYNXMzcFV1Z1JDU0JjaTlEeWRiMGlFSHZKQ0gwTG9DTjBHUXI5M3JQTjkwNXhmRlh2WnNlWG5WMXh4MmF3Zis0MHVabHI5bE10cjYvTU1TL09hNTFQcTFXUitGVVMwRUtQckhOZUIwRU5lNkdzUWVxZ0x2ZG9PUW45N1RPZ1B6ZjFkYTFkQTFYVVlXOHFTNmdtWlJ4bWZ1ejJxM3F2VHd5VVFRbzBRb1o5RTZBZ2RvU04wUC9RSWJjTldGZnB0NC9GdVg1Nzd5NlRVUUpxck1qWUphdkxqai8rM2dUMXp6NDU2clJlbjErRmlJWndXTSthdTc0Z0pRa2ZvQ04zbVF0ZTgyMXFGRFlSKy8wUUErMVVldjQ0OUdVaHlUWlVHbG5MZDQyZWozS1lTTlQvRVBrWUNBUlFLRWJyT3llSVFPa0pINktFdTlIQWJDUDNLQ2FGZk8yK01PeTZRNGhxTksrVFNXcE4xUHRGTjl3eXlYNCtOQlpBaVJ1anhDQjJoSTNTRTdwc1dyYVhZWlFPaDN6UWg5TmtMMTZhdXNRK3hmZit5OXlkV294czM2Tjd0dGdTZVNzOGpDYXdJcW9VSVhkOTFCd2dkb1NOMG13dGRjN1JPdHcyRWZ1NWtXdGNiNXYrclRxOVdXM2hOV05pZDR3SHY4VWFWTWNadEZmSWNjNHplSW9FRjJ0a0VrUWdkb1NOMGhPNjdYNmkxRkRYV0YvcTlrejczV0xnMndTa3ZTbnRoKzNpT21Ydkcvcm5RbURMMjlicXR3OXk1OUhZSk5CTWhSdWk2TGp0QTZBZ2RvZHRjNkcxYVM1RnRmYUcvUFNYMGg3ejh5eEl2a1hFTEovTzZ2emVXTU02WVhVcWEzSmFpZm5iR09GYWphMmRRak5BZFJRZ2RvU04waE82TGNLMmxTTEMrMEcrYkVycm53clZ4WXVldlhudDE4dU1YdVVaL09HVkVFVGU1TFViZXJ4bDBGNG16WG96UTlWeEhpTkFST2tLM3VkQTFwN0E2WlhtaDN6L3Q4M2tMMThaSm1wZGg1cDZ3Mlh1cEZobnd1Qzl6VzQ1WndYRWpDTm44b2JBSjZ2c1FPa0pINkFqZEI1cWpiOWRaWHVoWHpnajlXcThmV09xWkJmYVJxYzgvUEpibUpWUC9JZWVQM0Jaa1p0aDlBQjlyNXBRWW9ZdHA5UWdkb1NQMG9CUjZsTlpTckxHODBHK2FFYnFYaFd2ZUJyeGREOC9aSEQxQzd4TDJ1YXdvZEhmVWRPcTRab1NzbFE0eFBqOGJsWWJRRVRwQ1IraGVLZEI4anNXV0YvcTVNMEwzdG5CdGpBYlBMdm9YSno3KzFJVGZjM1V1WVlQYm11Uk5HVDBQSVdzbHZWWlFGMzBkUWtmb0NCMmhleVZKOHprMlcxM29zNmJRZlV5aVM1S3p6VU5sbHowNzNrT2YzRXMxWE45STkvVnV0OVdOWG95UnRTSm9FdDBScGRzMjlRZ2RvU04wZXd0OXBlWnpMTGU2ME8rZExmUTdmSHpvbU9jMCt2dFBQUk1XOXJCcmNxdVVIbDFMdU0xdGVhTkhJV1N0OUFzU3VxTUJvU04waEk3UXZhRjllV3lSMVlYK056bENsMDdNYzlrajc3MHc4OE1tSFF1WTRuSmIzK2gwMGJWU0xrcm85WWtJSGFFamRJVHVoV2JONTlobmRhRS9PVnZvYi92NlZJSC9WT3E5T3E3Y0tuVmJtYWdKb2Jzd3NrWmlvODRLTW5xTFpaL21DQjJoSTNRemhkNm8rUnhqclM3MFdYbGxmQWJGalUwKytPOG50K20yTFlZejJtMEhvK2VpWkkya2l1cWlPejVFNkFnZG9TUDArV2hOTVgxMjd1U3FKWVYrMVl6UHozM1NUMVVFMkJwZHI5WG9SOTBXWjJJOStpNk1ySkZJWVVLdmNpSjBoSTdRRWZvOHRvbHR3cFlVK21jUEJRcHluK2dwdC9uM21sNFpQWkt0TG5UMzJmR04wWjBvV1J1SndvVHVLRVhvQ0IyaEkzVHh3NEJ0MWhlNjlPV0gvT3kyTmtONUFLOE42MUs0WTI3ck14NFk5eEZLMWtpWE1LSFhGMW56YVk3UUVUcENOMVBvWlZvTGtXb0RvVXRQWG5WdVdOZ3p0OTBRNEdOMVBueDJ6NnRYak8yNzVvN1JvMnlkTmhCNkZHRnhJdmhJWEJkZGwwRjNoSTdRRWJxOWhhNDU4MnVDSFlRKzFrdi84cE1CUDlOWDdWVm5UNDIrRElUZGVkbm9QK21SQWJYTEJrS2YyS2lsVHdKTnRJb1R1a2U3UStnSUhhRWpkQUdKNGs3YlJPaXlHUFltczBjbjg3by82bmE3eEJzOTEyMEx4Z2JkY3lUUVJxOUFveDlINkFnZG9TUDBPUlJwUHNYR1lCSzYwMXQzZVdwejlHdEcrK2d1NFkvUjAvWVFlaFJqN2dJNEpWRG85YTBJSGFFamRJUSttOE9hVC9GSU1BbGRXdVJINkdFWGphMVVIeEo4eEV4N0NOM3RHRFY2R2tvMisvMTVGdFZKMW51YUkzU0VqdEJORkxyMk1KMlZRU1YwS2RWTFNOejBvcmQ3eG42TUU3b2V2YzhtUG5mbmpRcDlDQ1ZycEVxazBkdWNsbnVhSTNTRXJxL1FzeEM2UDVvMG4ySjZjQW05ZGI3S3FyODRKZlNIeDMvT0Zwa3pydGd1UWg5TEw1T0prVTEvZ1o1TmNpeENSK2loSmZRT2hPNlBhSzFsOE5pRnkvWkNsM3JtcTJ6aDlrbWhmMkhpNTh6MTRnNlhZQnVodS8vNzhWcU1ySkVSb1VKM05KVWdkSVFlVWtMWEVwWWMvRUpQMDN5R1hjRW05QlF2UzljZW5veHpmMnBxcHhaeG9YRmxianQxMFZOUXNrYmFCQnM5MWxwUGM0U08wUFVWZWlOQzk4TVI3VStVWUJPNnQ1VHVyb2NuK3VpUFR2K21aNnVZZ3lYcVlWNVh6YmFUNGJwMDBabEUxMHFrV0tFN2twMldlcG9qZElTdXI5QTNJblJkenpBdTZJVHVyUERpc3ZlK3NEM3MyWVd6ZnRGMVJNU3hLdnQxOEc3TmVEKzZNRnFITG5vcVJ0WkllcjFnbzdjbFdlbHBIc1JDTDBQb1ZoQjZxYW02czdyUXUwV1BnQVNCMEtYRFhtMVcvWWpIOXFvbk5UOUpDMDZkclJmdjg3TEpQdHNDSGJybzFSaFpLL0dDaGU3b2JiWFEwenlJaFI0dDhDWkE2S3FwUStoK09xUDFvcHRYTUFqOU01bmJuMFdmMERTQm1USmM5dXZIbzhSYnQzUHFBRTNpdStpL1JzaGF5UkF0OUxOUng2M3pOQTlpb2VjaGRBc0kvV3d5UXZkTm9mWWJxeS80aE81dDZacDNLbzZyWFpOZXVhRE9OYmEwTzArODBLZnZ1U0VkdXVpa2x0Rk1sME00OFZ1dDhqUVBZcUU3QkVZcklIVFZWQ0YwMy9Sb1BzRjZLUWlGTGpYSU5seDRvNXBtdnI2emF6S2RxZzVUNk5PWkZ6cDAyS05sRVVMV1NxUjRvVHVpQnhHNjdrSVh1RmdWb2F1bVZzTjdWYkFMdmNRbC9Pb0ZoOUNUQWdTVXZmbm9QZS8xVHY3elFFU2lRcHVmNlo3ZXd1eS85UlI2bGc3cDRrb1JzdVo1cmlnZGpPNm9TN1BFMDl5NlF0K2srY0NiRUxwV29TOFNjS2NYSVhSZmxJc1BVUWdPb1FmSTMvYnFOV09MMGg5K1llcm5wazF5aHp4TE1rNjN6WHpQcngvL3RjMkU3bzVBeUpxSjAwUG9EdmVaV0FzOHphMHI5QTdOQjQ1RDZGcUYzaUhnUnRld0VEM1loUzRnNEhaamNBcTlNdFdQMU81NVpuTDN0WmxsYk5YWk1RRTNDeTg1MWhnLzAvUHZmZStlTng5Ly9LemRoQjZIanpYVFY2K0wwUjNSeDB0TWY1b0hzOUFGTGtSSDZPcHBRZWkrQnBZRlBGaktnMVBvMG9qTGQ5cVdwNlkzYTFrNFp6cTk0Zmd4SDUya2d2WE42NXA2WjMzMmtZZEhPL2tYUGY1NHJkMkVubzJQdFJQdjBJbXFTQ2RDOTBHNzlpTW5JblNOUXM4U01SUlZpZEM5YzFwQTdhWUVxZEM5NVl1YllrYm8xN3p2S2Z2dWs2ZUxqK1N1VDB0M1NnWHA2WDFMQnhlZDZZOXY4M3c3dU96WnNjeHpUejMrdUlKbDZOVkg4eTBnOURaMHJKMmxEdDF3bnhwQjZGNVpvUDNJcHhHNlJxRVBpcmpITXhDNjk3WWxJRGhuM3RyTW9CRjZiTGRQcVMyY0ZucllxNnFzK1AxTHh2LzRZaVZDZDVWTFVyUWVRbmNseGlnb09wbGxSTkRrMEpITW9SU0VQaDhCNi85ZHNRaGRtOUNGdk1xZVJPaGU2ZGRldFdkVGcxYm8wa3FmZys1L3ZPaVpzTG5icnlsa2NvUDFoWThyeUN0VExPa2s5TkZIOExDQ3NqdlJzWFp5SGZxUzJabXJmRHJkbVJ2UkZjUkNGN0hQM1VhRXJrM29pU0x1N3FpdENOMEwrU0pDYzBxRFYralNHcDlTKzduSEJ1bVRubjkwNGNKSDM1UWp4WWt1L3IrL3AwRG80NnNKOUJLNjFDSmY2SW5vV0FDcERyMkpTdTM4VUc1UGZldXhSUkh4NGJWQ0F2TXNLL1FrRVpXYWhOQTFDVDFkeUwyOVR1VzVKZTBLWXFHWDdCSlJ0WVZCTFBRUzM2bFQzLy9DNUJ6NnoyZEdybDk5ZHZ4WFQvM2NzenYrMUNYYm43M28xZG16N2U5Zk0vN1I5K1VuaXF0SzAxWG9TVld5aGQ2S2pXM1FSWithVWU5T0dONlVrZTl0VkNXOWIzM3JoOGRQOUNmVWhJdGNGMjlkb2NlS09MM2t6eEM2RnFHWGlIbFpWWlZ6b1RKU3dJMnVyOUNyTjZtL2NKMUNxallwaUlVdUpmblpxL3pScHk0SnUrYXB5K1p0bVQ1bk1kdFlPUHVkazcrZXMxWGJ3dkhkV1ArUGZLRkhTcm9LWFRvcVcramwyTmp5cytqenFIZEhENFNIZDNkM3Q0V0hoNWRGUjd1ajlEcVNkWVV1Q1RubjB3aGRpOUNsUENGM1dieUtFMnNQRjNGa2ZZWHVjT3pLVlhuZENuVWFZQXNtb1VzWkx0bWVlMlFtVUc3N0xNMjc3NXo1L1h1enc5d2ZIdTNQMThvV2VsbXN6a0l2eUpSN29xdVJzUWhHSE1HSmhZWGVLK1FFenlCMExVSXZFM09iSFZWNldxMkNKcm4wRnJyRGthcEs2ZTFSWjBVY3ZDVzRoYTVnZTVQM1pzUWQ5bFRBWDQrSHVuLy9jZG1wM0NjNjZEb0tYWDdlOTBaa0xJUTZoRzZ3ME52RW5HRmNDVUpYTC9Sa1FVTk83Y3A2WnNJR3hQUVh1c1BSM2FGNHBYMldvRnhWUTBFdWRDbEhydWQ2bjUweDkwWHo0dG5IdWRNekw3cHNvZmVtNnk1MEtWUFp1d1ZvSkVYTUt6VkNOM3lXSTdrUG9hc1dlb3VvbU05QytjRVRtekxGM2Q5R0NIMjBGWjFRRkNWUUdWRXI2TUFqd1M3MEF0bDdpbDh4TStRK0svVDlrZTIrMTZ5UENsM20zaXpiSlAyRjNpanpQSWR4c1JnNkhRamRVS0VMZTl4R25ZZ05YcUdmMEZmb3AwUmRoTnBPZVR0WGovUzdSZDdmeGdqZDRhaHZhcGE5UUhpa1c5UlJYVkt3QzExS2I1TnQ5Q2wzWC9LSTF5UTBkL1o2L0VHVWJLRm5HQ0QwcmIwSTNWQ2N2UWpkVUtHdkVYZVd2V2Vjd1NyMGRmb0tmVWpjUlFnUHZHWHcrdUZ3d2ZlM1VVSWZlMjlzV1Mybm41N1lVeXZza0MzQkwzU3ByMHV1MFY5NGVDd0IzQmN2bnJzVS9kR0xKb0xjWC8yalc2M1FCMG9NRUxxMFRkNVpmb1NLQmRHTTBBMFYraUtoVDl2NHJGaUVybHpvV1NJdndxN0RmcTZCTXl1dVRQejliYURReDRZaDJ2ckwvV2JSY1hiVTFBbzhYbU1JQ0YwYUdaQ2ZkZVhORng3eGtvWm00UlVMSDYyZS8vdFJvY3ZiUGJWQk1rTG9IOG83UlRaRUYwWXFRamRTNksyQ1Q3VSsrWFJIL3J3SXVmVDFDdzRQUlhRV0ZpQjBiK1NMdlFaNUxVZTlaTHFLUFJhenJhMVdsL3ZiV0tHUFUxWjNJaXZSUzVoYyt1REdHc0g3TmlhR2d0Q2wxbWkzTHNnV2VxRWhRbytOUnVqR2tsaVAwQTBVZXF3ZWovajZxc3pzdXB5YzAvMDVDWFhaeVYzVjA1ZDBZQ1ZDOTBLQitJc1F0ZXRrZjJSelIvdUNCUjkySEI3cVQwaU8xdkgrTmtIb2svZlpycGFHMHVFMWpURXhNWkVSL1QwdHU2cDFlSFdRUWtMb2VobGR0dERUREJHNlZJZlFEU1lDb1Jzb2RHbkEwSnB3SlNGMEwxVForLzQyUytpR0VCY2lRcGRXRHBncDlGMlNNVUtQUWVnR1V4S08wQTBVZXJheFZYRUtvWnQvRVJDNkFnWkRSZWpTK2k0ZGhGNHZVK2luREJKNklrSTNtcVgxQ04wNG9hOHp0aW9xRUxvWE9oRzZWY2tyQ1JtaFN5bTdkT21objVYenVSaURoQzZWSVhTajZVVG94Z205dytEbkkwTDNRaUZDdHlobjY2VFFFYnEwdFVXUEhyb3NvYmNhSmZSNGhHNDBCWmtJM1RDaEp4bGJGVkVJM1F0OUNOMnFaSVdTMEtXU1VyTjY2RTZqaEw0R29SdE9maFJDTjByb0JrZkZJWFN2VkNOMGErSXVDQ21oUzFKenIzQ2hPMlI4YkZiNzBGbm81UWpkZUk0aWRNT0VmaEtobXkvMEZvUnVUWHFrRUJPNk5MTExES0UzR1NiMEZJUnVBZ2tJM1NpaEZ5TjA4NFUraE5DdHlXRElDVjJLalROQjZLY01FN3FzNzBmb2duRjJJWFNEaEo2STBNMFgrakdFYnFlVzZ3anVwKytDTHNPRkhtR2MwTHNSdWhuVDZIa0kzUmloUzEwSTNYU2hWN29RdWhYcERFbWhTMXY3WFFZTFBjWTRvY2NqZERQSXFrWG94Z2k5SDZHYkxuU3BEcUZia1BxVTBCUzZKTFVtQ3hKNjN1T1AxOHI0MkJIamhONlAwRTFoR0tFYkkvUU1xMVJGS0F0OUVVSzNJTmxTcUFwZGtqWjFHU24wVnRWQ0wxUXE5RWlFYmc1MUNOMFFvUnM2M0l2UWZReHkxaU4wNjlFZXdrS1hZb2VFSkhlWEovUSsxVUkvckZUb2hRamRwQnNxR2FFYklYUkRIN2tJM1FjMUNOMXkrTXhUN0FpTko3RHpUSmxSUWs4M1R1aTVDTjBrMHJzUXVoRkNYNHJRelJmNkpvUnVPV0pDWE9pam5hcVlUSzFDLzI5WlFpOHdUdWdqQ04wc1Vxb1F1Z0ZDTnpMT0hhSDc2ZzFGSVhTTDBWc1E4a0lmQzdHcGMra3ZkSmRrbk5DVEVMcHA1THNRdWdGQ1A0SFFUUmU2blVOR2dsVG9ReEpDSHlPdFdFdkkrNi9sQ0QzYVFLSEhJblR6T09aRzZQb0xQVDBLb1pzdTlGeUViaTFjVG9RK1BWWWFtZXBTTGZRb2F3bGRRdWdZUGJpRmJ1QkRGNkg3cEEyaDI2U0RIbnBDSDN0SWRlUzBLWlc1YTllMjRzTDBVb3NKUFJxaFkvVGdGbnBpTFVJM1hlaEhFYnFWcUNwQTZKNGtkYXhya3VkYlYxdkw2VTBySjZvUW9jTnNvMWNqZEwyRmJ0eHVYd2pkSjdHOUNOMUNORXNJM1N0OTVaR25zak9yZllpOEl2bmtSNDFIOG1lL0RTRjBtRTErRlVMWFcrajV0UWpkYktGTGtRamRPclJKQ04zL1F5cy9OK3R3OFpuaDRYV2xwWjNEdzBNeHpSL201cWQ3K3lSQ2g3a1JHZUVJWFdlaEc3WmZMVUlQd2k1NkVBcTl0aFdoaXdLaGc0ZndVaEc2emtKUHFVZm9aZ3RkYWtUb1Z1R1VoTkFST3VoRVFRSkMxMWZvVWlkQ04xM29CVjBJM1JyME9oRTZRZ2Y5T0ZPTDBIVVZlbXdaUWpkYjZOSUNoRzROQ2lXRWp0QkJSOXJ6RUxxZVFwY0dFYnJwUWpkdXRRRkM5MGVQaE5BUk91aEtuMzBUYjNUWlFlalNOb1J1dXRDVDNBamRmTXFjQ0IyaGc4N0VOdGhWNlBHMkVIcHNGMEkzVytoU00wSTNuZnFBdHhGQ1IraWduVUo3Wm8yckhiU0YwS1dSZW9SdXR0Q2xlSVJ1Tm8wU1FrZm9ZQUFwcVdmdDk3aHpGVXIyRUxvUnlVY1JlZ0NjRlFqZFhCb2toSTdRd1JnYWJiZHQ5TWsweVM1Q2wvb1J1dGxDbDlaSGhielFUWTEvVFM1QjZBaWRxMllVaWZicXBJZG55RGdueXdpOXNnbWhteTEwcWJBMjFJWGVhbUliTDB1WEVEcEM1Nm9aeDJyN3pLUzdHaXNsT3dsZGNpWWpkTE9GTGhXYmZkdDIxNXNxOU5xQ2tqaXpUcjIzVDBMb0NCMmhHMG5hTm52MFlhSkt0OG83SWVzSVhYSzJJWFN6aFM3Z2NGcHdOMHBWcGdwOTdCNHBOR2ZZdlRwZlF1Z0lIYUViek5KdTYrdTh2aUZKN3VsWVNPalMxamFFYnJiUXBWSVQ3OXVlTkVsS05WWG95V04vMXBkc1haOGpkSVFPWXVrb3M3ak9lL3JrbjR5VmhDNDVVeEc2MlVLWElzeTZielBIZHhsck1GWG9DUk4vZUNiSzZKbjBxa1NabHdlaEkzUVFTMEdqaFRlYnJNOUpVWEl1bGhLNlZIQVNvWnN0ZENuU2xGbWxxdVpKbDVvcTlJakp2OHczdHBOK3RrMzJrQnBDTjEzbzVRZzkySWhkNDdLbXp0M3IwcFNkaWJXRUxra25haEc2eVVLWGpoaS9lcTA2c21EeTRGbW1DbjNSOU44ZU43S0Z0emhsWHh5RWJyclFNeEI2OE9HTWpMYWV6c3NhblVyUHcycENsd1pkQ04xa29Vc3JEWjVVY3ErWnVXOFRUUlg2ckluc3JYSDFCcDErN1VZRjF3YWhJM1RRWmVEOWVKdWxscVhYTnBWWEtqK0xXTzBIemhCYnIwazFaeEc2dVVLWG5IVkc5czdYekg0TnJWUTJmUzFXNlBWeldsQmlreUhuNzJwWGNta1FPa0lIblJoc3Nzd2l0dXAxS2VyT0ljcDZLaXVPUXVqbUNuM3NXV1hVM0hsazdOd2poNXZZUS9lc3F0WlUvU3VnUmRra0dVSkg2S0FiZmFlcnJSQUlsMTFZb1BZTXRPOXpsaWE4VmxOYUVMckpRcGVTRE5tcVpkZWllYU5LZFNiMjBPZnZUWmlyYzNSYzNtR0Yxd1doSTNUUWtaTHllSk16WU85cVROZFEvbE9hUnd6MXFOVjJIZllKcWZKelBPM1RwZXQxdXIrMHJ5SnJVM25rRC9YZTA3WSt2c2pMWVRjcStnNi91dzkxS2kzUmtKY3ZhWTNYYnhpdXRrZngyekJDUitpZ0wxdUx1MDBiZWcrUFNOUlcrSHl0THR1bVM1MVdIcThTWFZYSmZnNm5PYVZOVklGT04xZVc1dk5PVUh2b2drWTlJNzJyTm5xWFdZYWliL0Y3OXhlS2VTdEx6TkhwbFgxWHEvS0xndEFST3VnLzlENlVYRys4elhlZFNOUmU5RWhOUlRnYmxhaFRsUllVQys2bFIvZzUyR3F0WDY1Yk15elFHbkZlcTJFeXdMbEdweG1sK2hhZmtXQUZTZzZaNnIvdUJwU1Z5dWUzT1dNeXhkZEIyeEUxbHdTaEkzUXdnclNqVFVibWw0cXFhVXdTVS9CbUxmMnc2a0VkcXpSTDVBVG1nTi9zOWhxM3prNk4xYTBTUnJRNXRiWlkwOUZqaTNVWWVFK084WGN0QnVVM280RUFrYUFqaW03dENuL2ozOGNheElZSmRoOVJkMEVRT2tJSGczQzI5N2NaTXZqZVZqb29jSWkzSU90VWFtYTRZcnJha2hPT08vV3QwY1JTUVYzRSt1d0F6LzZzcHJKb2xRd2t4NVRvV0FkcHBXMXFTeFpkVVZlaytmaUQ4VUlIbnpJM0JscVBzVExWZnlPcXo0c2EvMDlGYWJyQXV1dnVESEF2bDdTZkZMUnR5OW1vaEdOcXJ3WkNSK2hnWkVlOXVhZENWNm1YSld4S0M2SDZyQnpzMGR3MWN0VWRUK2ZPVk0vV1lrRkRKZldwOG9hVll2dlMwbWNUYTVHS0tEaVNJQ0NzWUZla2hyc1JvU04wTVBvQldONlpxc2NlalBXWnA1cVRRcTg2SzNNL1VoKzA1bW9aV3NrZHFmMDlOYVpHYTJUWVFFUEgxaUNvaWRiT2JnMGpGclc3aHZzMEhSNmhJM1F3Zy96bTAwM2kwc1BXdC9WRXRoYUVibTJtRmNhMTFTdXVzNXpWK2R5SW9vZ2RQTDFMcmNxaTQyUDZncWNtbk8ybms5WEV5MFRYSGRZOFVvVFFFVHFZMTFmUGlDbk43dExVdDZtdnlGN1hQRkpBWFVvRnJjVTV5ZktHUEt1VDQ0NGZvODdFUzcxb0tMNUxtZFh6a2tzTGczQllxV1FrWnRzdStjTndVYnNhTnFXSU9DNUNSK2hnTmlrWmh6Zm1OTFc1bER3S2Ezc3pXL29iMnhNL28vcm1kbytXTnAvcHIwdnQ4anF6N2k1TFBobXhhZWxXcWtuUEY2dWx6UkYxbWIwQkkwWHkydUlqRmlVR2Q4TnVqenhWMCtVdnlLTytLcmxudUVOY0xTQjBoQTZXSVgxOVJrZmp4bzl5NnBxUzI4SUhvbDFSOWJPRGQ2dXJ3ak5UVzNyNk54NzljR2xTQ2JVVmFQZ2paWDNyZ282T2pzTXhvNnp1V0ZEVUYwdWxHT2oxdnR6Q3hvaFRKN05IYitXcWQ5MlRvZWZWQTIzZDJUMmxrWVd0SVJTNkdadWZXMWk4Y2QycGhMcW1DZXJxR2tvamhnNjNyeFErTm9IUUVUb0FBQVFCQ0IyaEF3QUFRa2ZvQ0IwQUFCQTZRa2ZvQUFDQTBCRTZRZ2NBQUlTTzBBRUFBS0VqZElRT0FBQUlIYUVqZEFBQVFPZ0lIYUVEQUFCQ3Q1VFEvOSszMzc3ampwdEcvL1AvSUhRQUFFRG90aFg2RjhJbWVWaWUwTy85OHYwSUhRQUFFTHJ1UXIvL2J6ZGNlZFhiTnoxOTIvZjFFUHIzUnovNXpMa1BYZnYwVFc5ZmhkQUJBQUNoNnlQMDd6LzB6SlNndzNRVHVvSURJSFFBQUlRT2FvU3V6TGNJSFFBQUVEcENSK2dBQUlEUUVUb0FBQ0IwaEc0UG9TOTg2Tm83cnZ6Qi9WdzdBQUNFRHFNOCtiY3I3N2oyM0lXMkU3cHI0Y1FuSDdyMjdTdS8vQUhYRVFBQW9ZZXd5Mzl3MVUyVG9lc0xYZmJyb2M4RTNZYzljOXROVjkzN0pGY1VBQUNoaDZUTFp3blJ2ajMwV2R4MjA1VllIUUFBb1ljTVg3N3lwdHM4WFdqekh2cnN2dm9kTjN5WmF3d0FnTkNEdm1OKzdibmVOQmdVUGZScEhucjZxbnVaVmdjQVFPakJLdk8zYjN2R2x3S0Rwb2MrODQ1eTdkcy9RT29BQUFnOWhHUWVmRDMwMlZKL2txc1BBSURRZzRON3I3cnRtVURxQzc0ZStvelVyMkpPSFFBQW9kdWQrNjk4K2x3NTFndk9IdnIwblBwTk41Q0FCZ0FBb2R1M2EvNzJRM0tWRjd3OTlPazFiVmY5alRzQ0FBQ2gyNDRuYjdqcFhQbTJDL0llK2xSSC9RN0M1QUFBRUxxZHVQL0thNVYxWDBPZ2h6N0J1VS9mOENSdEF3QUFvUWVuelVPbGh6NTVyazlmaWRNQkFCQjZFTm84bEhyb1UwNm5udzRBZ05DdHk1TTNQSzFTY3FIVVE1ODg0NXQrUUJzQkFFRG9WdVRlTzg1Vjc3ZlE2cUZQenFlL3pRSjFBQUNFYmpHK2ZOVkRtdnFySWRkRG4xckx4dnAwQUFDRWJoMSs4TFRXM21vbzl0QW5oOTd2cGEwQUFDQjBLM0MvdHM1NVNQZlFKN3JwUkwwREFDQjAwL25iVFVJNnF2WVR1dnVlWjBRWlBleVpPNWhOQndCQTZHWnl3N1dDbEhaUFlJRythYVRRSHduODhjdkNSUEkwUWU4QUFBamRKSjY4OGlGaFBuczBzRURmTjFMbzd3ZisrQiszQ3pWNjJHMVg3cWZWQUFBZ2RPTjFmdFc1QW0xMldXQ0IvdHhJb2Y5Y3h1Y3ZDaFBNUTB5bUF3QWdkSU81WDZqT1pmV0lMek5TNkRKZU1Od1hQeE9HMGdFQUVMcXRlK2R2aTlWNTJMTXkvUG1lZ1VMZkxtTUt3SDFQbUE0OGRCVktCd0JBNkFicFhIRHZmSlE3WmZoejRYWURlK2dMODJSOGZudVlMa3Eva3NZREFJRFFEZUNHaDhSTDdPTEErc3g3MWNnZStxdUt2bDh3dHhIeERnQ0EwUFhtQjdmcG9UQTVJOXdQR3ptSEx1c3ZGb2JweGJWL293RUJBQ0IwSGJuL0psMzhkYzBmWmVqelRpT0ZmcWVzUDdoR042TS9jOGVUTkNFQUFJU3VFeCtJbnp5ZjRDa1o5blE5YTZUUXI1SDFGdytINmNlNU45Q0dBQUFRdWk3Y2U1dGU4cEl6NGo1N0dicitRdDh1WjkyYTY3SXdQYm1XZkxBQUFBaGRQRS9lb1p1NUxuRXBESExYWCtoeWtzdDdUQVBvTU81KzFRZTBJd0FBaEM2NGUvNlFidDdhZm9VY2R6NWxiQS85S1ZsLzhsNll2dHhHSngwQUFLR0w1SU8zbjlIUFdwZjBLcDFDTjZDSC9xekxiZWJLdGVsT09vdlNBUUFRdWppK2ZKdWUwcEkxdXYxb21MRkNseld2NzNiL2ZMdk9SZzk3K243YUVnQUFRaGZERGVmcWFhdzc1UVdVYnpkWTZQTCt4bjJ4M2tJUGUraGVHaE1BQUVJWHdWVzYrdXJaRjJUSjlsbWplK2pQeWp2R0h5L1IzZWdNdXdNQUlIUUJQUG0wdnJxU0YwN3VrWlJOb2RBdlZpRjBtUVZ6WDNhTjdrWVB1NFBtQkFDQTBEVnkvMjM2dWtxZWExMFhHUzcwWnk2U0Z4Ym52a0ovb1lkZCt5UU5DZ0FBb1d2aHl3L3BhNnFuNUZuem5tZU03NkhMMm5GdGZIci9HZjJOZmh1aGNRQUFDRjBEOTU2cnI2ZSs4RWQ1SFhUUGlXcGRoUDZJeC9MNFMyUjIwYXUvWUVBZi9TRldwQU1BSUhUTCt2eXBQNm9jMWRaRjZPOTdIdVVLZWFWemZ4K2pBd0FnOUZEMitjVXloZm5DTllZSS9ZVjVtOEM5NExaU0g1MVJkd0FBaEs2S0wrdnI4MmZ2a2FsTEwrbllkQkg2eitmUENNZ3RvZXRpakE0QWdOQXR5djM2eHNOOTRYMjV0bncxTE15Y0hucFkyS3R5eStoZStLd0JrWEZQMHF3QUFCQzZVcDdVZGIzYUpmZTQ1S3J5MGUwR0NmMTlML3ZHUENyYjZDL2NxYi9SYjZKWkFRQWdkS1hjb2Vkbyt4Vzlza1g1YzI5ZFgzbEN2MGlaME4vMFZ0S2Z5eTVvM2tMOWs4WmRSYnNDQUVEb3lyaFN4OTc1cTk5M3krLzRlcldrTGtML3ZyY2pmZkVGK1dYOTR4VjZLLzJaSDlDd0FBQVF1aEx1MXkxWnlwM3lCOXQ5K2x5bTBDOVJ1TkdLOTljUEJVWjN1eGJxUFBCT1lCd0FBRUpYeExWNnJUeS96SzJFeTc0WXBrSG96MDdOdmo4bDcyamVEL1pGWlVXK1p6dlQ2QUFBQ04wcTZEVGdmczA5aXR6b2Z0Ulg2TGlzaERSL25IbU5jQ3Nib3ZjbzlhT0tDdjJldnZIdURMb0RBQ0IwMmR5dnp3cjBaeTlUTXRydWRsM3NzN09yY0JtYXZDM1gzYjdTdzJ5L1dGRzUzOU4xLzdXSGFGb0FBQWhkTG0vcjR5SmwvZk9mKzA2LzlxdzhzYzZNbXNzN291L3NNSGNxbVVqUFc2aHJGNTNkMFFFQUVMcmNEcm8rRVhGUEtlcWVYK0dubjN1SjBqM1VxK1dsalBkOTN0ZGNvYVNUL2dVOTU5RWYrb0RHQlFDQTBNM3NvTCtuWlBiOEluL2ZkSkc4YlUxbi9rQmVYTnVqL2hhTVhTUi9KajN2UGJyb0FBQUkzWHcrMEdrR1hjRXNkSUROVHVUbFdKKzFnbXloMmxSeGM0NHErNDNFOVkrNlpvQ2xjUUVBSUhRNTNLQ1BoeTZTYThOSEE2N2xscld1L1BzejQ5N1B5TnpYTFZCOCtwMXllK24vbjY1ZDlML1J1Z0FBRUxvTW50WXBRWndzRlQ2eThIOEhub0NXTmFIOXFPSmp1NThLZkJKWHZDa25pYXl1Y2U1aGI5TzZBQUFRZW1BKzB5bEozRE9CMDZLL2VjKy8vTmR2ZnZPOXJ3WlMrajFLWTlhM3k0dFN2eUxBY2JkLzlWOS84MS8vY3MrYldyK0hsV3NBQUFoZGYzNmcyNGFwZnZ2VnJzc1cvdk9vemNjSnBIUlpPNi9PU1JvcmJ4TDlzZ0E2LzgrSjR2M1hQeS8wdTZMKzBTL3FuTktkL0s4QUFBZzlNRmZwNXFHbmZIVnQzMy92aW4vNWo5L001bCsvcUhYd2ZxNmNaYWFXOGJPNXlyOS84WHV6Qy9nZi8zTEZlKy83MktMbC8rcTk2ZG9OTkM4QUFJUWVrS2YxRTlHekY3ODNKMm5ybSs5ZmRzOFYvL09mNTdwOGt2OXhqYmFZT0k4c01mTEczSDJubHZuSGYvVlN4di80NS85NXhUMlh2VEQ3UGVYTmhmL3dQM1RmUlpWSmRBQUFoQjZZaC9SVTBUOSs3ei8rN2QvK1paUi8rN2QvK0lmeDRldmYrT0kvdityclMrVEVtdmQ2Ukt6TGkzUDN0WUI4K3ovNUt1VjQrZi96SC81aDZxeis5Mi8rNzcvckx2U25hVjRBQUFnOUlPZnE2cUpyL3VsNy8va2JtZmpvcEY4aUo4YmRNLzNxc3dxM1VBL2NQWi9ELy9wZmsyOGgvL2xQWWZyRFNuUUFBSVFlR0wxdE5CWXFMcFB2ZVUzUThxcWN4ZXllcytIYlg1VWxkSzlwMkwvNkc5a0YvdW8xQnZpY01IY0FBSVFlbUNjTkVOSlh2eWZYa0Y2RzNaOTlVNVdZWmYyWnUzcCtXTnoyL3l0YjUxLzg5ekJET0pmbUJRQ0EwSzBnZEQ5ejBwNFQ2ZjgvZTNmTW0wWVNCbUJZTk40cU5YS0VHMU5ZL2dGSXNBMUlGQ2dkQmVVMlFaY0NJU1FhZEhIRFNpeENpMHlmSm5ZVXVYQ1J4azJvb3VoYzdFbitCUzd5RzVCT0tIS0JLQTV5eWRtT2JmYWJCV1lIL0Q3MUpUN3Bidlg2bTVtZGZiaUNuWkhjRXZld3k4TGI0aDc4SnBCUGlYLzUwSlJ6Z2c0QUJGMUNUNVBTMG5YMzM0ditSK1RUNnJLcjJIKzdkemJmV0c3RG55VjNBQ0RvTWJIMFJLbWRpbFQwcE9SU21mTkg3NlhaRlgxRTlUd2ZwZWRhenNKeEtBNEFDTHFDbHE0c1ZTTHNvL2NsSDBKOS84UzNWMStLdm1sZXUzUDFiVnZhODZUT25pY0tQRjRBUU5CRGVRblRpbjVieTczRFphNkg4VVYzd0IvYzNzVCtRYmlLRUtTMTlqeFI1ZkVDQUlJZWFxZ3ZUSlZBclpjdlJDZlZhMC9mVkNmNmZlQTYwMWI3alVOM3p4TlpIaThBSU9paEJockxKQ3htNDBkaDkycXlMNndzT0oyV0ZOMEErK3JvdjBQeVNVTjduc2p4ZUFFQVFRL2wraHJUbEpJZmpQdnptNmpuNXd1M3MvZEVIMnE3L2paZnRjOEhxanNDSEhJSEFJSnVrSUxHTnVXRlY4eWs4N0lQb0Y2LzIxdjhVZlpkV2RHdmovckNYemIwbm05bkN4MEFDTHBZVm1lY2tySXh1Sk41Slp2UDk4SitvT3hjM2ZYMW9mQ0N1SWIybmlmcVBGMEFRTkFGWEN0aDNEYjZhMkdGKzRKdnVCN0ovcTZNYkVEUEoxaHhCd0NDYnFhcXpqekpkcXBsWTNYdFJuSStiU3BidlQvWWozalovTHJaUEZ3QVFOQkZjanFQeFltK1pTWWEwQzgvamk4NmVjblBlL05wVlNONkRBdnVsc3ZEQlFBRTNjQVJQU0c0alcxSHNJTitmakthWDZrZWVvbjgvTy9icnduK3dxOG1ubkJuUUFjQWdpN1gxRHFpaDcvdVBRcGZjVC9ZdVJHdGdmODhWai8rRW43YS9aMlJBM3FMQVIwQUNMcVliZGlJSHJwRS92WGs5ZzIzeFJ2b3YvNnhtOHhseU4vNWwrQnRPdjFCTC9Gb0FRQkJGN3R5ek5wRmZ4dXkydjdsSXBCTnpiZXJBYVBSNTlyN0paZmNZeGpRUFo0c0FDRG9DaVk2Rjkzenl4MXlQejhWSHp4djM3M0habnl4djNPNTFLRTQvVWZjclNaUEZnQVFkQlZhRjkzRDduQVpMWGpSN09qTmcxZkQyK0tYM2tlZlB6NjVsMzRjL3RwYW5nVjNBQ0RvcHZNMFppcjB1cmlUSjc1ay90Zk8vdWp4bTkvRlN3SGpOMGVQaittbm9UMmZhdS81a09jS0FBaTZJcmVscjFNZlF0dVplYVM0YjJ1djUrdm1DcmUzUFhFcjNlZlRydythZnZEUndIZldDbGM4VndCQTBGWGxOTjRBRy80ZGxNejlHZjN5TUhPeStPTnNhbnYxTjE5cTk5YmVqMDRFTDZIclhuRnZzWUVPQUFROWdycStnM0hoNTl6SCs3V2ZSOTJQejJ1WjE2UEZGNnkzbzF3YnYzOWFPencrUHY1MFhudTVWelR3bGppTHo2QURBRUdQWktDdDZPbndmSTRiaWIzZEZ5OTJVNUZ2V0crSDNocmZtZjB1OEVIOHlSak4zMDIxSmp4VUFFRFFveW5wS25wYlBoQ25MNklPejVLcCsxZWxCVUVmNjcxVnh1S2pxUUJBME0wdmVrTWU2WWFreStsb1ArUC9QMWd4YlF1ZCtSd0FDUG95QnBwT3hna0Myb2t3YUNzdTY5LysxaUQ0OXdtMG5vZGoveHdBQ1BwU0pucmVYcXNFNHFDTHd0eUo5Q051ZnhHb21IVW16dUY4T3dBUTlDVTF0VnpyWGxSb2RDZmFtcnZTVXIwZzZDbDlQZmRjbmljQUlPakxjc3RtTGJtTDlyY2Zycm1MQnZzZ1lXTFF1UjhPQUFqNlNtUjlvNEtlakhUT1hiVDFQalV3NkJiM3R3TUFRVitSZXN1a29PY2xhWDV3QmwzdC9YVnpndTV3SEE0QUNQcktySDNaWGVrUW1tUTNQRWlxditsK0VhU05DL3JRNVZFQ0FJSytRaVhMbktCSDJVUlgyMEkzSmVpdEFROFNBQkQwMVdwNnhnUmR0QjJlaXJDRm5qSXM2RlhHY3dBZzZKczFwQ3NGWFRSdFg5ei9BVk8xSytCTkNEcmpPUUFROVBWd3E3NFJRVmZjRDQreTd4Ny94VEsrelhnT0FBUjlYU2FPQ1VHWDNSR1RWRDRUZCtka2ZPeEI5empjRGdBRWZaMnlMUU9DcnY0SlZka3FmZHVVb0R1OGV3NEFCSDNOWE51S1BlanF4OXhWTDZPSk5laFc5b3JuQndBSSt0bzExN0NWcmhaUTlXUHVxbjhpeHFDemVRNEFCRjJYWE5tUE5lanBzZXJscjZvemZXeEI5NGQ4V0EwQUNMckdwSzk0U2xjTXV2SjdhNHB2cmNVVmRISU9BQVI5czVPdUZsRDEyOXhWejhYSEVuU0xuQU1BUVk4ajZVTXJwcUNydjRnZUtINURQWWFnV3pZNUJ3Q0NIZy9YYnNVUzlNU0ZZcCtWLzREMm9EdlpmM2htQUlDZ3g2Zmt4QkgwamlEUDQzVDBlMlUwQjkwdmNNc3JBQkQwdUUxV3NabStocURmM1JMUG14eDBhOGl0Y0FCQTBFM2daaDBEZ3g0VU55TG9oWkxMd3dJQUJOMFU5YkpsOG9TZURzd011bFZsT0FjQWdtN1ltRjRxK05xQ0hpaE82R2tUSjNUZkszSEZLd0FRZEFNMWJjZWtVKzVKbzRQdVpIbExEUUFJdXJFbXc1WXBRVGQ1UW5kc2x0b0JnS0J2WTlNRkFVMnBUdWltQnAyYUF3QkIzOXFtYjJEUU85UWNBQWo2OXN2WlNtZmtqQWg2ZXMxQjl6MzJ6UUdBb0c4ZU55dC9sMjM3ZzI2VmVlRWNBQWo2cHJxcUR4MmZvUHNGZThML0RBQkEwRGRiczFSdVBlZWd0NnFNNWdCQTBMZEVMbXoxZlV1RDNpcXphdzRBQlAwNVJYMExnMDdNQVlDZ2IzUFVIOTlUTnkzb3hhV0M3anZWRWpFSEFJSyszZHlCWGJDV0MzcmI0S0JibmoxdythOE1BQVQ5dVl6cVZlZHUxYWZiRUhTck1DeHhiUXdBRVBUblhQVk5Eem90QndDQy90eXJYcks5bHIvdW9JL1hGblMvVmJiWk1BY0FnbzY1disxdXI5aFlYOUNUSzUvUWcxVEZiM25EN0lSUG1nTUFRY2Q5elZuV2s5TzFCRDFZWGRCbktVLzJuR0VwUjhvQmdLQmpnY0haYkZ5ZmZsODI2RUZseFJQNnZPVDViams3WUlFZEFBZzZ4Q2EyMStzVlU5OGpUK2lWVlUzb2pXbXgzM09xcGJyTGZ4VUFJT2lJS0plZFRlejk0clRpTHhIMEtCTjZZemFSOTd2ejQrdUVIQUFJT2xhbldTOWxoOVZ5d2JHQzlVM29Wc3NwbEt2ZW1jM0tPZ0NBb0srOTdRUDd6T3YyZXYxa3NUSk5OWUpsSnZST2Fqb2J4WHZkcmoyb054bkdBUUFFUFQ1dWJwQzFoMmVlMSszT01qL1Q3eWQ3NVpuQ0Q3MVp0aHVOVkdvNm5SYUx5ZVQ4SCtoMnZiTmh0alJoRGdjQUVIUUFBQWc2QUFBZzZBQUFnS0FEQUFDQ0RnQUFRUWNBQUFRZEFBQVFkQUFBUU5BQkFDRG9BQUNBb0FNQUFJSU9BQUFJT2dBQXo4Ky9BZ3dBUzgxUS9OWDhtSHNBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2dpdGh1Yi5wbmdcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFnQUFBQUlBQ0FZQUFBRDBlTlQ2QUFBQUNYQklXWE1BQUE3RUFBQU94QUdWS3c0YkFBQWdBRWxFUVZSNDJ1eTlkM2hrNTMzZiszblBtWXFPM2NYMkpiaGNkdTFLbENoS3RCb2xXZFdTVld4NUtUdnhkWkxIaWVPVzRqVGZKTmMzdVkrZGNtK2UySEVzTzQ1ang3SHMySVFrUzFTaEpJcVVSSWxOWXBGSWtLSll0bUFic0FYQUFwZys1NXozL2pHRHJXZ0R6Sms1WitiN2VXeHhkeFo0NS8yOTdmZDlmMjhESVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFRZ2doaEJCQ0NDR0VFRUlJSVlRUVFnZ2hoQkJDQ0NHRUVFSUlJWVFRUWdnaGhCQkNDQ0dFRUVJSUlZUVFJa0lZRllFUThlSEEyRVFTU0RjakxXdkJORzhFc0VCNS9PQ29wMW9TUWdKQUNOR1lZODhzNzZ3dHB1YXQveEh3L3pSSEFGeElzeG1jQWY0dDhNbFYwaTJOSHh5dHFzYUZrQUFRUWs2K3hpOEQvMjY1UG1tdHRhYUozcm8rWmJjbWhERmdsYnorUytEM0pBNkVrQUFRb3VQWWY4L1JwREVtdThRLy9RTHdIOWZUNzBJUkFNMk5BRFFqci84YytNTWxQaTlLR0FnaEFTQkUxR2IxcVN0bjlkYmFuemZHL0tkbTlxOXdCQURXbUpaSEFOYkRQN1hXL3RFVlNaYkdENDVXMUFLRmtBQVFvaFhPUGduMFhQSHgzd2IrODZWOUthVFplZ2hMQUpZUS9IK3I3UDgxNEUrV2lCUklGQWdoQVNCRVUyYjNsNGJ5ZnhiNGJTQVJBUWNZeVRUYm1GY0wvR1BnVHlVSWhKQUFFR0k5RHYvU0dmN2ZBSDVuTlljZlh3SFExR09BVWJQZkF2OFErT1FsbnhVa0NJU1FBQkJpS2FmLzA4RHZOdXJ3WXlzQXNOYlFNUkdBdFFpQ1h3WCs0cElrQzgvZGZhMDJGd29KQUNHNnlPSDMxajBBeHBpZkJqN1JaR2ZWOU4zMW9lell0K0dNQURFUlFKUFcybjltakxtdi92ZThvZ05DQWtDSURuYjZ3RUZxNTlBVEhiWUdIb2swWTJxL3BYWVB3MTlKREFnSkFDRTZ3K24zWGVMMGYvL0s5dDcxRGpDa0FTQkdleUNXT3diNWk4QlkvYzg1aVFFaEFTQkV2SnoreDREL3RsSWIxd3hZOXE4aHpiOFBmRXBpUUVnQUNCRk5wOTlmLyt0UFVMdEpiazN0V2c2d28wOEJoSkhtTHdDZnFmOTVRV0pBU0FBSTBYcW5uNnpQOUIzZ0kvV1pmc003OTdVRTBGV25BSnFacHEyTGdiK1dHQkFTQUVLMGJyWS9BTHlUMm9VOE82UG1WT296NjZaZnNSdXZDRUJzN0c5R1ByMjZHUGc4TUM4aElDUUFoR2l5MDY4N3F3OEQveVBLVHFVTEhhRHN2OGpQQS9kYWF6MWpURzc4NEtpbkhpd2tBSVJva1AzM0hFMEJnOEFIZ0Q4QzNCWGFzRjI1ZWR2MTlnMjd4S2NHdTJTQ1puMWZ0R29lbDB1MzBjOGJMcjAxNXRHc3Q0Q2JPNUxWeFlHMTdjNkxBYjRQL0d2Z2NXQmVsdzBKQ1FBaFZwL3RKNm1GK0IzZ2cxenkySXQyd2N2K21MMkdDSENhMm5YRVh3ZEsxSzRpRHRUVGhRU0FFQmNkLytKcy95N2d2N0RFMnI0Y29PeVBzZjBGNEI3Z0Q0Q1hxQjBuOU5YemhRU0E2R2JIbjY0Ny92Y0JmOHdLTy9ubEFIVUtvQVBxM3djZUFQNERNRTV0MDZDV0I0UUVnT2c2eHo5VWQvei9jeTN0VUFKQTluZVEvUlk0RFB3VDRCRjBla0JJQUlndWMveC9LZ2NvKzJVL1U5UmVLWHdJeUFHbDhZT2pWcU9Ga0FBUW5lVDRoNEgzQVA5cmZZTnE4OCtzaCtnQXduZ05VRXNBblMyQXBxanRmL2tzY0J3b1NnZ0lDUURSQ1k3LzNjQ2Z5UUhJZnRtL0tnWGdQMUxiTkNnaElDUUFSTHpZZjgvUnRERm1FL0N1alRwK09VRFozNlgyWHlZRXJMWEY1KzYrVmtKQVNBQ0lTTS80TjFscmY5UVk4OG11ZFFBaGhOYmprcVlFUU5QVExRRC93VnA3anpIbXFEWUxDZ2tBRVVYSHY1bmFIZjJmbEFPUS9iSy82WG1kTk1iOENyVlRBN01TQWtJQ1FFVEY4YjhEK0hNNUFOa3YrMFBQNnhUd3k4QzNnRG5kSXlBa0FFU3JIWDhLMkZSMy9IL0dGUmY0eE9YbE9wMEMwQkpBVEFXUUJaN2k0bnNEdWxsUVNBQ0lsczM2M3cvOEhyQkxEa0QyeS82MjVUV29DL0RmQjM1QTdhMEJiUlFVRWdBaUZNYy9BcndOK0FzNUFOa3YreU9UMXdyd1c5Uk9EQnpSL2dBaEFTQmE3dmpsQUdKbXY1WUFPcTMrSjZudEQxamNLS2o5QVVJQ1FHekkrWDhVK0NRclBOUWpCeUQ3Wlgrazh2b2s4SytBUjRHOGxnV0VCSUJvMVBGdkJkNEMvRzg1QU5uZm1mWmpqYUZUN2E4QXZ3bDhDamlzWlFFaEFTQldjL3dwWUF0dzEzb2NmOGdEWUN4MjFzZktBV29Kb0J2cWZ4TDRKV3FQRGMzcnRJQ1FBQkRMemZyZlIyMTMvKzV1bUsyRjV3RGlrVmZaM3pVQzBGSjdmZk1QZ0dmSEQ0NldOZUlKQ1FDeE9Pc2ZBZDRLL0tWbWdMSmY5bmRzWHZQQTN3YStTVzJUb0tjUlVBSkFkQ24xUjN2ZUMzeGlvN04rT1lBWTJ0LzFTd0FkdlFkZ0piNU03WDJCN3p4Mzk3V0tCa2dBaUM1ei9DbHFtL3plM0t4WmY4VGF0TzJndjNmejJHUWJxTnRMYjhsVE9hOU9BZmhiMVBZR3pENTM5N1dLQmtnQWlFNm52dGIvWHVBVDF0cGRDZ0hMZnRuZjFmWi9CZmdQd0hlME4wQUNRSFN1NDc5MDF2OVh0YWxTckVMQU9nWFE5Q1dBY0FZQUxRSEViZ2tvWDQ4R2ZKM2FBME02S1NBQklEcHgxczhsYS8yYUFjbCsyUy83TC9ub1Q3aDRVa0QzQmtnQWlBNXcvaG5nUS9WWnY0bnJBSWpGRXB0amdLRkVLNXFlWmxnaEFBbUFXTnMvQ2Z4aVBScVEweTJDRWdBaW5vNC9CV3dIN3FUMlNNaFNQbFVYd2VnVWdPcGY5WDhsQWZCL1U3c003SmlPQzBvQWlQak4rdDlON1puUTNSb0FaZi9TYVJLQysxZjlkNUQ5WDBZYkJDVUFST3ljLzRlV20vVnJBSlQ5c2wvMk41Qm1Idmc1NEd2QWdwWUVKQUJFTkIxL0N0Z0J2SEV0emg5MENrQWg0S1p2cTVBQW9DT1hnQ3p3RzlUdURKblFrb0FFZ0lqZXJIL1ZrTDhHUU5sL2VacGRmZ3hPN2IvUk5PK2p0aVR3WFMwSlNBQ0k2RGovSHdmR05BQkd4djVZUkN0Q09WbWcrdTkwKzJlQnYwUHRsSUNXQkNRQVJKc2Nmd3JZQ2R5eEh1Y1BjVnNDaU5OcmdMRzVDTWdhRkFIbzN2cGZkLy8zZ0g4RC9EbHdRaGNIU1FDSTFzLzYzMFh0MG81MVArS2pHWERYendBVkFWQUVZQ05wL2pHMTU4T2ZIejg0V3RYSUxBRWdXdVA4UDBEdFlwK0VCa0RaSDZXb2l1enZ1dmIvQlBEcndDUGFGeUFCSU1KMy9oK2tGdkxmY04zcEZFQ1h6NEIxQ2tCTEFNM3AvNVBBTHdCZkd6ODRXdEpJTFFFZ21zeitlNDVtakRIcjJ1eW5BVkQydDFJQnFQNjcwbjRQK0duZ2E5YmErZWZ1dmxhYkF5VUFSQk5tL1NsZ3Q3WDJkbVBNV0lRSEFEbUErTm12UFFCcS84MU0wd0wvbDdYMno0MHgyaHdvQVNDYTRQemZDZnlSdGV4cStpNTRuUUlJeVFIRUk2L2huUUtJaWYyeDJnTVFRcG1HMS8vL2h6SG1kNEVYZEdtUUJJQlluL08vN0hJZkhZTUx4ZjZRWnNDeGNZQWh2UVVnQWFCanNPYkx3RzhCVCtwcFlRa0EwYmp6djJ5em4wS2dzbC8yeS82WTJmOFM4S3ZBUXpvaElBRWcxdW44UXhzQWRBcWcyeThDQ21VQWtBUFVjOUNYNVBVVUYwOElTQVJJQUlqbDJIL1AwUXp3UVlQNTFHSUhiVjB6c012OHhXQnJmNzNzODR0TngxN3hlVXZicmwwNS8rWVNWN2RVL20wTDgzblY5MTN5T1N2azM3YXdQSTFkNHZ2cW43TmsvaTlwSHkwcVdMTmttMXQwWkV2MG1SWHNDcjF3RytnelpybSt0RnorUSt4THEvYVpSdklQVUFCK0Z2anljM2RmcTJPQ0VnQmloWm4vcHpRRGt2MnlYL1ozbVAwZThISGdTN29yUUFKQU5PRDhOUURLZmkwQnFmNDd3UDVGRWZBZ01LZUhoQ1FBNVB6WDRQdzFBT28xUU5XLzdPOFErd1BnTjRBL0FhWWtBaVFBNVB4WGNmNGFBUFVhb09wZjluZVkvZjlhSWtBQ1FNNS9EYzVmQTZCT0FXZ0pRQUtnQXlOZ0VnRVNBSEwrR2dCbHYreVgvVjFxdjBTQUJJQ2N2d2JBem9ncXlBSElmdG5mY0xvU0FSSUFjdjRhQUdWL1M5UFVFb0RhZjNUc2x3aVFBSkR6MXdEWUVmYnJGSUFjb094dkhJa0FDUUE1ZncyQVM2V3BVd0J5Z0xLL0MreVhDSkFBa1BQWEREaWVhY2JLQVdnSlFBSWdtdlpMQkxTSWhJb2crczQvaG9UeHpreGMwdXp1V2hKaTQveG0vYitmQU02ck9CUUI2SHJucnhtUTdKZjlzci9MN1A4WWVqdEFBaUJ1N0wvbmFNWVkwOVNadndaQTJhOGxBTlYvbDltdkI0UWtBT0kzODdmV2Z0QVk4eWtOQUpGUFUvY0FkSFg5TjM5anFlcS82ZWw2d04zVzJ2djBsTEFFUU9TZFAvQkJhKzJZQmdEWkwvdGx2K3h2Q2hWcjdjZU1NZmVQSHh3dHk5TklBRVRXK1FOajlabWxqc0UxTmRIbXQ5YlE3QWRybXB4Ymk2WFprOVh3bGdEaTBWWWxBRUtMZ0lWeFl1ZVVNZWJuZ2E5TEJFZ0FSTTM1cDREM0F2Y0NSak1BMlMvN1piL3NiM3FhazlUMkJEdzJmbkRVaytlUkFJaUs4MzhuOEVmQWJnMEFtZ0dwL3JVSFFQVWZXbDd2QTM0RGVFWWlZT1BvSG9DTnMrZFM1eTlpUlhlZmhEZXFmaFZDN1BpeCtuLy80WUd4aVVPNktFZ0NvRzNzditkb3hscjdPbUJYZlRTNVRMRTJZV2h1SkUxejVjK3ZkUmJjNE8rdDZYczJhUCtTM3lQN1E3Q2Zodk1aWmZzYnJjdG01SE10NmE2cmJ0YVJWOU1oOWkvNTg1ZWsrWDdnVWVEM2dEbDVJczBCV2s1OTA5K1BBMk5MTlZTRkFHVi85TlBzOWhDNGxnQmkzdjUvQ3ZpaTdnaVFBSWlNODQvVkFCQ3ZpMkJpOGNKZXpPcWZFUHlmSEtENmY2djZ2MWNYQVYvV3lRQUpnRlk2L3hWditkTUFxTmNBTlFOVys1ZjlMV21yczhEUFVEc2VXSkdIa2dBSTAvbW5nUGNBbjJXRi9STWFBSFFLUVBhci9jditscVg1TXZDM2dPL3FaRUJqYUJOZ1krd0MvcUJqeWszeXI4dFBBUmh0ZzlmMHJ4TzRBZmhYd0Q4NE1EWnhXQ2NESkFEQ21QMW5nTmZUU2NmOU5QeDN1ZndKWlFsWXFQKzNneDhESGdOK0Y1aFg1V29PMkd6bnYreW12NnZIVllVQVpiL3NsLzJ5djhWcEJ0UTJCWDVKbXdJbEFKcmwvTk4xNS8rcGpoc0FkQW9nVG12Z29lUTFuTUNDSEtENmY5dmFmeDc0Q1BEUStNSFJxanlZQk1CR0JjQSs0SWMwc0Z5aUFWRDJ5MzdaTC92Ymx1WVR3TjhEeHNjUGp2cnlZc3VqUFFBck8vOE1jTHZLU1ZxMVE4dFVoU282c2YvZkFmd0s4QytBYVpXZFJ0WDFPdjhQQWZkMDdBd2dYaUZBellCVS82cC8xWDhqL0JUd0JlMEhrQUJvMVBtbjY4NS9yS01IQUlWQXUvd2NmRGd4QUYyRXBQNGZrYnhXZ0k4Q0QraVNvS1ZSYUh0cGRnSC9XOFhROFhUNVFjaXdKSUNxWDBTQ0ZQQTd3TWNQakUwOG8vMEFFZ0JybWYwdm52ZnYvTEl4eW0xWFk3UUhvTHZydnl0eWV3UHdTMmcvZ0FiVk5Uci9kYTM3WHo2dlVnaFE5c3QrMlMvN0k1S201ZUxMZ2RvUElBR3dwUE5QQWU4RDdvMW1CK2oyeDNCQ3NUK2tQUUR4cUt2dzlnREV4djRZN1FGUS85K2cvWGxxdHdVK3F2Y0NMcUlsZ0l0c0F6NGgrZGRWZFBsYkFGb0UxL1N2YStnRmZoMzRsUU5qRTBmMFhvQUV3S1d6L3d6d0ppSjl6MzhJWTNXc2h2ODRaVFltZVEzdExZQzQxRldYdDZudTYvL3ZCMzZhMm5zQkMvSjhVdjlORGYxZkhGZTFCaWo3WTVCWGkwWEg0R1IvZDlsZkFUNElmRk5YQlNzQ0FMQ1ZiZ3Y5eDFQK21hNHZnV1lQMUNhVUpYQ2gvaC9sM0thQTN3TCt4djU3anI3eTNOM1hkdlZTUUZjTGdQMzNUS1NCTjlOSlQvdzJOZ09NMHlBUVJtNjdldzNjbWxBaUFQS0E2djhSeiswZHdNZXAzUkhRMVVzQlhkc0Q5bzhkVFdQNU1QQlhvWmF1WGNlZkZ3ZmxXb2oyNHI5SExaOHIvYmx6ODluWWIwZTVQQzl2Yy9Gb0E0MzJtYWpsYzIzOS8zS1hGLy8rM3h3cm1wdFBTKzNJOTllZXUvdmFycjBsc0dzRndJR3hpVkZyN1N2R21LWkhRYlFHS1B0MUY3enFYL1pIUHMyWGpURS9EcnpVcmFjQ3VuSUpvSDdYLzQ4QUxrSmF0VnZSSVVEUjNWeFA3WUtnLzBLWExnVjBYZmV2Ny9wL1AvQTVLV0RaTC90bHYrenZhdnVyZFBHcGdHNk1BR3dCZmsvaVYySlZKYW9pRUYxUEN2aDNkUkZ3V2dLZ3MyZi9hZUF1dW5YWGY3eFJ3Rm9sS2tRWXZCNTQyNEd4aWM5MzIxc0IzUllCMklhZStkWGNVZ2doTHVkL0F1ODRNRGJ4ZERjOUc5dzFBcUErKzMrejJybm1sa0l5VFlncjZBVitFZmcxNEx5R2dNNXovaDhGL3ZJeUw2Vk5NTEd4UDR4cmEyTlcvMDEvdVZEdFgvYkwvc3ZTWEx3YjRQN3hnNk5kY1RkQXQwUUFSb0JQU3VUR09hVFE1WmZXS2FvaVJDc214TDhOZk9EQTJNVEwzWEEzUU1jTGdQcnMvMjNvM1lOTzZKeENKU3BFbUZ3UEhLUjJUWEJPUTBEOEJjQnU0UGlTVXlxRndHUy83SmY5c2wvMlgwNGVlQWZROFJzQ08zcFdmTW5zWHdnaGhDYVdhNkZyTmdSMmJBU2dmdVBmandHZmxRS1cvYkovaVRTNy9pMEFRbmtQV2UyL0kreTMxRzZNL1hvbjN4RFl5UkdBVGVqR1B5RldVZ0JvWDZVMlFvaGxKOGUvV1o5RW5wVUFpTmZzUDAxdERXZFg1d1JBalBxajhpcjdoV2dkcndmZWZtQnM0dDVPUFJiWXFSR0F6Y0NmZGRZTW9OdG5LOWFvcnVMaXB6V3pGaDNESHdJL1BEQTI4Zno0d2RGQUFpQStzMzhkKytzd0JTQ3ZvaEtOaVFJU25jTXc4SGVBMzZBRG53enV1QjV3WUd4aUozQnlUZU9mTnNISWZ0a3YrMlcvN0Y4WkgzZ2Q4RnluUlFFNmFwWmNuLzIvVTZKVkNFMkFoV2dTTHZCendML3B0Q2hBUncwQkI4WW1kZ0NucElCbHYreVgvYkpmOWpjeFRSLzRFVHJzY3FDT2lRRHNIenVhdHRnZnhXTFhwbm5zaFVZUVJuNDJsTzVpbTd3aWlURHl1djQwTHkvSHB0cmZ0THl1bk1kbzFQL3FlUXkxVExGMjlhOWVleDdiVnYvTDlKbDI1SFA1ZE5kWWpzdjhXR3ZLdFBHNmJuMzlOeWVQRGViVEFYNEorSWZBdkNJQU1aLzlTd0hIemY3bVg5cWkrdGRGT09yLzZ2OE4vRXJIUlFFNklnSlFYL3QvRjZLRDVWK2NqZ0hHcGY1VnB1ci82djhONEhaYUZLQWplditCc1ludHdLUm1BTEpmOWlzQ29QcVgvU0dtMlZGUmdOaEhBT3F6LzNkM3ZLeUtTNW9pUnZXdkNJRDZ2K2ptS0VEc204QjZaLytoS3VBUUhsbUpTNXFhQWNXcS9na2hBS0Q2Vi8vdjlQcnZtQ2hBckNNQTlkbi9leUtYc1RCdVdJdExtaUpHOVcvQ1VRQ3FmL1gvem84Qy9ETHdEK0llQlloMTlSOFltOWdHVEVWdUJxRG5ZTU93bjJaWGxlcGZFUUQxZi9YL2RmNTZSMFFCWWhzQnFNLyszeWN4MmkwekFLUDVTdFByWHhFQTlYLzEvdzFHQVg2VkdOOE9HTnZPdjlIWnYyWUFzbC8yTjM5V3BmcVgvVjFrdncrOENuaHAvT0JvS0JkS0tRSVE2dXkveXljL212dDFkL1diYm8rcXFQK0xEVWNCUGc3OGYwQkJBcUIxREFKLzJnUU4yTjI5UUVIMXJpYWtDYUE2Z016dkp2NDU4QWNTQUsyYi9hZlEycjhRelpnQ3lnVUlzVEY2Z0xzT2pFM2NPMzV3dENJQkVENUR3QityM1RWai9GZHV1OXovUitZaUlOZEFOdUhRbHpSa1hFUEdkVWk3aHBRRFNjZmdPdUFza2RjQWl4OUFOYkJVQWt2SnQ1UjlTOUd6NUwyQW9tZnhyYXBhL1Q5VWZoZjRCbkJPQWlEYzJYOFNlRnZ6OG0yNnUvMXJGM0IzajZ5aG5RSllQVW5YUUUvQ29UL3BzQ25qc0RudHNxczN3ZTYrQkp2VERrTXBsNkcwUTMvS29TZGhTTHNHZDRsa2ZRdGwzMUtvV3VhckFlZkxQdWNyQWRNbG4rTTVqOG1pejdtaXoyelpaNzVxS1hyQkpZSkEvVi85dnlsc0IrNDRNRGJ4dGZHRG81NEVRSGdNQVA5RjBsMkkrQ2tWcCs3MHQyUWNkdlFrdUc0Z3lkNytCUHNHVXV6c2RSbElPbVFUQm1lSmZRa3JuVmpvVGNDbTlCV1JBVnVMQXN4WEEwN2tQQTR0VkRrODczRmt2c3Brd1dPNkZGRDBBZ0sxQWRFY2ZoTjRISmpWQUJCZUJHQUVPTk0wQWF5TFFIUVZxT28vZFB1VERnelhaL2czRFNaNTllWTBOdzNWbkg1dndtbVovUXZWZ0ZONW54ZG1LenczVSthbHVZbzltZmZOYk1YSEMrSlQvejBKUThveDVMMkFhcUQrSDVFMExmQkc0S254ZzZPeDBaV3hpUURzditkb0N2aWdoR1pUUFVCWUVsRHI5YkdvZnhQcU5VQnAxekNTY2RrM2tPUzFXMUs4Ymt1RzZ3YVM5Q2NON1RoOTBKOTB1R25JNGNiQkpEKzZLOHRMY3hXZVBsZm0rOU1WRHMxVk9GY0txQVRSM1RDUWRHQWs0L0s2a1F3VjMvTEUyUkt6NVVEOVB6cVQ2VjhHZmdYSUtRTFFmQUV3WW93NTA4dzBkUkdHN0pmOXpiYy82V0MzWmhQbVZjTXA3dHlXNFhWYjB1enFUWkIyVGVUc3J3U1k0M21QcDg2VWVQUjBpUitlcjNDdTVHOXNadDNrdkxvR05xZGRlOE5RMHJ4dFI1WTdSako4K3ZBQ1h6eFdZTDRTcVAxSEo4MEtjTUJhKy9KemQxOGJpNjJuc1lnQUhCaWJTRmxyUHlDaDJ0WG1LNnJROUJKdDdvRHFHTmlVZHJsbEtNVmJkMlQ0a2UwWmR2VWtTRGpScmJxMGE3aCtJTWwxL1FuZXNDM0RvMU5GSHA0cThjSnNoZk9WZ0hZR0JOeDZlVjQza09TTlc5TzhlVWVXNi9xVEhKcXY4dnhzaFlWS29QNGZMVkxBeDREZkJvb1NBTTFqQVBpajVpZXJpMEJpWkw3T3JJY3dWV3VXQ09oTkdLNGJTUEtXN1ZuZXVTdkxkUU5Ka2s1OHFzc3hocjM5U1hiM0pyaHRTNFp2bkN6dzZPa1NoK2FxRkZ0OGpqRGxHRFpsSEs3dFQzTEhTSm8zYjYrVlo4WTFlSUhsaVRNbEpncytWdjAvaXZ3cThJY1NBTTBkcHd6Z1dtdnRxdnJRTnB5MkRTblA2MDkzR1Z2Q3lHdXI3SGVNSWVtQXdWRHlnOGprTlpMMTM4bzBzWFlqbnNSMWF1djhiOWlhNGYxN2VyaHRTNXJlaEFrbHU2MG8wNFNCVzRlU2pQWU5zSDlUaXZ1T0ZYanFiSm5wc28vZlFEaGdQWG5OSmh4R01pN1hEeWE1ZlNUTkhTTVo5ZzRrU1RzWDB6eGQ5SG55YkluWnNrOHppcVByMjMvejA5d0d2SHIvUFVlLzlkemQxMGIrbGNESUM0RDZ6WDhmcWs5V1ZsZUFwckhLai9RYW1BazNyNjIwUDVzdzNEU1VvaS9oOE9UWlV1T3pxaERlcm8zWkdtZzR6Nkd5L28yQUdkZXd0ei9CdTNiMzhMNDl2ZXp1UzJEb2pEWGd2cVRoN1R0N3VMWS95WmVQRmZqNnFRSkg1cjAxYlJKc0pLK3VnWUdrdzlhc3kvV0RLVjQva3ViMmtUUTdleE9rTG9tZ1dHdHRBT2FKTXlVT3pYdFVnNDJ2NEdnUFFHajIvN294NWlsZ1hnSmc0d3dBLzZQeHViMklDZ2JZMlpQZzduMTliTXU2V0N5UG55azFkUFFxckxmclkwVHpRNkFiU0swLzZmRGFMV2srTk5yTG5kc3lES1Njaml6MGEvdVQvTXdOL1Z6VGwrQUxFM21lbVM2VDkreUdpejJiTUd6T3VPenFTYkIvVTRyYnRxUzVlU2pGNW95RHU0eFBPbFAwZWVSMGlYTWxYNE5LdEhrbnRmMEFrU2ZTQW1CeDlxLzJGRXVmZjRHZWhPSFZtMVBjdVRWRFQ5TGg0TDUrWnNzQlA1aXRTTlhGVUZKc1NqdThiVWVXbjlqYng2czJwV0sxMXI4ZUJsTU83OTNUdy9hZUJHT0hGM2gwcXNSY2d4dndURDFpTXBSMjJKWk5jUDFna2dPYlV0d3luR0swTDBrMnNYSVpCc0IzVHBkNGZxWkNTWGNiUngwWGVOZUJzWW5QakI4Y3JVb0FiR0NpUVcxRGhZaXBhekhBenQ0RWI5MlJaVlBHQmVEMkxXbnV2cjZmUDMxeG5zUHpWWlZXakZUZDFxekx1M2YzOEJQWDliR3ZQMG0zUENhWWNBeTNqNlRwU3hyNmtnN2ZPRmxrdXJUeVJqelhRRy9DWVREbE1KSjF1YVl2d1UxREtXNGVUbkg5UUpLQnBMUG04anVWOTNob3NzaFp6Zjdqd204RDl3TXpFZ0FiRzNNU2FrdnhKWnN3M0RxYzRyYk5GKzlxN1U4NTNMVWpTOEVMK09STDg1ek0rMnR0QzZMWnZhdUJIOTNabStESFIzdjU4TFc5N09ydHptNTUwMUNLbjcyaG42eHJ1UDk0Z2RQRml5TEFOWkJ5RFFOSmwrRzB3NWFNVzcvdU9NbU5RN1VUQnYxSnArRmprU1hmOHVESklzL05WQ2hyOWg4WHRnSDdEb3hObkkveXpZQ1I3Y1gxOFA5SDFJN2l6VWpXNWM2dEdUYlhaLytMREtjZDNyMjdoMExWOGxlSEZqaFRYRlVFNkJoZ3MxbGppUnBnVjIrQ2orN3Q1VU9qdld6cjZXNU5mbTEva285ZjM0OXI0S0hKRWhYZjBwZXNuWWJZMXBOZ3RLLzJ6c0hPM2dRN2UxeXlDV2REVmZUQ2JJVnZuQ3hxN1Q5Kzh2cnZBLzhBeUVzQU5FNC84Ti9WanVKTDBqRmMyNS9rTlZ2U1M0dURqTXNIUjNzbytaYlBIc210RXQ2VTcyOFgyM3RjUG5SdEx6OHU1MytCM2IwSlBuWmRIOWNOSktrR3NDMWJlK3RnSk9QU2t6QzRUZG9YY2E3bzg4V0pQSy9NVi9Tc2NmejRTZUNmU1FCc1RFV0ptREtZY25qTnBqUTdldHhsZjJaYlQ0S2YyTnVMWnkzM0hzMHp2YXdJVUFDZ0hiMXJjOGJoL2RmVVp2N2I1Znd2WTA5Zmt0MTl5YXVLc1ZsSHk0dWU1Y0dUQlI2WktqSmZDZHJ5Zm9MWTJCQUkzSFpnYk9LaDhZT2prUXpmUkxKSDE4UC9QNm4yRTI5R01pNnYzcHhhOWxqVG9nL2FVUmNCMWNEeXBZazhNMlU5MHRvU1Z0RlUvVW1IZCs3czRVT2p2ZXpzbGZOdjVRekZ0L0RNZEprdkhhdnRNeEN4NVY4QVR3QUxFZ0JyUjd2L1kwN0tNVnpUVnp2dXRPb2dhbUIzYjVLZnVxNlB3TUpYanVXWnZsb0VhUHJUUXUrVmRRMTNic3Z3NFd0NzJkdWZWRm0xbUtNTFZUNXpKTWZMY3dyOXg1eTNBNUh0UUpMMUloUUdVdzQzRDZVWVRLNXRBNVJqNEpxK0pCL2YxNGNEM0hlOGNPVnlnTllBV2hRQmNBemNNcHppSTlmMmN1dHdDa1dlVzh0VXdlY3poM044NTNTSmdpZnZIL2U1RUJGZUJvaWNBS2lIL3orbWRoUGppYVdwWFhoeS9XQ3lvYzFRanFtdHF4N2MxNGRqNEV2SEN0cjUzQVoyOUNSNFQvMWUvNFFqNzk5S3BrcytuNS9JY2YrSkF1Y3JXZ3JyRUg2ZGlDNERSREVDMEFmOE43V1orSkl3dGZYL2Evc2JiMTZMa1lDRCsvcHhIY09YSnZKYUF3MU5xUzNSK1JLR3UzWmt1V3RIbHY2a296SnFJYk5sbjY4Y0wvQzVJL20xSElzVjhlRXVJcm9NME9WTEFFWjVEWUdVYTlqVm0xajNrVEZqWUhkZmdvUDcra2c1aG51UDVqaVY5MVZYemVhS0pRRFh3UDdOYWQ2MUs4dE83Zmh2S2VjckFWODdVZUJUaDNLY3ludnJhbkhEYVlmK2xNT1pvazlSU3dlUkdoS0o2REpBcEhwNVBmeC9zRzBqWUp4RzZ3alRtekRzN2syUTNrRDRlUEVCb1k5ZDEwZlNnYzhkeVhNaTc4WGs3WUI0YmxmWTFwUGdIVHV6M0tKMS81WXlYZko1OEdTUmV3N2xtTWhWYVNUd24zWU53Mm1IM2IwSmJ0dWNwdWhidm5haVFORlRCQ0ZpUkhJWklHb3l2dy80QTdXVmVOT1hkR3BQd3piQmlXek51dnpFM2o1NkVvNzU3SkVjaCthcjJoVWRRcUFpN1JydUdFbHo1OVlNdlFyOXQ0elRSWSt2SGkvdzZjTTVqdVU4MXZEYU1BbGpHRWdadG1VVDdCdEljc3R3aXR1MnBIQ0FUNzY4UUw2cXZRTVI1SzRJK2x1ZEFoRE5KNXN3akdUZHBxVzN1WFpqb08xUE9lYlRoeFo0NFh4VmQ2STNPVkN4cHpmQm03ZG4yTk9uSWFFVkJCWk81ajIrT0pIbjNva2NrL21WSHhaS09vYkJsTXVtak1NMWZVbHVIRXp5cWswcGJoaE1NcEp4eVZVRC90ZExDengrdXJUaDU0cEZLS1NBR3c2TVRUd1pwYmNCSXRQYjYrSC91OVZPNG8yeitBSmFrMmVSQTBtSGQrN00wcDh3Zk9aSW5xZlBsY2hWTmRBMWc0eHJlTjFJbXYyYnRPdS9GWlE4eXl2elZiNHdrZWYrNDB2ZWVZRmphbmN4OUtjY1JqSXUyM3RjYmh4TXNXOHd5WTJES2JabFhWS093WmphWTBIZlBGWGtnUk1GWm5XSlZwVDVSZUNYZ1lJRXdOWDBBcDlRRzRrM0NXTVlTcm1oaEpIN2tnNXYycDVsS08weWROamg0YW1pYmczY0NIVmZmMDFmZ2pkc3piQzl4MVdaaE14czJlZXBzMlcrTUpIbmliTmxjdlZ3dld0cXl6RDlTWWZodE12bVRPMzU0RDE5Q1c0WVRMS3IxMlZySmtIS05WZEVFaXpmUDFmbXMwZnluSXpOSHBtdTVhUEFQNVlBV0hWSUVyRVZBRTd0dWQrZVJEaFZtWFlOQnphbDZFOE9NSngyZWVCa2dWUFJHL2ppMFk1dHZUdzNwN2xsS0VWQ08vL0NtL1g3bHVPNUtnOVBsYmovUklISnZFZHZ3ckFsVTNzaWVHdldaVXZXWlU5dmd0ZGFRbndBQUNBQVNVUkJWR3Y2a3V6b2NkbmVrNkEvYVhDTXdWcTc1RnNBUnhjOFBuMDR4dy9uS2lqeUgza0dnSkVEWXhOejR3ZEhJMUZia1JBQUN2OTNrZ0F3OUNjTkdkZUUraDM3QnBQOHpSdjdHY200ZlBGWW5rUHpGU0swOXlrMnh3QzI5N2k4ZG5OYXMvOFE4YTFscXVEeCtPa3lMOHhXMk5tVDRIWDFNaDlLdTJ6TnV1enNjUmxNdS9RbXpJcHZaMXpLNmZxTmdkODlVOUt4djNoZ3FMMXg4OXRBV1FKZ2NiUzB0Z2Y0ci9XQjg1S3lzbGYrbkYzdTMxWXVjN3ZFNU14ZWtlWjY2OU11K1hkcnNjM0s0OVgyTnllUGphVzVsandhWEdwcnlxN1pZTkV1M1U0dVMzQnJ4dUhEZTNzWnlUcDhmaUxQczlObDVpKzdQVzNwUERiUGZydm12RFphamt1bHZYcGVHOHVqYXd6WER5YnRqVU5KRXFaNXI5aHR2Ri9GTzgwcjAvVnRiZFBmcmNOSlhqK1NaaURsTUZDUGtqbEwvKzZxYVo2dkJIeGg4Y2JBc285dGFFeThOTTByeDZtMXQ4ZmwyK0JpWHMwRzBsbkovbWJrMGE1Zy8wYWFoTGtrM1NYeitQUEE3MHNBWEZvc3RkaFdZcm5DWEt4OGMxa016RFJjS1ZkK2RuV2E2Ni93cTlQRk5DT1B5OXUvc1R6V21xYTFwcUhEZW1iVno0eUJoR09hVUs1cll6QmxlTWV1SHJiMUpQamlSSjZISjR1Y0xsNjVvOW9zTjBnMStNU3FXVU41cktXdVRNTnByejJ2YThzandFREs0ZGJoTkx0N0UwMTlhclk1L1NxZWFTNlZiaExZMjU5azcwQnkzV0doUzlQTVZ3TytjYXJJNXlmcU53YldCcHVHZzA2MS9yL2NPTFgyZHJTVXFMaG8vL3JUV2IzOWJ5VHR4V1dWNXVYeGN2dFp6djVyZ2NpRTIzVG1wNXNKSVZCdExyYjhVQWZWUzhtNGh0czJweG5KdU96c1NYRC9pUUtINTZ0VVZqOVUzZFUzUWUzcVRkaWJocEttTjZGei8rRk9jSnFYVnRtM1BIYW14S2NQNVRpUjIrRGVsM2pkVnhWR2J0dFJBaTV3KzRHeGlXOUU0VmJBdGd1QSt2ci96MmlZNkNCUjBRWnFEd2tsK0tsOWZlenVjN252V0lIdlQ1YzVyMU1DUzQ5Q0J2YjJKOHllSmwzWUpNS25HbGllUGxmbXIxNVo0S1c1cWpiOXhaZGZBeDREOG9vQXdPTDZ2Mmo1MUNRTS8yL1hkSnRaV0F5bUhONnhzNGZkdlVtK2NqelB0eWFMbk1oN2VOSUJsekdRY3RnM2tMUmJ3OXl0S1pxR2IyRjhwc0pmdkx6QXM5T1Z0VVMzMnRML3hacDRVMFI4YjJTV0FOUVUyelZiTjgxUDBtL3pvYnkwYTNqVmNJcHRXWWU5L1VtK2RxTEE4N01WNXE1K1hyVnIyOTFJeG1XMFAybDZGUDZQUEY1ZytjRnNoVDkvYVo0bno1WW9OZXNXVEV1M2o3enRzbjRnS2lXdlBRQ2lxUVMydGs3cFc3dm00MHloOUd3REk5a0VQM1pORDljTjFFVEFJMU8xYU1BbHh3VzdkZ2pjM3BOZ1I0OXJROXF5SVpvMjg2ODUvMCsrUE05anAwc1V1amJ1SDBvemJWZi9OOERiRDR4TmZISDg0S2pYemxKdHF3Q29yLy8vckxwNTUvUXBMN0RrcWdFbHo5S2JiTjRYckhlM2RqYmhjTnZtTkx0NlhXNFlUUEwxVTBYR3A4dGRmWU5nMGpGczczSFpvdkIvNUdmK0w1eXY4dWN2TC9Ed1pBaDMvTWVxOXEzcE1LMytyNEFIZ0Z3M1J3QjZnTi90TUZVWm96N1YvQ0x3TE14WEFncWVwVGZaeEt4dTRNaVdNYkExbStESHJ1bmxwcUVVRDU0czhQQmtpYU1MVllwZCtLaFFiOEt3dlNkQlg5SlJFRGlpVkFQTDh6TVYvdUtWQlI2WkxKR3JCalQ5eEtKT0FiU1RXNG5BY2NBdVh3TFErQmZHd0RWWENjaDdBU05FNjNhNXRHdTRkVGpGemw2WFc0ZFRmT05rMFR4OXJzeFVzYnMyQ1E2bEhYYjB1R1IwOTI4a0tmdVdaNmJML09VckMxMGU5dS9vR1dBMkNzNUhld0RVL0p0S1lHR2hhcSs0a1M5aURqRGxjdGVPTERjTUp1MmpVeVh6OEZTSkYyWXJUSmY5dHA1Z2FCWDlTWWVobElNakJSdzVDbDdBVTJkcnp2K3BzK1Z3STFTcStYYTJmd1BjY1dCczR1dnR2QStnYlFLZ3Z2Ny9mNmpMZDE3ekwvbkJraytjUm9tRVk5alRtK0FqZS9zNHNDbk53MU5GSGp0ZDRwWDVhcVRGU3pQb1RUajBKQnhhZFZ1aldCdm55d0dQblM0eWRqakhjek1WeW1FdlQwbit0WnRmQXg2bGpmY0J0RE1Da0FWK3ArT213R0VsRzhaWUhkSU84SHpWbWhPNUt0Wm1tNWJ0TUp5Vk1jWmtYSGpWcGhUWDlDZDR6ZVkwRDA4V2VlcGNtV001ajRYMXZpNFVobU50VWwwWmFxODE5aVYxL0M5S25DNTZQSGlpeUwxSDg3eXkxTU5XTWVyL1lZeUFKcHpycXNLeGYrMzkvMGRvOHo2QWRpOEJTSDkySUxscXdMR2NSeld3VjcxZkhsWDZrdzV2MkpyaHhzRWtkOHhVZU94MGlhZlBsVGllODVxLys3cU51RTd0RXFEZWhMcGVGQWlzNVZqTzQ3NWplYjQ0VVh2YVduZFdkUTF0dnc5QW13RER1UTR2aEZ1cmJmTm5BUllieGl5ZzdGczdXZkROdVpMUHp0NUVrOHdQL3pFWXg4Q21qTXRiZDJSNTFhWVV6MHluZWZ4MGlXZW15eHpQZStTcmRzMEpOejBLMEtTNlNoaERieUxjNTVyRm12c0pQenhmNFFzVGVSNDRVVmo1YUdxTStuOFlJMkRqRDVlMTBRRTA5bkxYelFmR0pwNFlQemphRnQzWEZnRndZR3dpQ1h4VVEwQ2JDY2tIK0xZVzBqeXlVRzJhQUdnbGpvRXRHWmQzN096aDFadlNQRHRUNXJ0bnlvelBsRG1lODVpdkJNUTFKdUNhMnVOSlNjZUU5aHFlV0ozWnNzK1RaOHQ4WVNMUGsyZEs1Tm9SWlZMTlI0R2ZBNTRCU3QwVUFjZ0EvMTUxMzVrQmtNQmFac3NCcjh4VnVYTmJwcTAzQXE0NC9xM2kvQndESTFtWHQrL3M0VFdiMDd4d3ZzS1RaOG84TTEzYkl6QmI5b25iTlFMR2dHdHFjeWs1Ly9ad011L3g5Wk1GdmppUjU1WDVLdFdncy9xL3BrQU44YU50OU1OdCsySUgySzc2NzF3V0tnRXZ6VlhKVlN5RDZXaVc4MXBud0c0OUl2Q1c3VmxldlNuTlMrY3JQRE5kNGRtWk1xL01WemxiOU1QZnNkMjBGbDkzL3FBSVFGdmFIRHd5VmVTZVF6bU9iL1E1WDlFSkVtaDMzUjkybFFCUS9YZTQvaTM1bGlNTFZRNHZWSGx0T2gzNmJMMVZ4VFdZY3JoamE0YjltOUs4TlpmaG1la3l6ODVVZUdXdXlxbTh4M3cxaUh4VXdFU29UTHVSVXdXZnVTZ3NJOFdyOWp1MXJiYjFRaUJkQkNUOUUxclNaNG8rejh5VWVmWG0xSWFYQWFJMlc4MG1ERGNOcGRnN2tPVE4yMzFlbWF2eTdFeUZGMllySE10Vk9WUDBtL2RxVzNPakhnUzJWaitLQUxUQml4bElPNFpJN01HTTFmekhkT3BzelFDM0hCaWIrRzQ3TmdLMlhBRFVOd0QrcElhQ3ptZXVFdkRjVElYcFVzRFdyQnU5bnRjRTU1ZHlETHQ2RSt6cVRYRDdTSnFKQlk4Zm5xL3cvR3lGdy9OVkpnc2VNK1VnTWtzRUFlRFZSWUNjZjN0d1RaaEg4RFZiaVdGVTRlZUE3OU9HallBdEZ3RFcyZ3p3Vy9VYWJYZ1dHRUorYkVoMjJtNU5jekhkc205NVphN0NzOU5sZm5SWE5ySjViUmE5Q2NPdHcwbHVIRXJ5MWgxWmUzU2h5c3R6RlY2YXEzSjB2c3Brd2VkOEphQzR6b2NIbW1HL2J3MWwzK0lGbGpDTFUrMS9oWFJOYlVMYjZGZHIvQXNselNpMC83WnRCR3o1bDlabkhkdlhVNkJobndPUGNycHh0ZjlNMGVmeE15WGV1QzFEL3dadW40dVQvUW1zM1pwMXpkYXN5MjFiMHN5VUFpWnlWVjZacS9MeVhKVWpDMVhPbFh4bVNnRkZQMWpUK3dQTnlxc2ZXSEpWdTdnOG9mYmZCdnROL1g4YitXcU5meDF0L3k3YXRCRlFld0JFcU9Tcmx2R1pDcy9OVkxoeld5WlNnYzlXaE1CVGptRjdqOHYySHBmYnQ2U1pMZ2NjVzZneWtmTTRNbC9sUk43alZNRmp0aHd3WHdsQzN6ZFFlNjdaSis4RmdLc0dLa1Q3eWJicml5VUFSS2hZNEVUTzQ2RlRSVjQxbkdJZ0ZaMDc2RnU5Q1M3aEdMWmxYYlpsWFY2N3haTDNMR2VLSHNkeUhpZHlIaE01ajFONXJ4WWRLQWNVdkpvZ2FQWUxoYmxxTFFvZ2hJakdYRVFDUUhRc3VXckEwK2RxTittOWFYdDJYYTI5MHphc0pSekRZTW93bUVweHcyQ0tpbTg1WHdrNFcvUTVWZkE0bWZlWUt2aWN6SHZNbEgxeTFZRHpsWUNDWjZrR0d4TUZlUzhnWDlXTjg2THpIRnFNOC9tZUEyTVRueHMvT09wMXJBQ29ud0Q0dStvZlhSZ0Z5RmQ1NEdTUm00WlNiTWswSG5ydTlDTnJLZGV3TmV1eU5ldHk2M0FTejlhRTA1bWlmMkcvd0ttQ3g1bWl6L21LejJ3NVlLNHVDRXFlcGVqWFRocXNaUVZodmhJd1c2bnRQZENUQUswbnNCRHgvYXpONlBKRytXeUlYd1R1QXpwWEFGQzdBdmcvYWdqb3hpaUE1WWt6SlI3ZW5PS0QxL1NTY0RyWDgyeFVxQmhqU0JvWVRyc01wMTF1b25hOWN0bTNGRHhMcmhwd3J1UXpYUXFZcndiTWxRUE9sbnlteXo3NWFtM1pvRlQvMmFJWDFIZjlYenorbC9NQ0pnc2VCZC9TNzBnQnROcmpMTjdESU1RbDdLRU5Hd0ZiTFFBTTJublV0VXdWZkI0NFVlQ1dvUlEzRGFVNmQ1QVBJVnBoZ0d6Q0ladUF6Um1YMGY1ay9idWdFbGp5MVlDRnFxWGdCUlQ5MnQvbnE3V05oZmxxN2JPcWI2a0V0Wi9mbmsxZzVZWGEwVGJ3ckZYWml5dloxWTVvaFBZQWlKWlJDV29uQXU0N1ZtQmIxbVVvTFMyNDhXZ0RwRjFEMm5YWmxMblMyVUNBeGI5azl1L2Iyak8wU1FkNkVwcjl0eHJQUXNXM2FBZUd1SUtNQklEb2VNNlhBeDQ2VmVTR3dTVHYyZE5EU2lIb1VNV0JpOEYxSWJYRTJHSTFEVzA1VmIrMmxCT283TVVWM2JVZFh5b0JJRnBLYlVPZ3grY244dXpzVGZEYXpXbldFaXpYdGJXaUU2Z0VsdUlhTjJ1S3JoTUEydytNVFN5TUh4eHRXZXVRQUJCdEdRVEhaOHA4NW5DTzRiVEQzdnA2OW9yQ1FRL1hpQTZnN0VzQWlHWDVNUEE3UUxYakJFRDlDT0F2UkU5MHhVa2dkZzc1cXVYUnFTSmJNaTQvYzBNZjI3TFNvcUk3QkVDaEd1QUhVZ0RpS2o0Q2ZLSWpCUUMxVFE3L1BscmxIYWNYSmp2dk5jenBjc0JYVHhRWVNqbDhlRzh2bTdRcFVIUTR4ZnJ4VFBsL3NRU2p0UGdvWUt1blhScmhPeHhEWXpwbE11L3h1YU41c2duRCsvYjBNcFIyVklpaW95TUExY0RxSGdDeEZJT3RudVVwN2lxYTI0TFREdGYwSnBncDF5NmJXVzJ0MHdMSGNsVStkVGlIYXd6djJwMWxXSkVBMGFrUkFNK2lXNWpGTXFSYi9ZVVNBS0twYk0yNGZPeTZQc3FCNWJHcEVpL09WVGxUOUttdUVQUDBMUnllci9LWHJ5emdXY3U3ZC9kY2RWMndOZ0NLVG1DK0VsRFJEa0FSRVg4c0FTQ2FpdXNZcnUxUGNQTndtdHMycC9uK2RJVm56cFY1ZWI3S3lieEhicG5wajIvaDhFSk5CQlE5eTN2MzlMQ3I5Mkx6MUNrQUVYZXNoWm1LVDhsWENFQXNpUzRDRXZIR3E1OXp6cmlHbTRaUzdPMVBjdWZXREMvTlZYaHVwc0pMY3hWTzVUM09sdnlyTmtNRkZpWVdQTzQ1dE1CY0plQURvejNzRzBqaXl1K0xEaUN3bHBsUzdhMEdJYm95NUNBNkd6K29yWE11a25JTm8vMEpkdmU1M0RHUzVrVGU0OGk4eHl2ekZZN25mU2J6SHRObG4xeTE5bkNOYjJHeTRQTzVvem5PbG53K2NFMFBCemFsNlU5S0JJaVlpMk1MNThzK1pRa0FzVHh2T3pBMjhaWHhnNk8rQklDSUhWVnJ5VmV2SHVCY1l4aEsxKzcvdjJVNFJhNmE0V3d4NEdUQlk3TGdjYnJnY3lydjFkKzhEOGhWTGMvTmxGbW9Cc3lVQW41a2UyWmR6d2dMRVJXS2Z1MkJKay8rWHl6UHg0RUhnYzRSQVB2dk9acXcxdjVOMXZVS3BybndhN1lwbDVjdnppU2JuZWJseVd3czNjdnoyTHcwci83MTlhZTVkQjRydm1XKzZxK1lyZ01NSkIwR2tnNzdCaEw0RnZLZVpiYnNNMThKeUZWcmI5M1BsZ01XcWdHVm9IWjVpazA3VFI4NmJVZ1g0b2VSYmx6U2xQMUxwenRUcWozZDdBVjJYZTh3TEoxWHcwWWVGNzQ2emFYNzljYlNOVFRqQWVTTGFUWW5qMWVuYVp0WS80dUpOWnptRUMzY0M5QVNBV0NNU1FQL1p2MkdtUkEyZ1RVN1RYTlpvMnBPdXMxTzgvSmZ0MWhyYUc2YTFjQ3lVTFcya1gzN0NRT0RLY05neXJtMEErSGIycGxwTDRDa0E4M2VBeGpXeHNJdzBvM1RKc2k0Mk4vcStqOVg4amxmcVMxek5mcTFLK2QxZlNhczNQOU5rKzAzR3kzVEpjck1OTG1lVEJQcmZ6R3hodFBjM1hFQ29HN1FWa1Yzb2paU043K3BWUU9ZS3dlVWc5cEd3UFdMUmtnWVE2TCtXbUJkcVdzalFKZUtpazVndXVSVDhJS083di9LN1liWlN3dHZBOVFlQU5GVXlyN2xkTkZqdmhLUXlXck5Qc3JJK2JkU2JNRnNSU2NBUkxTUUFPaHFEOUQ4Skt1QlpicmtNMXYyMlNvQm9BaUFBR292WUo0cCtKZWRrT25FL2k4MlRFb0NRTFRJQXpSL0VMREFmTlZ5dXVoejA1Qm0xdDJXcGxpYVhEWGdWTUdqRUNVQkVLT2d1b21YV3RsSVpqTjA0QjRBMFVYTVZ3SU96MWQ1Ni9ZczNlaGl1bjBUbkxpYXVVckFURGxZOFVwc3NaSldzWEVTQWJHUlZsMHVBSXpNRDJtMmMyVGVvK2dIOUNTYXM1OUZqaXFFNmxlWnRveXBnc2Q4eFkvV0s0RHhxbjIxVlFtQXJoVnFzVEsvSEZpTzU2c2N6M25jTk5TY0pTM05Wa09vZnBWcHl6aWVyMjJNMWZDbndWb0NRSFEwUVdETjZhTFBpK2VyM0RpWVFpNUdFWUJ1cGhwWUpncysrZTY1QWxEdEtpWmxKd0dncGhhR1ZMZm55NEY1NFh5RmQrM09ObTBaUUNnQ0VFZG15clZycmt0UkV3RGgxYnhtNjRvQVNHeEZQcThoZHRPOEYvRGkrVXBUbHdHRUlnQnhaS3JnTTFYd3FXeG9BMkM4K3IvR2Fna0EwY1VFRms3bFBaNmRybWdaUUJHQUxpNWpPSm4zT0IrMURZQkNTQURFU1FLSGtOZVFUWjh0Qnp4OXJzUTdkMlhadk1HWC9PU29GQUdJSTU2MUhKbXZNcmZoRFlEeDYvOU5IdjlNRjQzVnR4MFltM2hrL09CbzZMdEdGUUdRL2dtTmttOTVhYTdLTTlObDNybXJSN05WUlFDNmp2bEt3RVRPVy9LSmJNMS9PamkzRytOandIZUFpZ1NBaUxXK21DejRQSHE2eE8wam1jdGUreE9LQUhRRHgzTWVVd1ZmRndDSlJyaU9GajBJcEUyQU1qOVU4dFdBWjZmTFBEdGQ1aTA3c3RvYXJBaEFWd25nbzdrcTArV0lydityNXJzZTdRSFFSVUNoZjhXSnZNODNUeFhadnluRmNGb1BCQ2tDMEIyVXZOcU5tSkc3QUVqRG41QUFFSzBpWHczNDNya3lUNXd0OCs1ZFBUb1JvQWhBVjNDdTVITjR2a3ErR3Fnd05pNVhWUVFTQUNLT2ZjcFNPd3Ixd0lrQ3R3NmwyTjNYZUxPVG8xSUVJRzRjWGZDWUtucEU5Z0pBblFLUUFGQVJkUE1Vc0hXRFFORzNmTzljbVFkT0ZyaDdYeC9aQm04SDFHeFZFWUE0NGR2YUNaaVpVcUQrMzQyNWxRRFF6TG9yMDF5QmN5V2ZCMDhXdUhrb3hSdTNaZFNiRlFIb1dHWktBUy9QVlpodlZ2aS9BL3EveHY4dUZRRFdXakRZQzF0aFRWM1BOZkpud0Zvc1dHT01zZFphQThaaXJNSFcvd3RjK0xNMXkvOHNHSXkxaTdPZ2h2TzBocCsxQU1aYXJERmdMMlNrOXQzR2NsV2U3SVhQRjhmbFdya3QvaXhZckYxWDJhM3daOHVsMzdHWW45cUhHR3VOcmYwanhwakZERjIwaTJYS3VwN1hLNzdMcy9ES1hKVXZUT1RaMmV1eXB6ZlJhRHU2K0NWTitPOWw5Ui9pRExzWi93MHJyODBzejFhVTYwcmYyV2k1aDVuUHcvTlZleXpubVlwdnJiV3NvYytzTnBhRjFmOXIrVEcybHNIYVdJQmgyVDYvbHJGczZmNi8wVC9iU3diRm1qK3hGd2FwSzhmUXRZMWw0ZVNUQzBYTFplVzIrTDJHQzhWZC81d3I4OTh5RmRFU0FWRHZhK1l5bXhyODgySnQxejgwRjlLcy9kL0Y5U0Z6MVdkTC9HenQ0OHU4YmFONVd1SGZhd05NN1RzV3MzREZqTXV3ZFA3TnBUdmtMcFpicmIxZStQME5sT1BWWldxV3ljL0YvRi9JMUlYOEw5cTFkRm5YUjd3bDZ6dnZXUjQvWFdKUFg0S2Z2cjUvelhjRFhEcG9OK3UvWWMyQ0Y1MUtNL01iUnJnK2pIeUdWYTZyNVhXcHlFYTc2dDhMckgxeHJtck9GdjJhOXpHcjk1blZ4ckthdXdpai8xLzhEc09sNC9SeWZYNzFzV3hSU1RRcm54ZkcxTXZ5Yy9GN3pkSmo2S3BqbWEwNzQyYm04K0pZeFpMbGR0bWdmdG5uUy9zQUxRR0lqbU82N0hQL2lRSTdleEs4ZDA4UGFWZXhTTkU1bks4RXZEQmI0WHhGdS8rRmxnQ0V1SXpBd3JFRmo4OGR6YkVwNDNEbjFnd0p4NndXUllyUHUyVmFXKzlxWHBtck1KR3JVdkYxKzUrUUFCRGlLaXFCNWZuWkNtT0hjdlFrSEc3Ym5NSlp3Vy9HYWNlNmR0ZDNMMTY5WFo4dTZ2VS9JUUVneExJVVBjdVRaMHRrWEVQU0dXRC9zSjRORnZIbWJNbm5oZGtxYzJXRi80VUVnQkFya3F0YUhwa3FrWEFNZitQNmZtNFpUcTRZQ1JBaXl2endmSVVqQzFVcWV2eEhTQUFJc1RvTDFZQnZuU3FDaFk5ZjM4ZXJOcVZ3SlFKRXpDaDZBYytjcTNDMjZLc3d4RVlZQXp3SkFORTF6RmNESHBvc1Vna3NQN1d2ajlkdVNaTnlKQUpFZkpqSWVieHd2c0tDN3Y0WEcrTno0d2RISlFCRTkwVUNIcDRxVXZBc0M1V0FPN2RsNkV2VzdnblFwam9SWlh4cmVYYTZ3ckdjaHhkWTFGeEZIT2h5QVdDVTE0aFI4Q3hQbkMyeFVBMDRWL0s1YTJlV0hUMEo3YXdYa1dhbUZQRE1kSW5wa3NML1FnSWdKc1RwZlludWVRdWo3RnVlbnlrelcvWTVtZmQ1MzU0ZXJoOU02TUlnRVZsK01GdmhwYmtxSlozOUZ6RWFxTFVFSUNLSlorRll6dVBlb3psTzVxdThhM2NQYjlpYVlVdkdWZUdJU0pHdkJqeDF0c3hVUWJOL0VhL1ptZ1NBaURUbkt3SGZtaXB4TE9meDBseVZ1M1prdVhFb1NXK0R6d2tMRVJhSDVxczhQNnZOZjNHY0FVZFVQRWdBQ0xGSXhhKzlyWDY2NlBQaStRcHYycGJsRFZ2VGpQWW55V2haUUxTNWJUNXh0c3hFcm9xTy9zZHZCdHp0U0FDSWVJd28xcHE1U3NEanAwc2NtcXZ5L2VrMGJ4ako4SnJOS2E3cFQ5Q2ppSUJvQThkeUh0ODdWMlpHbS8rRUJJQVE0YzRxZkF0VFJaL3BVMFYrTUZ2aDVxRWtyOTJTNXNDbU5LUDlDUVpUamk0UkVpM0JDMnBYV1IrYXIrSnA5aSthUTB2WGtTUUFSQ3d3VjBRVXE0SGxaTjVqcXVBeFBsTmgzMENKbXdaVDNES2NZdDlnZ3UzWkJQMHBwMlBpa0RvQ0dUMG1DejVQbkMzcjVqOXg5WEMxZmtxMGNCK0FCSUNJeWZUZlhpVUNBSHdMWjRvK1o0cys0OU1WdHZlNGpQWW51RzRneVhVRFNiWmxFNHhrWEFaU2h2NmtzK3F6dzVHMVgvY2dSR3VhWmkxUG5TM3gwdm1LN3YwWFZ3OVg2eGNCWGlzejJrb0I0QU02d3lVRnZLWmZkazNOdWRzR2Vsek9DM2hsUHVEd2ZKWHZuaWt6a25YWjA1dmcxdUVVdDIxSmNXQlRtajVkTHl5YU5QdC8vRXlKMDVyOWkrYVM2OFFJUUJuNERlQzNWTDlTd0t1eHJjZmw5U01aQU02VmZPWXJBVVV2d0xPMWRkZmdFbUhnR0hDTndUV1FkZzA5Q2NOQXltVTQ1ZENmY3RpY2R0blRWNHNDSk9UOFJaTm0vMCtlTGZIOGJFVVgvNGhtTTlGeEFtRDg0R2gxL3oxSC95dndteXRNK2xZMTJscHJWNTF6TmxoMFM2UnBtbEVCRzBwM01kWnRMLy81RmUxdlhqNXBSbmxjbG00REtSZ0R2UW5EblZ2VEhOaWM1bnpaSjFlMWxMeUFTb0Qxck1VTGFvT3dxVHYraEdOSTFBVkFObEVMOVE4a0hYb1NEdG1FSWVNYUZuMy9sZVkyV3FiR0dMT1czMW44bWJYK2ZLTmwycXgwTjVyR2N2bG9kVnRkWEI1WjYvYzIrdk5YenY0Zm5Tb3hWZkJaNHRmTmh1MWZaaXhiUjVxcjlyeDE1ck94ZEEzbXlyR3NIVzExcVh3M25PWWF4N0pWMGwwcGxabE9qQUFzUG81aDF0RHNseTNRTmEyQm1zWWExREpwbW8wMjFLYWtlOG1pZHhocndBMmthVGFjYmdNcHpKWURqdVU4M3JPN2w3Mzl5UXRwQm1Cc2ZmWnZiVTBzTElvR3AxNWN4b1JpLzVMT1k2M3BOcVBlbHNyclJ0TnRWcHU2TW8xMnR0Vkd2N2ZSbi9jQ3krT25hN1Avc3IvMG96KzJKazQzYnI5cFNwbWFrT3JmTk5qL0k5RldMODMzdXRNMFRjbnJjdi8rTUMzY0I2Qk5nQ0p5ekZVQ25wdXBjRHhmNVliQjFJWFBYV05pY2IxSVhEYnJhVk5oNDV6SWV6eDZ1c1NVMXY1Rmt5Wk1WL0JaQ1FBUi9XWWFJcjZ0dmEzK3ZYTmxyaHRJeHU1Y2YxeDI3T3RrUVdOVTZyUC9IOHhXcUhUQzJyOVJac1BxV2h2SThPVDR3VkVkQXhRUmI2WWg5OVp6Slo4bno1WjU2NDdhYzhCQ0VZQjJjMml1eXNOVEpjNTB5dXcvd3YyL2xabU5XSTIwbEM0ZldUWCtSWFZvS2Z1V0Y4OVhlUHBjbWZmdmNWVlRpZ0MwbFlJWDhPM0pJaS9NVnFqcTNMKzh0UVNBMnFuMFQ3aE1GWDBlbVNweCs1WTAyM3NTVGM5dHR6cy9PZisxODRQWkNvK2RMakZUOXRYL095ZTNVU3VCc2dTQWtQNnBVL1FzejgyVStlNlpFaDhjN2JWTyswNUJLQUxReGN5VWZSNDhXZVRsK1NvZGRldy9Ydk9mTUhJYnRSTEkwOEhQQVplQS94UDQ5eHBTeEZxWkxQZzhORm5pMVp2VFhGcy9FaWdVQVdnVmdiVThjYWJNRTJkS0xGUUNGWWdJa3lOMDZtTkE0d2RIcXdmR0puNC9XZ0lnVHVPZjZVcnp5NzVsZkxyTU4wOFYrZmkrQkptRWZKWWlBSzFqSXVmeDRNa0N4M0llVnYxZlkzVzRlWDBSdlFZb1d1Y0I0dEd2enBWOEhqcFY1TmJoRkcvWW10RU1XUGEzaElJWDhJMlRSYjUzcnR5WlYvNXFxMTdVclA5TG9Db0JvQjZnM25vSm5vVVg1eXA4K1hpQlBYMkpwaDBMMUI0QVJRQlc2bTNqTXhXK1BWbmtYTWxYLys5TSswTXExSFVuKy9ENHdkR1dOalpGQUtSL1kwR3VHcGpIcDByczdVL3lrM3Q3NlUwNnFqOUZBRUpqcXVEeDFlTUZYcHlyMExIdi9lZ1VRTlFVVHN1UkFPajJhVTVNdXBXMTJLbWlaNzU2UE0vdTNnUnYzNW5Ca2Y5U0JDQUV5cjdsVzVORnZuT21SSzVxMWYrVjIxYmcwUVgzQU5ob1ZhVEd2ampoVzNoNXJzcTlSM05zelRyczM1VFdERmoyTjUzblpzbzhlS0xJVkVIMy9YZDZGNGhRWG5MZEVBRW9BZjhDK0g4bEt0WDgxOVdBZk10VFo4c01wM1AwSkJ5dUcxai8wVUR0QVZBRTRFb21DeDVmUGw3ZytXNjQ4VTgxSHlVSDhBb3RQZ0hRY2dGUVB3cjRoOUVSQUdyKzhSa0VMbVowdmhydzBLa2lmVW1IaisvclozZWZWcklVQVdpQ3VQUXNENTBxOHRoVWlZVnFvUDR2dGRKS3htanhDWUIyUkFDRWFNcG9OVk1PK09yeEFpblg4RlBYOWVuQklFVUFObGdXOEwzcE12ZWZLREJaOUZRZ1VpdXQ1dk1TQUVLaWVvMjV0Y0Nab3M5OUUza1NCajZ5dDQrZERZcUFPRG0vTVBJcTUzK1Jvd3RWdmppUjU0WFpDbDZnL3Q4bHVZMUtDVmhncXBYUEFFc0FpTmp2QXJiVUhnejZ3a1FCTDZpSmdHc2FXQTZJMHd3NGpMd3FBbERqZkNYZ3F5Y0tmT2RNaWJ4bjFmKzdKN2RSS1lGcXU3NDRvYVluNGt4ZzRWVGU0d3NUZWNxKzVTZjI5ckZ2VUc4R0tBS3dOc3ErNWR1VFJSNDhXWWpJaFQraUM1bW1XKzRCc05hV2dIOEsvS2MxRGxNWHlzWmFhMWY4TWRaU2pKZi80SXBwcm4wb3ZlcUxONVR1NHNCOFJScFhwR21Xc1hhWno1ZisrSkkwMTVIZThnVmVUOVl1a1lKWnZwYk1paFc0VEprYUMvWjAwZWRMeC9Ma3FnRWYzZHZIcXphbFdNdXpBVmVtYVl3eEc2bTdSYWZhbkhaMWVYNmFrZVpHN1Z0cmV1djlqcFh5dDFLYTZ5MzM4ZW15L2VKRTNoeVpyMXIvcWwzL1p0M2o4dEw1V09NZ3RjeVBMWi9tK3F2ejZqVFhQSkN1UFYxamFwc3NHaGxBbC9qOFlwcXI1bkhOWTlubGFhNGh2VFdPWmRZdWZtN1hrci9EdE9FRUFPMmFoUjhZbXhnRXpqZmFvT0lTQW8xTFhqdlIvdjZrdyt0SDBueGd0SmM3dDJZWVNEa3R0ejhrNGF6NmIzS2FoK2VyOW4rK09HOGVQRmtrMThSZC8rci9zYkdmTUxyL092TDZNZURlOFlPakxkOTlxajBBSWlhc3JUOHRWQU1lTzEzaWJNbm5STTdqWGJ0NzJOT1hhS25TMWRwNjlEbGI5UG5DUko1SHBrcE5kZjRpVmtSbEtmcUJkamgvQ1FEUlhtL2RXRjgxYTAyMjVGdGVtSzB3WGZJNW1xdnkzdDA5dkdaem1yNHIzZytRays1Tzh0V0FCMDhXZU9Ca2dXbXQrNHYyam45dGJZRHQzQVNvallCUzFxR2w2VnVZTFBqY2Y3ekFzUVdQdDJ6UDhOWWRXYTRiU0pKMGpHYnFYVW8xc0R4NnVzU1hqdVU1bWZPd0toTFIzdkZ2QWRyWEROc2xBRXJBUHdIK3M5cUtDSk9DWjNsbXVzeUp2TWZ6c3hYZXZEM0xIU05wcDVzUWNRQUFJQUJKUkVGVWR2VW1jT1g2dTRyQVdwNCtWK2F2aitUNDRma3ExU0NjTldEUmtUUDFzSGljMmtOQTNWVUFqVzRFMUNZWTJiL1JORk9PWVh1UHkvNU5hZDY0TmMxck5xZnRydDZFU1RkWkNhaitvNW5YNTJjci9LOFg1L24yWkpHOFo5WC9aWDhVN0g4djhPRDR3ZEcyTEFWb0Q0RG9HaXFCNVZqTzQzVFI1L21aTWpjTnBjeHRtOU1jMkp4aWIzK1N2cVRSRThNZHlwR0ZLbjk5T01kanB5Kzk3RWQxTGRxS0JiN1RMdWN2QVNDNmtySnZtY2g1bkNwNGRueW1iRWFua3R3MG1PVFc0UlRYRDZiWTN1UFNuM1JVVUIzQ1pNSGozaU41dm5HcXlGd2x1R0w4bFFnUWJhUFk3Z3kwVXdCWVlBclkzcjRzeEtuemQvZEFaV2orMUx6aVd5WUxmajBpVU9IaHFSSjcraEpjTjVEa3V2NGt1L3NTN094eDZVczZaQk1HdDQzUkFXMVdYQitMeC8yK2VrSTcvbHM0cUppdXR0K3NPZDBUdE9rQ29DZ0lnQ0x3NjhDZnRsZUR4S1d0ZHZkc3hXSnRHQ0lBYXRjSkwxUURGcW9CUnhlcWZPOWNtYUcwdzBqR1pWdldaU1NiWUZldnkwaW1KZ2I2Ni8vZmt6U2tuZHF5UWNLQmhBa3JoenF4c0I1bVNyWGJJYjl3Tk05a1FUditXemlveEdXd0NpZWZGcnRHRWZCblFLVXJCY0Q0d2RIcWdiR0plOVVIUlpSbUFMNkZ1VXJBWENWZ1lzRWo0VURXZFJoSU9mUW5EUm5Yb1RkaEdFZzU5Q1VkMHE1aHREL0JtN2RsMmRXbkZiV29jTDRTOEpYakJlNDltdWQ0M2lPd2NaNm9pZzVsckdzRmdCQnhtQUY0QVN3RXRlakFwVzRqNFVCdnd1R1c0UlMzREtmb1NScTVrNGd3VndtNC8zaWV2ejZTNCtoQ2RSbm5INmVKcXVoQWZPQnNPNTRBanBJQXNOVE9RRXFJaUZpcGh2Nmt3MXQzWkhudm5oNzJENmRYZkhOQXROYjVmL1Y0bms4ZnpuRjRvWXF2dUw5WW5uYXF2N08wZWYwL0NnS2dDUHdqNFBmVUZrVWNTRHF3YnlESmUzYjM4STVkdFhjR1VvNW1rWkdaK1orb09mOVg1cXQ0dXVKZnJLN2wyOVY1L3p0UTdtWUZCTUNCc1lraFlIYlZtdEpGR0hHeXYrazNyRVVoelUxcGh6dTNaWGozN2g1dTI1eG1jOFpWL1Vja3I3TmxuNitlS1BEWERUaC85WC9aMzhieDcwYmdsVzVmQWhCUzFtdlZxbTE3WHlEakdtNFlUUEtqdTNwNDY0NE0xL1FsU2VzZTRjZ3dVL0s1NzNpZXp4N0pjMlJCTTM4UitmR3ZTZ1RXLzZNaUFBTGFmaCtBNkVwTnNRcU9nZTNaQkcvYW51RWRPN084YWpqRmNNWmROUmM2cnRjNnpoWjk3anVXNTNOSDh4elZtcjlvY0ZiUnB1K2RJQUxyLzFFUkFFWGduMU03RXlsRUpCaEtPN3h1YzVxMzdjeHkrNVkwTzNzVEYxNFJYRldxNk14K1N6aVY5L2o4Uko0dkhjdHpJdWZKK1l2b3p5cHEvQWtSV1ArUGhBQ28zd2Z3UmJWRkVZVVpRRy9DY010d2lyZnR5UExHclJtdTZVdlFxMnVCSThlUmhTcWZQWkxucThjTFRPbVNIeEV2MGZGcDJueitQMG9SZ0hhck1hRVpBTm42T3YrYnRtZDR3OVlNK3dhU0RLVmROY2lJNFZ2TEM3TzFoMzIrT1Zua25LNzNGZkZpbm9pcy8wZEpBT1NCWHdFK29mWWgxanBiYndZOUNjUDFBMG5lc0RYREhWc3pYRCtZWkZQYWFldTkvMkpwS29IbHFiTmxQbk00eCtOblNzeFh0TnV2bS9wcWgrVHpVV3FiQUZWUmw3TC9ucVBEd0hTSGRRSzd6citiUzJhb1MvM2JTdWxvOEZsRE9mY2xIVzRlU25MSDFneXYzWkptMzBEU2JFcTdkbkZ6dnpIR1dHc3YvRjZqZjEvdjd5MlhUdGRXWnIwOGNsN0FvMU1sODlramVmdjk2VEw1MnMyTWErMHo2amZoalZVcmxXV3owbWswM1NqemJ1Q2J6OTE5YlNSQ1Y0a0lkZlFWQlVrTXo4RXVaYys2LzE0L1cyclcrSHRSc0wvSmRZVTFhNzl0ZDhueWNRMXN5YmpjUEpReXI5MlM1cll0S1h0Tlg5SU1wUndTenRYMWRhVU5hLzM3bGZhdk41MVcxRlVZTkR1dlUwWGZmTzFFd1g3bGVJR1g1NnFtN0Y5MnpucWx2ckJpUDdtaVQwVzgvWWVlWmpQSHFtYW11MXovMy9BWTJJYnh6d2VlSGo4NEdwbDFxeWp0QVFpQVNXQ0hCSG0zeFgvVzFLM1duZUdzYTdpbUw4R3JOcVY0M1pZTU53d20yZEdUWUNCVmU4bXZXNG02cUxBV0RzMVgrZnhFamdkUEZEbFYwRTUvOWY5WWM1U0lIUCtMb2dBb0FQOE0rSFAxQVBXcGpaSnlERnV6THZzR2tyeDZjNHFiaDFLTTlpZllta21RU1JnMUFLSjlYMEhKczN4dnVzem5qK1o0L0hTSm1YSVFRb3hYL2IvTGk2RFYxdi9MdXArVEJseUtBMk1UbTFobUg0Q3V3cFQ5cTZXWmRHQWttK0Q2Z1NUWER5YTVaU2pGTmYwSnRtZGQrcE1Yd3Z5cS80amJmN2JvODlCa2tTOGZ5L09EMlFwNXo2cjl5LzY0MjIrQkxlTUhSMmNVQVZoWmsrcDFRQVZBMXB6YnZxVERybDZYM2IwSjlnMGt1V0V3eFRWOUNUWm5YSVpTRGlsZDJSdWJDRUJnTFMvUFZmblNzVHdQblNweUl1OVIxVVovOWY4NDV2WnF6aEN4OEg4VUJVQWUrR1hnRDlVN1d5UzM0dE90ckdzd3ZVbUg0WlREcnQ0RTEvUWx1S1kveWQ3K0JDTVpsMDBabDRHa25INjdaMERyWWI0UzhOVFpNdmNkeS9QRTJSS3pvWVQ4Ulp6N2Y4eEZ3TzhESmFtcVZWaHVHU0FDTzh2Yk9yQ0drZGVvaGdBTnRSMzdhZGV3S2UyeXJjZGxVOXExMjNwY005cVhaRnVQeTVhMHkzRGFvVC9sMEpNd2tUcTNINmR3WmJ2dHR4WW1jbFh1UDFIa202Y0tISnF2VXZRczZ2L2QyLzliYUQ5aGRLa2w4bXFCbTRHWG8zSUJVRlFqQUl0b0dTQ0M4aS90R3JabFhheUZ1V3BBeWJOVUE5dndUTTBBU2NlUWNpR2JjT2h4RFptRUllczZiRW83akdSZE5tZGNCbE1PSXhtWGtheExiOExRbDZ3NS9JenIwSXhKZnJmZjJkOXUreGNxQVUrZksvT1Y0d1dlT0Z2aVhNa24wTFMvaTZkL0hSdFZPQU9jaVpyemo2b0F5QUcvQlB6M3pxbi9pT2Exd1NSVGp1SDZ3U1MzYjhtUVRSak9sMzN5bnFYc1czeGJXOFAxYmUyNjFzRFdrbllNdU1iZ0dIQ011VEN6ejdxR25vVERZTnBoSU9XUWRRMHB4NUN0Ty9xZVJPM3ZLZGZVTnUrRnBOYTdldnh2VTRGNmdlWElnc2ZYVHhiNDFtU1JRL05WQ3A3dGpEN1Z3ZjIvTzN4MUtIbjlCQkVNLzBkV0F4NFltOWdNbkF0N3RxSmRzSTJsbVhSZ2UwK0MxMjFKODQ2ZFdXNGVUcEYwREg0OUNoRFlXa2czd0Zwck1SaHdNQmdERG1CTXJjRWxuSm9RU0JoRDBqVWtuWm80TUIxUXBwMWMvODFJOTF6SjV6dG5Tbno5WkpIdlQ1ZVpYdU9zWC9VdisyTnFmMlRELzFHTkFDd1dtcFlCSWliL3FnR2N5SG5NbGdNbUZqeCtaRnVHdTNabXVYRXdlZGtSdXpEVzFzTG9xTjMrWkc4cjdTOTRBUy9NVm5uZ1pJSHZuQ2x4SXVkUjBxMCttdjYxTjdldEtJSFRST2p4bjdnSWdCendpOEFmcVFlRUxMTk00NytTcXdZOE8xUG1lTjVqZktiTVczWmtlZE8yRE5mMEpYRkNLdEp1MzFnWGx6Szlrc1Z3Lzdjbml6d3lWZVNsdVNyemxhanM4RmYvNy9KVEFLMG9nWDlTOTJmU2dJMXc1VEtBUW1EUlREUGh3TmFzeS83aE5HL2ZtZVdPclJtMlpkMnVGZ0E2QlZBTEFVM21QUjQ3VStMYmswV2VuNmt3WGZKWjcxSy82ajlXOWpjOUFoalQrdmVCYmVNSFJ5UDd5RjJVUSt3QmNBcllpWWlzL1BNQ09KWDNtUzdWTm5NOWNhYkVXM2RrN1d1M3BNM21qS3N5N3NJSXdIUTU0S2x6WlI0NlZlVFo2VEpUQlorS3R2ZDMwL1F2aEpsMUxLTTFSK29pSUxKRVdRRGtnRjhEL2tvOU5mcmR0T3hiRHM5WG1TeDQvR0Myd29ITmFkNnlQY05yTnFmcE5pRVFsNWw2TS9OcGJXMkQzelBUWlI0OVhlTDcwMlZPNWp5S1d1ZnZpdjZ2ekM2cFZuNmQydVYyWGFnQm04Q0JzWWt0d05td1ppc0tBWVpqdndIYmt6Qm1UMStDQTV2U3ZHbDdobGR2U2pPeWdhVUIxWDkwMHp4WDhubm1YSmxIVHBkNGRyck15YnhuODU3VkxuRFozODMyVjRHZFVRNy9SejBDQURBUC9GMUMzd3pZcFlRay93SnJ5WHZ3NHZrcUovSWV6ODZVdVhVNHhadTJaWG5ONWhSYnMyN0R6L0FhWFFJUXFRaUFGMWpPbG55ZW5hN3cyT2tTejgyVU9WWHd5RmN0Z2U1czZPcityOXdDY0E5UVZxRTJLUW9nQlJ4Zit3MlFUUmgyOUNTNGFTako2MGRxU3dQWDlpZElydkhZZ09vL0dtbFdBOHV4bk1mVFo4czhlYTdFaStlclRCVzh5eTd5VWZ1WC9iTGZ2QkY0YXZ6Z2FLU2ZzNHJMT1hzUDBJNnltR0tCZ21jNU5GK1BDRXhYMk51ZjRIVmJNcnh1Sk0yK2dTUURLVWNGRmVFSXdId2w0TkI4bGU5UGwzbjZYSmxEYzFYT2xuektXdU1YNGtwT0E0ZWk3dnpqSWdEbWdiOEgvTEhhVmJNOVFPdS9zdXhiVHVROXBnb2VQenhmNWR0VFJXNGVUdkdhelNuMkQ2ZlpsblgxbWwrcmhOa3FNNkNLYnpsZDlIbmhmSVh2blN2endteUZFL25hUlZCVjdlcFgveGZMOFkrQUJUV0JKckgvbnFNamRWVzFSUGF0cVU4eXIvZ0hZNi8rZVBGeldQcmZzQWJERmMvYjFOTy83R3V1K000TGYxMGlMNnYrMjFXZjF5N1BCWXUxUzlmWlNyWXRiZGNTWDMvSkI4dmJka2w1TEdFenk1VS90WXQvN2FxZnU0NmhOMkVZeWJobXREOXBYNzA1eGFzMzFhSUN3MmtIWTR5eDl1cDB1dTN6bFdieHpmN2UyVXJBSzNOVnhtZktqTTlVek1SQzFaNHArdVNyRnQvKy8rMmRlNHltVjEzSFAyZmV1ZTIxRjFyYTB1cTdFRUtNN0NxSmlhQW1FbEhBV0NnSTRkMFNrU0RheHRBV3FKRkVRMXVRY0lzR1RRVWhpbTJGVXRvWmxFdlFSUVNFQWlLMEJaRlpRU2kwdTZYdWJyZGxMek03dTNONTMvZjR4L1BNWHVmeXpzejd6THpuZVQ2ZlpET3o3ODZjUGIvblhIN2Y4enUvYzU3WTRYaFp2Rit0WkZ5c2NNd3NkMXdzZDh3c05GNldPV2FXUFpjdGFWdUhjOWs4ZHJGQTI2eXN6UUloZEg4dVk0Ryt0Wks1Yk1rKzE5RmNsak1MWEw1NzU3WW5VdkN0U1d3QmhCREdZNHpYaEJEK2ZnRU5FeGJvWEl1SW5qRGZDaWpNZFpTRmZtZGg4WFJxeS92Y2NzTWlnbXZCK3ArYzFPWlpyUzFpMitJMm43VUNQQzBNdkxCdFlabjF6K282TjBEbWI5RzU3OW9SSm1ZakU3Tk5manpaRExzUHovQ2xqU2Q0NnRZQm5ubitJRDk3d1NBL3ZXVWdiQjBJNTZ4V0YxcTlkdnI1bk1OYmJUbG5mMzVPRGtRWHlsOXN0ZDZOZW83UHROa3pNUnUrZjNTVy96azB6WS9HWjlsL3ZEVzMyai9kRnBZYUw1MzJxK1dNaXpQdDcyek1MRFV1c25vdWI4eWMrY0VDOVkrY05WWTdIZk1MejJYeHpESTdIdk9MeldYbnppbWR0TTNTYlRaZlh3MEx6Z1dkeldWNW1RczkvdzQvUDNNdVcyQ2VYbkxPV3VMemUyS01QZm5pbjZTRFFOdEg5bHdjUWppNGxpSFFYaXEzU2tsQUFSanVEMXd3Mk1kbEcvdDUybmtEL016NWd6eDk2d0JQMnpyQTV2NUFyUXQzRGxlNS9adnR5TVJzTys2WmFJWUhqODd5Z3lNei9IQjhsc2RPdERnODNlSkVNNjc0dWw3N3YvWlgxUDRJUER2RytNM2RPN2YxL1A1L01oR0EwK2N0ZkVGUTZZbkFpV2JrUkxQRmdSTXQvdmZJREY4N01CVXZIcTZGYlZ2NmVjWjVnenpqL0FHdTJOVFB4UnRxSFo4a3FEcHplL3FQSEp2bFIrT3pQSGgwbGtlT05UbDR2TVdSbVRiSG03MXlSNzlJa2p3R1BKU0s4MDlOQUJ3bHV4UGdEdnRaZFdoSG1HeEdqczNPc20reXlmZVB6UEQxZzFOY05GempzbzM5UEhYTEFOdTI5UFAwclFOY3ZLSEcxc0UrQlVIT2RDdHlkS2JOWXllYVBEUSt5NTZKSmc5UFpNL3g4SFNiOFprMlU2Mm8wNWR1VTlVQitBWVNTZjVMc3FGMmpPNjlHT2phTm9BaHNIVHREOEJBWDJEVFFHRHJZQjhYRGRXNGRHTS8yN2IwYy9tbTdNOVBiZTVuNjBBZi9YMWgzcmNVbHFuOVd6RXkzWW9jbm03ejZHU1RmWk5OL20reXlaNkpKZ2RQdERnMDNXSjhwczFrTTU3TTRJL0V1TWplYkFYNlB6RUVIUC9hM3cyT0E5dkdHdlhIVS9LcHFZWFR4NEhYQXJjcnNxdE5CR2Jha1pucHpPazlNdEZrc0RiRDVvRStOZzhFemgrc2NlbkdHay9lVU9PS1hCQmNORnpqd3FFK3poL3FZN2lXN3IwRHJSaVpuSTBjbXM2UzlKNll5c0w2KzQrM2VQeEVpNE5UbWJNL050dG1jall1L0NLZXRGNEhXMUF2TWxva1hlRXY2UEY3LzBzUnF0a3h1dmZKekhza3NPd3JnTzdYTmEwVndQTHNuNHNRRE5VQ213Y0NXd2I2MkRMUXgwVWJNbEZ3NFZDTkN3Yjc0aVViKzhPVE45VFlNdERIWUEyR2E5bnYxRlpSL2RYYTM0NlIyVFpNdFNJenJjanhacHVmVExmandST3RjR2lxeGVHWkZrOU10WG5zZUpPaithcCtZcWJOWkxQTlREdlNhdE5SV0wrNDlrK2pyN29DMXY0dWxka0NuZ244WUt4UlQycEhMY1dFdXFQQTc5R1ZYSUNVVmdCVlg2M0VzQno3VDBZSTJwR0pXZGhQaXdBTTFnSkRmWUhCV21DNGxtMGhiTzd2WTFNZU9iaHdxTWFUaG11Y045akhodjdzWnpiMjk3R3BQN0NobG9tRW9WcjIrNE45Z2Y2K3hXcHd1bE9IVmh0bVkrYlVwMXVScWZ6cmlXWmtzdGsrK2RuNFRKdEQwMjBPVDdjWXoxZnhrODNzNjRsVzluTnpmMVoxRVYrd3I0cDBnYnVBZmFrNS95UUZ3RmlqUHIxamRPOHUrMXoxRk1CcXZVcUVrNDZUMlpQbjFRR29CZWp2eTV6NmNPN2dCL3FnRnJLdkEzMkIvaENvNVovVlF2WTdZWjZsYmlTZWNmNDZucmF5YjBkb3hTeU0zMnlmK2pyYmpqVHo3MmZhV1Ixbld0bCtmU3VTWDJBU2V1eUpwbzRpUmJveWl0NUhndUgvVkNNQUFHMWdIL0FVKzU5MGcxYUVWaTRPSm1aWE9TTVU4RGE4R01FWDdCbXBrSjdqdjBqazN2OHlDWUNqd091QmY3VC9pYmdBRmxrbkJYa1RXWEs2VThCYXNtTjA3eVhBbzZzUk1TYkJhTC8yYTcvMmEvOEtPUUQ4WEdwSC84b1FBUUE0UW5ZazhNTUtVUkVSV1dOdUlJdEdKMHZTUWNEVlJnRlV3RWtkQSt6NkhuaUI5aGVRQTFEQU02MzhSVUNPZisxZmNabkpyLzVUandBWUJhZ1VTYVhCcFpGZFpnNmNTR1ZYLzVSaCtPOFkzWHNwOE9PVmlCa1ZzUFpydi9acnYvYXZZUFgvODJPTitrRVNwd3h2MWp0TWRqSFFuWXBTS2Eyc1RxVk1rV3FzL284NFZTVWVCVkFCYTcvMmE3LzJhMzhWVi85bGlRRE1SUUZlQTN4RWNTb2lJZ1Z4ZlZsVy82V0pBT1JSZ011QVI1WWphbFRBbmdMd0ZJRDlYL3UxZnhtci8yZU5OZXFQVVJMS0VnRWd4bmdvandMY3VkeE9zSWc0aXF2cFhGMFFabkdlTWxkVnIvbWMxVExMNitqL1g2WDlDNHFBMWRhcndQWS80K2U3WUg1WWsvWm4yUlZkeC9aZnRNeDV4OHdhMXZQczlvL2Rta3U2VU5jRi8vOGkybWtaNVM3cnVYUlFaaWk0L2E4bml6YVhobEtsQWVXdkN2NFdjTGtLV1B1MWYrMGpGYmEvOXBmVS9tOEN2em5XcUQ5UkpwL1pUN2s0UXBhaCtmRUs2cCtLeXo5WmR2T0hVUEdiQUJ6LzBwbFdJTHZ6LzZoZG9QZWpBSmZrYW0zSktJQUtXUHVOQUJnQjBIN3RyK0xxdjR3UkFNajJhSllSQlJDcDdCTFF1d0JGRnFjRnZMbU1xMy9LT3ZoM2pPNGRBbDdCRWdtQmxWZkFhV1dCSjVGWm4xajdFekFDNFBoMy9DL0NIY0NOWTQxNktRVkFHU01BakRYcTB6dEc5MzZ4WFBxbmdMb210ZjVMYWJXYVNEVmpLRVlCSk5PcEhQK08vMFU1RG53QU9GYlc4RVkvNWVVSjRGVjRPWkJJR1R5Z3lGcnpMdUM3WTQxNlN3R1FaaFRnUzBCellUdFRrc0FGMURXcDZiL2liVlhNb3FxZ055eW0wbGFPZjhmL2d1d0hQcFpIQVVwTG1TTUFjMUdBVndNZlZjeXU2Wmh5WlpsRSs0ZGdTem4rSGYvemNoM3c4RmlqSHN2Y0JVby8vUE1yZ3U5bm5tT0JIb1BSZnUzWGZ1M1gvck40QUxpeUxDLzhxWElFQU9BblpGYzRmc0tGYXRMbXUxYnQraE1ORGdETnQ3Wm5NbmZzNzdCZG9EeFJnQ0hnNWNCZEttRHQxMzd0MTM3dFg2RE10d0IvT2Rhb2x6Ynp2Mm9SZ0xtRXdLK1EyTUVYT1YycGhyU3FtMENaZ2VCWUVNZi9LWTZRSmY1TlZ1VzU5bGVvRHgwRWZnY1RBb3QxVXdWUjFLVTFoVlczKzArMzYyWEdVTXhGTU9MNFQzRDhSK0FhNEtHeUovNVZVZ0RrVVlCN2dVZUJLeHo5R0ErcGZQdDdDc0R4NzJQSStTendwYkZHZmJwS1J2ZFhySkdmSUVzSS9LVDlYYVNvZXdCRWttS1M3TktmSTFVenZIS0RQMDhJZkJud1VlOEM5eTV3M3dYZ3V3QWMvNVVmL3pjQnQxWWw4YS9LRVlDNXJZQXZrMjBGWEU2VlNTc0VhTUN5NjA4MFJOd0VjUHhYdTdZUEFLTlVLUEd2MGdJZzUzRVd2QnRBWk5Vazh6WWdOWlZVbUZteU0vOTdxcFQ0bCtCRTFYMTJqTzRkampHK05JUndkOWVuVlVPQUJkamYvWlExUThERktBQzNBQnovaVl6L20wTUl0NDQxNmhOVjlZTlZqUUF3MXFoUGJSL1o4eFdxZkNvZ3FidkEzUUhvL2lQMUZHQzEyNy9TNC85K1lJUVN2K3BYQWJBMGo4Y1lyNk9BVXdFeHhrakkrKzNja09qMCt6bWxtMlZwbmZ6M0dHUHNxWG91OG4wQlZTVVNZd0gxTENUMGQ3TGNiajNib3RxZmVHcHU3ZGF6TGJLdkxuUE1yRWM5dXpEK3ovUjVqdjl1ai85WllyVkQvd1VxdGJUWU1icDNHSGdwY0hjM0I1VWhVRThCOUh5WmFXV0J1d1dnL2QwcTgyYXlyUC9LaHY2TkFPU01OZXBUTzBiM2ZoVXZDT3AxM0FQd2lZcXNGa1AvQ29Cek9FajIvdWRQK1NoRXFvTHFwMkpNZ3FGL1I4QTg1RnNCTHdIdVdmWEN5aENnOXJzRllQdHJmNitWK1FyZzAxVzc3bGNCc01ZaXdHTndWYmMvamJwcXZ3S2dRdmJmRHJ4cHJGRS9wS2M3aFZzQXA1SG5BOXhQVCs2T1ZuM0ROaVg3YlN2WEZ0SkQ3QWMrQUJ6MVVTZ0FsbUlmY0RWWm9vajBEbm9VbjZnUFFKWkxFL2hENER0ampYckx4K0VJV0pKOEsrQ3FsWW9BUTREYXIvM2FyLzA5VWViTndGK1BOZXJqZWpZakFCMlJid1Y4SFk4R2lvaWt5bWZJN25lWjhGRW9BSmJMQWJLamdaL0VTSW1VRVh1MWxKZjl3RHVCdlI3NWN3cFlFU3ZkQ2pBRVdIbjdrN2kxMFBiWC9wTGEzd1JlRG56V0kzOEtnRFVYQVU0QUhvTzAvYlZmKzlldHpKdUE5N3J2dnpSdUFTeEJuZzl3SCtZRHJETyt1MTc1TC9hc0pia04rQWp1K3lzQXVzZys0SFhBeDMxbTY2Y0FkRmsrVWJGbkxjS0RaT2Y5SDNYZjN6VkFWOG0zQWw0RWZHekozbThJTUJYN0tjQjgyMS83dFgvdDZ6cEpkdFh2RjhZYTlSazlsZ0tnS0JId1ltRFVDVUQ3azdmZmR3SFkvOHRoZnhQWUNmeUxTWDhLZ0hVWEFVNEFuZ0x3RklEOVgvdlhyTXliZ1BlTk5lcGU5YnRNM005ZUpubFM0S2VCeGxLUkFLbXNWblYzWFdSdG1FdjZNK1BmQ01DYVJnS2VCdHpMUENjRFhBRVVzZ0pPb3N5azJ0OHRBQ01BYWR1L0MvZ1Q0THZlODI4RVlLMTVsT3hrd0tjVVVtdXlBazZsVE9NVUlzV3pIM2czOEQyZHZ4R0FkV0g3eUo0OEh5Q01aTE5wdDFvbHpNbmVMamQxTEtEcldNZWs2OWpSanlid0hNczBacGIxdUNzNVpvNERWMFA4M082ZDIwejZVd0NzSC9NbEJSb0M5QmlnOXR2L3RiK1FNczM0VndEMHRnaHdEOWdKTUkzMkwrWjZSZHZmOFYrUS9aQWxYLy96V0tNK3BlZFJBUFNrQ0hBQzFINGpBTGEvOW5lOXpGdklqdnNkMGVNb0FIcFdCRVRpU0xlVmRSR3J0VWdrVUlnRDZMNWpLU0JoclRBSFNCSFppc1cwVlJHazh1S21JdXBaMU1yYThjOU5CRzRIRG5qTnJ3S2dsMFhBMHlQeGk0RndoUk9BQWtBQm9BQncvSythWFVUZVNPQ0hPdi91NGpIQTd2TmpJdGNRK0NEZGZIdGdqTkI5cDFxVVYrbTZEeXhvdjdLWWczQ0ZYRnJRL2JZcVNnQ2xjNzZ3b0hvV29nQXJPLzUzQWJkRTRzTzdHOXQwL2tZQWVwL3RJM3NHUXdqUGcrNkpBSk9BM0FNMUNkRDJyOWo0M3dYY0F2ejNXS1BlMUxNb0FKSmh4K2plSWVBRmRPa1Z3azZBSnNGcHYvMi9RdmJmQjd3QmVFRG5yd0JJVlFRTUExZVN2VUk0T0FGb2YyK1ZXZEFldVBiYi8xZFg3ajdnZDRHdmpEWHFzM29TQlVEcUl1QkZaSGNFaEo2YUFOTGFBa2ppRFh0Sk9ZRGlrc0IwZ0c0QnJMVGNmY0FmQVAvdVJUOEtBRVdBRTJCaHF6VWpBSzZBallEMWxQMDZmd1dBSXNBSk1OMm9ndmJyQUxWL1JlWHEvQlVBaW9BMW5RQThCZUFwQUU4QnVBV3cvdmJyL0JVQWlnQW5RTzAzQW1EN1Y4eCtuYjhDUUJIZ0JLajkycS85RmJOZjU2OEFVQVIwMGc1dUFSUnlDaUNsRlhCQnQvYVJpdjBLZ0hLTmY1Mi9Ba0FSMEtrSWNBTFVmdTNYL3BMWS93UGdCdUJlbmI4Q1FCRUF6d2ZlenlMWEJqc0JlZ3l3Z0dkS0VVRUZIYUQyTDFMdUx1Q2R3UDFqamZxTUhrQUJvQWpJcmczK05SWjVkNEJiQURvQTI5LzJUN3o5dmR0ZkFTQXJFUUZPZ0diQkd3SHdJcVNFeDcvT1h3RWdpN0Y5Wk04Z1VDZndMR0FFWDM0cGF6RUR4SkxZZ2JiMEtEZVQ1VGs5dkh2bk5wMi9Ba0NXaUFZTUF5L09CNDBSQU8zWGZ1MVAwZjZZci9wdkF3Nk1OZW91YVJRQXNoSVI0QVRveTRETUFYQUxJS0grM3dKZUNYd2VPS3J6VndESUtrU0FBa0Q3dFYvN0U3Ri9Nb1R3YW1EWFdLTSs1VXl1QUpCVmlvQVlHYW4yTWJpVWpnR21VVmZ0VndBVVlQLytHT08xSVlUUGVjWmZBU0JkRWdFeHh1ZUhFQmE5SzhBSlVQdVhWYWJIQU8zLzNTMXpGL0R1R09OOXUzZHUwL2tyQUtSYmJCL1pNeGhDZUI2TDNCWGdCS2o5MnIrK2tZb0t0Lzl0d0szQTl6em1wd0NRWWlJQmc3bnovd1ZPT3lHZ0E5Qis3ZGYrZFNxekRid0Z1Qk40ZEt4UmJ6bFRLd0NrV0NGd3pqSEJDa3lBbmdKd0MwQUIwRnRsVGdLdkJyNEFqSnZwcndDUXRSY0JJeXR0UnlkQTdkZCs3Vi9ocno4SXZBSGY1cWNBa0hVVkFVdStTTWdKVVB1TkFOaitYU3h6Ri9BTzRBRmY2S01Ba1BVVkFZUEFVNEJmektNQkpaMEFmUnVnRGxENzE3bk1KdkJXNEI1Z3I4bCtDZ0RwcldqQVZjc1JBVTZBMnEvOTJ0L2hqeDhHZnA5c3YzL0MvWDRGZ1BTbUNIZ0I4RGQwc0NWZ0VxQmJBRzRCYUg4SFAvb1o0TjNBTjl6dlZ3QkliNHVBUWVBeTRObExSUU9jQUxWZis3Vi9rUitaTytKM040YjhGUUNTWERSZzBTMkJBaWZBSkZick9nRHQxLzRGeXpUa3J3Q1FFb2lBQmJjRW5BRGRBbkFMUVB2bithZlBBTzhDN2pQa3J3Q1F0RVhBSUhBcDhFdGsyYnRKVG9CRUl0VStCV0FPaEFLZzZESm5nRmNCWHdaK1lzaGZBU0RsaWdaY0Jkd0Y5RHNCYXIvMmEvOXBaZDRQdkJuNHNxdCtCWUNVVXdRTWtTVUlQZ2U0MnhXd1d3QnVBVlRlL2hid05yTG80SjZ4Um4zV21WSUJJT1dQQnJ3a3huaTNFNkQyYTM5bDdYOHdoSEFqV2NqL21JbCtDZ0Nwa0FpSU1WNGFRbmdPMlRFZkhZRDJhMzgxNnRvRy9pekdPQkpDZU5qcmZCVUFVbEcyait3WkJsNEtmSFRwcmhMbjZUcHhrWjlaU1hmczV1OWJSK3RvSGMvaUFlQW00RCtCWTd0M2JuUFZyd0NRaWtjRGhzaE9Ddnp5MGtMQUZXQnA3RGNIb0VydFB3TzhIZmY2UlFFZ0N3aUJZZUFsd0VmSVR3cjB6Z1NZMHN1QTBxaHJqQlRnL3BPeXYrdjE3Tkc2UGtDVzRmODFZTks5ZmxFQXlHTFJnRXVBWDFscE5FQUJVSFVIcUFEb2ticE9BcThGN2dVT3Vlb1hCWUFzUndqOEp0a3RncGV2L3dUb01jQUN0Z0Fvd1ArNUJiRCtkVzBESHdJK0FIekhjLzJpQUpDVmlJQkI0RW5BYzRFNzZYQmJRQWVRaXYwcHJZQnQvdzdMbkV2eSt3YlpIZjR0WnpKUkFNaHFvd0VYQTc5S2RwT2dEcUFjOWxPQStiYi8rdFQxQ0hBdFdiai9zT0YrVVFCSVVVTGd1V1NKZ2pxQXRPc2FpNWdEaklDc3FmMHp3RHVBVWVCaHcvMmlBSkMxRUFLL0JieVhlZklERkFCR0FHei93dXNheWZiNTN3OThEN1A3UlFFZ2F5Z0NCb0VMZ2VmbEUxRi9hcXMxQllBNUFBbTJmd1MrUlhhczcrdGtWL2k2enk4S0FGbTNhTUNUY2lGd1owcXJWVThCZUFvZ3NmWi9ETGlPN083K28rN3ppd0pBZWswSS9IcU04VU02QUNNQXRuL1hPQkJqdkQ2RThGV3lCRC92N2hjRmdQU21FSWd4WGhoQytBM2d3NVYwQUFWY3NWdFFtVVlBZXJ2OUR3RFhBMStOeE1PN0c5dDAvS0lBa0dRaUFoZExpM1hUQUFBRG9rbEVRVlFDenlmTEVkQUJLQUJzLzg0ZC93MWtvZjRqcnZoRkFTQXBDNEVMZ0Jlc1JnaTRCZUFXUUFYYVg4Y3ZDZ0FwdFJCNElmQVBLNWhVVFFJMENiQ3NBbURPOGQ5TGx0eW40eGNGZ0pSV0NKeFA5cDZCT3pydGd4NEROQUpRTWdFUWdZZUFQd2IrUThjdkNnQ3BvaEI0SVhBYlM3eG53QzBBTHdJcVNmdTNnRzhETndQM0FlTWU1eE1GZ0ZSWkNKeEg5cDZCVzRHbktBRFdySzVlQmJ4MkVaQVo0RzZ5dDJ2K2tPeEZQVTFuQUZFQWlFSmdkTzhBc0JXb0FWY0N0eXNBakFDVW9QMFBrRjJaL1UvQVBySXJlOXVPZUZFQWlDd2NGZGlhQzRFUEF2MEtBSE1BRW12L2IzUHF0YnpIZ1NudjZoY0ZnRWlIYkIvWk0waTJQUUJ3VlM0R1JIcVovY0NOd0w4QngzYnYzR2FZWHhRQUlxc1VBME1oaEszQWk0Ry9aWW1rUVNNQUhaUlp3T1ZDRlkwQVJPQmE0Rk5BSzhZNHNYdm5OaFA3UkFFZzBrM3l0eEJ1emYvNjI4RGY5WjRBU09QSW92YXZ1c3hyZ1UvazM0OTdqRThVQUNMckl3WmVsa2NHakFCb2Y1Rmw3Z2YrQ1BpOFRsOFVBQ0s5SXdhMmtGMDUvQjdnTWgzZ0VtVldmZ3VnNDBoRkUzZ2Q4SEdnRFJ6ejdMNG9BRVI2VHdnTUFKdUJ2cVhFZ0N0ZzdWK2t6Q1p3SGRueHZaZzdmVmY3b2dBUVNVZ01iTXJGQU1CTzRQMDZRTzFmb016OVpGZnovbXYrZDUyK0tBQkVTaUlJQnZQb0FNRFZNY2IzdVFWUWVRRndQWEJQL2xHYjdLSWV3L3VpQUJBcHN4aUlNVzdLZmNxVndKL1RRZDZBRVlEazY5b0VYZy9jazkrRU9Pa3FYeFFBSXRVVkF3UEFSazV0RmJ5UzdMMEVLN3BySUpWcmV5c2lBR0x1OE84NjdlL0hkZm9pQ2dDUmVhTUR1U0NZNDFYQVgzVXFDTndDV0ZmN0kvQkc0TU9uZmFiREYxRUFpS3hZRUd3NGE3eThKaGNGNlFxQWNrUUFEZ0IvQ254U2h5K2lBQkJaUzFFd3g4dUJkd0tYS0FBS3Eyc0xlQk53eDFrci9oTW03b2tvQUVUV1N4QU1BTU5BMzFuNzlkZVFKUml1YXF4VmNBdmdUWnoyOHFmOG1VYXl0K3E1dWhkUkFJZ2tFU2tZbnVlZnJnYmVCbHhTNFFoQWl5eDhQOThWempwNkVRV0FTR2tqQmtPY09ua3dIemNBYjA5WUFCd0Uzc3FwRFB4emd4Q1pvemQ4TDZJQUVKR3pvZ2REdVZQdDlCamdqY0F0UUcxSlI5MzVGa0FraTFhOHAwTUJNRmZYQ0V6cjRFVVVBQ0t5TnFKaGNKbU91aE5tRE1tTGlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSVNHSDhQOXlrL1pMdEJIdXBBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdHdpdHRlci5wbmdcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUI5QUFBQUlmQ0FZQUFBQW92a2UvQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBZ0FFbEVRVlI0bk96ZGQ1aGRkWjAvOFBlZFRIcFBnSVFRUWlmVWhJNmhDRkpGa0M1Z1dYQVJFYXpZc080SzYrcmExNG9pS3F2OHNJQ0lyb3FLaFNaRkZMQWlDbEtsaEdZSUxVQXk4L3Zqaklwc2tHVG0zdm5lZSs3cjlUem5tU0hjdWZQT3pUTXpaODc3ZkQvZkJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0SmsxU2djQUFBQUFBSURhT09hMEdlbGR1bkg2ZXVZbW1adit4cVEwK3F1anIyZENldnJIbEk0SUFDM1YxM2d3UFgwUHBiL3hjSklIa3R5VC9zYnYwOSs0THFNZS8wTk9lZFZEcFNQK013cDBBQUFBQUFBWXJHTlAzU2lOL2wyVFBDZjlqVjJTekNpY0NBRGEzZS9UNkw4Zy9ZMEw4OFRJQzNQNjBmZVVEdlJrQ25RQUFBQUFBRmdaeDMxNnkvVDF2RFRKd1VsbUYwNERBSjJ0a2F2UzF6Z2pJNVo5Slo4NS91N3ljUUFBQUFBQWdIL3VwSk42Y3Z1c0E5TFQ5L3IwTjNhSzYrc0EwR3hMa3B5ZFJ2K0hjK3B4dnlvVndnOTRBQUFBQUFCNE9pODRhMVNtM1g5MCtodHZTTEpCNlRnQTBBWDZrL3d3eWZ2eTJWZGNNTnlmWElFT0FBQUFBQURMODRyUEhKbit4bnRpVERzQWxOSG8vMG42ZWw2YjA0NzkzYkI5eXVINlJBQUFBQUFBMEJHT09XMTJldm8rbFdULzBsRUFnQ3hKOHNIOFplcC81dXpESG0vMUoxT2dBd0FBQUFEQVg3MzhzMGVrMFg5cWtrbWxvd0FBLytEYTlEY09hL1ZxZEFVNkFBQUFBQUFjZStySTlEZmVsMGIvNitQYU9RQzBxMFhwYnh5VDA0NDlwMVdmd0VrQUFBQUFBQURkN2RoVFYwbnl2MGtXbEk0Q0FLeVFqK2V6eDU2UU5QcWIvY1FLZEFBQUFBQUF1dGZMUHJkV1JpdzdMOGttcGFNQUFDdWh2L0dsTEpyeThtYnZpejZpbVU4R0FBQUFBQUFkNDVXZldqTnBYSlJrZzlKUkFJQ1YxTWo4akYyeWFaNi96VGR5NFlWOXpYcGFCVG9BQUFBQUFOM24yRk5YVDEvUHhVbldLUjBGQUJpMGpiTjQwZ2JaZit0emMrR0ZUUm5uM3RPTUp3RUFBQUFBZ0k1eDdLbVRrM3dueWJxbG93QUFROVRvZjJIdVdQMUR6WG82SzlBQkFBQUFBT2dlSjUzVWt3Y25maVBKczB0SEFRQ2Faa0cyMlc5aHJ2ck9MNGI2UkZhZ0F3QUFBQURRUGU2YytlWWsrNVNPQVFBMFdYL2pvem5tdEsySCtqU05abVFCQUFBQUFJQzJkK3lwMnllNUpNbkkwbEVBZ0piNFEzcVhicE5UWHZYUVlKL0FDblFBQUFBQUFPcnY5UjhabStUL1JYa09BSFUyTjh0R3ZIOG9UNkJBQndBQUFBQ2cvaDRlLzQ0azY1ZU9BUUMwV0gvanVMejhzenNNOXNPTmNBY0FBQUFBb042T1AyVnVsbzM0VlpMUnBhTUFBTVBpbXN5NmM3dWNkTkxTbGYxQUs5QUJBQUFBQUtpM3BiM3ZqL0ljQUxySmxybHo1bEdEK1VBcjBBRUFBQUFBcUs5WGZHYWI5RGV1ak92aEFOQnRic2xmcG02WXN3OTdmR1UreUFwMEFBQUFBQURxN08xUm5nTkFOMW9yVXhhOVpHVS9TSUVPQUFBQUFFQTlIZmZwdGRQZk9LQjBEQUNna0ViLzYxYjJReFRvQUFBQUFBRFVVMS9QUytNNk9BQjBzM2w1K1dlM1haa1BjT0lBQUFBQUFFRDluSFJTVDVLWGxvNEJBQlRXNkQ5cVpSNnVRQWNBQUFBQW9IN3VXSDJISkd1VmpnRUFGSGRZVGpxcGQwVWZyRUFIQUFBQUFLQitHdjNQS3gwQkFHZ0xxK2IyV2R1dDZJTVY2QUFBQUFBQTFFOS9ZNC9TRVFDQXRySEM1d1VLZEFBQUFBQUE2dVg0VTZZbTJhcDBEQUNnVFRUNmQxL1JoeXJRQVFBQUFBQ29sMlVqdGsweW9uUU1BS0J0YkpjWG5MVkM1d1lLZEFBQUFBQUE2bWFUMGdFQWdMWXlKcE1XcjdNaUQxU2dBd0FBQUFCUUwvMk51YVVqQUFCdHBxZHZveFY2V0t0ekFBQUFBQURBc0dyMEs5QUJnSCswZ3VjSENuUUFBQUFBQU9wbVZ1a0FBRURiV1gxRkhxUkFCd0FBQUFDZ2JpYVdEZ0FBdEpsRy82UVZlWmdDSFFBQUFBQ0F1bEdnQXdEL3FMK3hRdWNIQ25RQUFBQUFBR3FrdjVGa2ZPa1VBRURiVWFBREFBQUFBTkJsWG5CMlQxejdCZ0QrcjVFcjhpQW5FUUFBQUFBQUFBQVFCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQVNCVG9BQUFBQUFBQUFKRkdnQXdBQUFBQUFBRUFTQlRvQUFBQUFBQUFBSkZHZ0F3QUFBQUFBQUVBU0JUb0FBQUFBQUFBQUpGR2dBd0FBQUFBQUFFQ1NwTGQwQUlDbjZFMHlPOG5hU1ZaTk1pYkoyQ1NUa293WWVNeWpTWllrZVNESlkwbHVTM0p6a3Z1R055b0FBQUFBMEF5TlJqSnI4dmlzczhyRXJMUEt4S3c5ZldKbVRSbVhVU05HWk9LWWtSazNxamVqZTZ2TGc0OHZXNWFISDF1YWh4NTdJbzh2N2N1ZER6eVNtKzU5TURmZHR6ZzMzZnRnN2xqMFNQcjYrd3YvalFEb1ZBcDBvS1JaU1JZazJTSEpGa25XU2JKbUJ2KzlhWEdTbTVKY24rVHlnZVBxVkNVN0FBQUFBTkFtWms0YWx3WHJyWllkMXAyWkJldXRscTNuckpveEkwYzg4d2V1Z0NWUExNdFZ0OTZUeS82ME1KZjlhV0V1djNGaEZpNSt0Q25QRFVEOUtkQ0I0VFF1eWQ1SkRraXlhNUsxbXZ6OGs1TE1IemdPSGZpeng1TDhJc2w1U2I2UjVMb21mMDRBQUFBQVlBVnNOV2VWSExUbDJqbG9pM1d5NmF5cExmczhZMGFPeUk3cnpjeU82ODM4MjUvOTZzLzM1UnZYM0pSdlhIMXpmbnZIL1MzNzNBQjB2a2JwQUVEdGpVNXlTS3BDZSs5VUpYcEoxNllxMHIrWTVJYkNXUUFBQUFCb3RoZWNOU0pULzdLMGRBd3FhMCtmbU9OMjJUaUhiN05lMXA0K3NYU2NKTWtmRno2UU02KzhQcWRlL0hzcjB3RzZ5L241N0N2MmZxWUhLZENCVnRrNHlRbEpqa2kxTXJ3ZFhacmtZMG5PVGVLWEtnQUFBSUE2VUtBWDE5dlRrNE8yWER1djIzMnpmMWdGM203Nit2dHozbTl1eThkKzhwdjg2UGUzbDQ0RFFPdXRVSUZ1aER2UWJPc25lWGVxRmVmdC9qMW14NEhqMmlUL251U2NzbkVBQUFBQW9MUHRzZkVhZWYvQjIyZXJPYXVVanZLTWVocU43RGR2VHZhYk55ZmYrKzF0ZWZNNVYrUjNkL3lsZEN3QUNtdjNjZ3ZvSEdzbCtXQ3FjZTA5aGJPc3JFMlNmRDNKVlVuZW1PU2lzbkVBQUFBQW9MUHN0UDdNZk9DUTdiTmczUm1sb3d6S1BwdXRtZWR1dW1hK2Z2V05PZkdjbitYbSt4NHNIUW1BUWdaVG9PK2NwRE4vQXBiMVdKSnZsdzRCTGRCSThxb2s3MG43am1wZlVWc251U0RKbDVLOE5zbmlzbkVBaXRrb3llYWxRM1NvSHlaWlZEb0VBRUNiZVU2UzlsK0sybjRlU2ZMZDBpSGdtWXp1SFpHVDk5ODZiOXB6ZmtiMGRQYXVzWTFHOG9LdDE4MWVtOHpPOFdmK05GLzUrUTJsSXdGUXdHQUs5SDlMc21lemczU0JlNU9zV2pvRU5ObjZxY3JtQmFXRE5GRWp5VkZKOWs1eWRKTHZsWTBEVU1SQlNkNWJPa1NIMmlJS2RBQ0FwL3FQSkR1VkR0R0JiazAxOFEvYTFqWnJyWm96am41T05wbzVwWFNVcHBvOGRsUytmTXh1T1hUcmRYTHNHWmZrdm9lWGxJNEV3RERxdERITFFQczROTW1WcVZkNS9tUXpVMDJOT0NtK1Z3SUFBQURBUDNqbHJwdmtweWZ1WDd2eS9Na08zbktkL09JZEIyWCs3T21sb3dBd2pKUkN3TXJxU2ZLeEpHY25tVm80UzZ1TlNQS3VKT2NsbVZnNEN3QUFBQUFVTjNKRVR6NTM1TFB6cVJmdWxORzlJMHJIYWJtMXAwL01wU2Nla0FQbXIxMDZDZ0REUklFT3JJeHhTYzVLdFQ5NE45azd5VStUekM0ZEJBQUFBQUJLbVRobVpNNDlmcSs4Yk1lTlNrY1pWdU5IOSticngrMlJsKy9jWFg5dmdHNmxRQWRXMU5oVUk4MFBLUjJra0hsSmZweGtSdWtnQUFBQUFERGNwbzRibll2ZnRILzIzWHhPNlNoRjlQYjA1TE12ZVhiZXROZTgwbEVBYURFRk9yQWl4aWM1UDhsdXBZTVV0bUdTaTZORUJ3QUFBS0NMVEJnOU10OTl6WE96eFpyMkF2L0F3Yy9LTVR0WmlRNVFad3AwNEptTVRuSnVrcDFLQjJrVEd5YjVmcElwcFlNQUFBQUFRS3VONnUzSldjZnVrUVhyV2xPU0pJMUdjc3FMZHNwKzg3cHpKVDVBTjFDZ0E4L2tvMG4yTEIyaXpXeVI1TFRTSVFBQUFBQ2cxVDV4eEk3Wlo3TTFTOGRvS3lOSDlPU3J4K3lSVFZhZldqb0tBQzJnUUFmK21XT1NIRmM2UkpzNk5NbWJTb2NBQUFBQWdGYjUxeDNtNXRpZE55NGRveTJOSDkyYnM0N2RJK05IOTVhT0FrQ1RLZENCcDdOMWtrK1VEdEhtL2l0RzJ3TUFBQUJRUTV2T21wcVBIN0ZENlJodGJkTlpVL1BmTC9BYUFkU05BaDFZbmxGSnprZ3lwblNRTnRlYjVQUjRuUUFBQUFDb2taRWpldktWWTNiUGhORWpTMGRwZXkvZmVTUDdvUVBVakFJZFdKNjNKekdiYWNXc24rUWRwVU1BQUFBQVFMTzgram1iWnZNMXBwV08wVEUrZXRnT0dUTnlST2tZQURTSkFoMTRxcmxKM2xvNlJJYzVNZFhyQmdBQUFBQWRiZmJVOFRuNStkdVVqdEZSMWx0MVVrN2NlMzdwR0FBMGlRSWRlS29QSlJsZE9rU0hHWlZxUDNRQUFBQUE2R2p2M24vYlRCeGpkUHZLT25HdkxUSmowdGpTTVFCb0FnVTY4R1E3SnRtdmRJZ09kVkFTdCtZQ0FBQUEwTEUybkRFNS8vS3NEVXJINkVqalIvZm1UWHRhaFE1UUJ3cDA0TW5lVmpwQWgzdEw2UUFBQUFBQU1GZ243ajAvSTNvYXBXTjByT04zMlNTclRCaFRPZ1lBUTZSQUIvNXE2eVQ3bGc3UjRRNU9za25wRUFBQUFBQ3dzbVpOR1plWGJHLzErVkNNSDkyYlkzZmV1SFFNQUlaSWdRNzgxU3RMQjZpQm5pVEhsUTRCQUFBQUFDdnJGVHR2a3RHOUkwckg2SGl2Mm5WVHEvZ0JPcHdDSFVpU0NVa09MeDJpSmw2Y1pGVHBFQUFBQUFDd29ocU41S2dGRzVhT1VRdXpwb3pMYm5QWEtCMERnQ0ZRb0FOSnNuK1M4YVZEMU1TMEpIdVhEZ0VBQUFBQUsycm45VmZQV3RNbmxJNVJHLy95TEtQd0FUcVpBaDFJcWxYVE5JL1hFd0FBQUlDTzhjTHQxaXNkb1ZZTzNHTHRqQjNaV3pvR0FJT2tRQWZHSnRtOWRJaWEyU2VKTTJRQUFBQUFPc0krbTg0cEhhRldKbzRabVozV24xazZCZ0NEcEVBSGRrb3l1blNJbXBtVVpOdlNJUUFBQUFEZ21hdzFmWUx4N1Mzd25MbXpTa2NBWUpBVTZNQXVwUVBVMUc2bEF3QUFBQURBTTlsbEEwVnZLK3c2ZC9YU0VRQVlKQVU2b0VCdkRhOHJBQUFBQUczUHFQSFcySHJPcWhrM3lpNlBBSjFJZ1E3ZHJaRmtxOUloYXNvSWR3QUFBQURhM3VaclRDc2RvWlpHOWZaa2s5V25sbzRCd0NBbzBLRzdyWkZrWE9rUU5UVWxpZHQzQVFBQUFHaHJHOHlZVkRwQ2JXMDBjMHJwQ0FBTWdnSWR1dHNHcFFQVTNNYWxBd0FBQUFEQTA1azJmblNtang5VE9rWnR6WjA1dVhRRUFBWkJnUTdkYmNQU0FXcHVvOUlCQUFBQUFPRHByTCtxZ3JlVjVzNndBaDJnRXluUW9idk5LaDJnNXRZc0hRQUFBQUFBbnM1cWs2dytiNlZaVSt5ZUNkQ0pGT2pRM1NhVURsQnowMG9IQUFBQUFJQ25NMkgweU5JUmFtM3F1TkdsSXdBd0NBcDA2RzRLOU5hYVdqb0FBQUFBQUR3ZEJYcHJUUnV2UUFmb1JBcDA2RzRLOU5aU29BTUFBQURRdGhUb3JXVUZPa0JuVXFCRGQzTUcxMXJqU3djQUFBQUFnS2ZUYUpST1VHKzlQU29ZZ0U3a3V6ZDB0NGRMQjZnNXJ5OEFBQUFBYmV1aHg1NG9IYUhXdkw0QW5VbUJEdDN0b2RJQmFzN3JDd0FBQUVEYmVtakowdElSYWsyQkR0Q1pGT2pRM1JTOHJmVmc2UUFBQUFBQThIUWVmbHpCMjBvUEx2SDZBblFpQlRwMHQ4V2xBOVNjMXhjQUFBQ0F0blgvdzQrVmpsQnJYbCtBenFSQWgrNTJVK2tBTmVmMUJRQUFBS0J0WFgvM0E2VWoxSnJYRjZBektkQ2h1OTFRT2tETlhWODZBQUFBQUFBOG5ZV0xIODNpSlkrWGpsRmJDblNBenFSQWgrNm1RRzh0cnk4QUFBQUFiZTJHdSsxQzJDb0tkSURPcEVDSDduYi93RUh6TFlzUjdnQUFBQUMwdWQvZnVhaDBoTnJ5MmdKMEpnVTZjRm5wQURWMVZaSWxwVU1BQUFBQXdEOXowZlYzbEk1UVMvYyt0Q1MvdmNQYUpZQk9wRUFITGk0ZG9LWXVLaDBBQUFBQUFKN0p4WCs4cTNTRVdycmsrcnZTMzE4NkJRQ0RvVUFIRkwydDRYVUZBQUFBb08zOVllR2kzTEhva2RJeGFzZktmb0RPcFVBSHJrbnlZT2tRTmJNMHlhV2xRd0FBQUFEQWlyamdEOHJlWnZ2UjcyOHZIUUdBUVZLZ0EwOGsrWHJwRURYenZTU0xTb2NBQUFBQWdCVng1cFhYbDQ1UUs3Kzg3Yjc4N282L2xJNEJ3Q0FwMElFa09iTjBnSnJ4ZWdJQUFBRFFNWDU0N2UxWnVQalIwakZxNHlzL3Y2RjBCQUNHUUlFT0pNa0ZTZjVjT2tSTlBKRGtXNlZEQUFBQUFNQ0tXdHJYbDY5ZmZXUHBHTFhRMTkrZnIxejVwOUl4QUJnQ0JUcVFKSDFKdmx3NlJFMmNrMlJKNlJBQUFBQUFzREsrY09rZlNrZW9oUi84N3MrNTdTOFBsWTRCd0JBbzBJRy8ra2dTYzVxR1psbVM5NVlPQVFBQUFBQXI2K3BiNzgxM2ZuMXI2UmdkNzZSdlgxVTZBZ0JEcEVBSC9tcGhraStWRHRIaHprbGlQaE1BQUFBQUhlay96N3U2ZElTTzl1UHJicytWTjk5ZE9nWUFRNlJBQjU3c3YxT05jMmR3UGxnNkFBQUFBQUFNMXM5dXVqdVhYSDlYNlJnZDY3Kys5OHZTRVFCb0FnVTY4R1IvU1BMcDBpRTYxQmxKZmxFNkJBQUFBQUFNeGZGZnZpUkwrNnl4V1Zsbi9lTEcvUGk2MjB2SEFLQUpGT2pBVTcwOXlaMmxRM1NZZTVPOG9YUUlBQUFBQUJpcTM5M3hsM3o2b210THgrZ29pNWM4bnRkOTdiTFNNUUJvRWdVNjhGU0xrN3kxZElnTzg4NVVKVG9BQUFBQWRMeDNmdk1YdWZPQlIwckg2QmovK2QxcmN0ZGlyeGRBWFNqUWdlVTVJOG1QUzRmb0VKY2srVnpwRUFBQUFBRFFMSXVYUEo3WGZ0V0s2aFZ4K1kwTDg5RWYvNlowREFDYVNJRU9MRTkva3NPUzNGSTZTSnU3UGNtaFNaYVZEZ0lBQUFBQXpmVDFxMi9NaDMvNDY5SXgydHFkRHp5U2d6NTlmcDVZWnM5NGdEcFJvQU5QNS80a1J5UjVvblNRTnJVMHlZdVMzRjA2Q0FBQUFBQzB3bHUvY1dVdS9kTmRwV08wcFdWOS9YblI1MzZTaFlzZkxSMEZnQ1pUb0FQL3pCVkovcTEwaURiMXppUVhsdzRCQUFBQUFLMnl0Szh2TC9yY1QzTDdvb2RMUjJrN2J6MzNaN253ajNlVWpnRkFDeWpRZ1dmeS9vR0R2M3R2dkNZQUFBQUFkSUZiNzM4b3UzNzQyMVphUDhsSjM3NHFIenJmZUh1QXVsS2dBeXZpYlVrK1h6cEVtL2hZa25lVURnRUFBQUFBdytXR3V4ZG52MDkrUHc4dXNkdmpSMzcwNjV6OG5hdEt4d0NnaFJUb3dJcm9UM0o4a3JOTEJ5bnNqQ1J2S2gwQ0FBQUFBSWJiTDI2NUovdDk4dnU1LytISFNrY3A1bU0vL20xT1BPZG5wV01BMEdJS2RHQkZQWkhrOENRbmx3NVNRRitTRTVJY21XUnA0U3dBQUFBQVVNVEYxOStaYmQ3N2pWeDMxNkxTVVliVjQwdjdjdlFYTDhvSloxMldaWDM5cGVNQTBHSUtkR0JsOUNjNUtjbXJreXdyRzJYWUxFbnlrbFNqMndFQUFBQ2dxOTEwNzRQWjljUGZ6dVUzTGl3ZFpWajg1WkhIY3NBcFA4anBsLzJoZEJRQWhva0NIUmlNVHlWWmtPUlBwWU8wMkRWSnRrenlsZEpCQUFBQUFLQmRMRno4YUhiOHdMZHl3bG1YNWZHbGZhWGp0TXovL3VxV2JQVHZaK1g3djd1dGRCUUFocEVDSFJpc255ZlpLc21YU3dkcGdiNGs3MDkxazhCMWhiTUFBQUFBUU52cDc2LzJCTi94QTkvS0h4YytVRHBPVXozMDJCTTU2dlFMYzhBcFA4amREejVhT2c0QXcweUJEZ3pGNGxUanpZOU5jbmZoTE0zeXh5VDdKM2xya3NjS1p3RUFBQUNBdHZhTFcrN0oxdS81UnQ3My9WL21zYVdkdit2ak9WZmZsQzNlZlU2K2RNVWZTMGNCb0JBRk9qQlUvVWxPUzdKT3F0SjVjZGs0ZzNaemtzT1NiSnprdTJXakFBQUFBRURuZU9peEovSzJjNi9NZXUvNGFzNjQ0dnIwOTVkT3RQSXV1ZjZ1YlB2ZWMzUG9xVC9Nbis3cDFFdWNBRFNEQWgxb2xrZFNqVDJmbCtUVUpKMHkyK2lPSkc5UHNubVNzMU9OYndjQUFBQUFWdEx0aXg3T2thZGZrQjAvOEsyY2MvVk42ZXVBSnYzQ1A5NlJBMDg1UDd0KytOdjV4UzMzbEk0RFFCdm9MUjBBcUoxYmtoeVg1TTFKams3eWhpUnppaVphdmg4bCtYaXExZVpLY3dBQUFBQm9rc3R2WEpoRFQvMWgxbHQxVWs3WWZmTWN1V0NEVEJvenFuU3N2M25rOGFVNSs2b2I4OUVmL3lhL3ZPMiswbkVBYURNS2RLQlZIa3p5c1ZTcjBaK2I1T0FrejA4eXBXQ20zeWI1WnBKemsxeGRNQWNBQUFBQTFONmY3bG1jMTN6MTBweHcxbVZac082TXZHRHJkWFBvVnV0bTFwUnh3NTdsOWtVUDU1eXJiOHJaVjkyWXkyOWNtR1Y5N2I4NkhvQXlGT2hBcXkxSlZWcC9NOG1vSkxzbDJTdkpEa20yU2pLeWhaLzc5aVJYSkxrMHliZVQzTkRDendVQUFBQUFMTWV5dnY3ODlJYTc4dE1iN3NvYno3NGlDOVpiTFR1dU56TTdyRGNqQzlhZGtWVW1qR242NTd4ajBTTzU0cWFGdWV4UEMzUEZqWGZuWnpmZG5hVjlCbEVDOE13VTZNQndlanpKOXdlT0pCbWJaTnNrMnlYWk1NbjZTVFpJTW5zbG4vY3ZxY3J4UHcyOC9XMlN5NUxjTnZUSUFBQUFBRUN6TE8zcnl5WFgzNVZMcnI4clNkSm9KT3V2T2prYnJEWTU2Nnd5TWV1dU9qSHJUSitVTmFhT3k2UXhvekp4ek1pL3ZmM3J4eis0NUluODVaSEg4dENTcFhud3NjZHo4NzBQNWViN0h2emI4Y2VGRCtUVyt4OHErZGNFb0lNcDBJR1NIazF5OGNEeFpPT1N6RXd5SmxYSlBpbkppSUgvMTU5a1Vhb3kvdUdCOSs4ZmpyQUFBQUFBUUhQMTl5ZlgzLzFBcnIvN2dkSlJBQ0NKQWgxb1Q0OGt1YkYwQ0FBQUFBQUFBTHBMVCtrQUFBQUFBQUFBQU5BT0ZPZ0FBQUFBQUFBQUVBVTZBQUFBQUFBQUFDUlJvQU1BQUFBQUFBQkFFZ1U2QUFBQUFBQUFBQ1JSb0FNQUFBQUFBQUJBRWdVNkFBQUFBQUFBQUNSUm9BTUFBQUFBQUFCQUVnVTZBQUFBQUFBQUFDUlJvQU1BQUFBQUFBQkFFZ1U2QUFBQUFBQUFBQ1JSb0FNQUFBQUFBQUJBRWdVNkFBQUFBQUFBQUNSUm9BTUFBQUFBQUFCQWtxUzNkQUFBQUFEb0F1T1NURXN5ZFRsdmU1TTBra3daZU96b2djY3Z6NklrL1FQdkwwdHkzOEJ4LzNMZTcydjJYd0w0UDBZa21UVHcvcWdrNDVmem1JZVRQRDd3L2tOSm5oaUdYQUFBd0NBcDBBRUFBR0JvR2tuV1NMTHVVNDUxQm81cHFVcng0WFpYa3B1VDNETHc5dVluL2ZlZjh2ZENEL2kvZWxOOVhjOUpzbmFTdFpMTVNqSXp5U29EeDZvRGIxZldnNmx1ZEhueWpTOExrOXlXNVBhQnQzOU9ja2Q4blFJQXdMQlRvQU1BQU1DS1d6WEovQ1JiSkprMzhQN2NsQ25JbjhuTWdlTlp5L2wvVHlUNWZaTGZKUGwxa2w4TnZIL0hzS1dEOXRDVDZvYVgrZm43MS9TOFZNWDVpQlo5em9rRHgxclA4TGlsU1c1SThydFVYNisvUzNMdHdMRzBSZGtBQUtEcktkQUJBQUJnK1NZbDJTSEpUa20yVGxXc3JWNDBVZk9NVEZVU3prdnk0aWY5K1QxSkxrMXljWkpMa3Z3eWlqcnFaV0tTQlVsMlRQVzF2VjJTQ1VVVFBiM2VKQnNOSEUvMlNKS3JrbHc1Y0Z5UjVOYmhqUVlBQVBXbFFBY0FBSURLakZTRjJzNER4L3kwYmdWcXUxbzF5WUVEUjFLTm1yNHNWWm4rZzFTbFhmL3lQeFRhMHFna3owNnlUNUpkVTQrdjYzSDUrL2VwdjdvK3lmbXB2azR2U0xYWE9nQUFNQWdLZEFBQUFMclZpRlFyelBkTHNtK1NUY3ZHYVVzVGsrdzljUHhucXYyWnY1M2tXNmxLdXNmS1JZT25OVHZKODFLVjVudWtmVmVZTjlNR0E4ZXJVdTJiL3RNa1gwOXlUcEs3QytZQ0FJQ09vMEFIQUFCYTdlZ2syNWNPMFlVZVNmS09nYmY4M1pSVVpmRHprenczeWZTeWNUck9Ha21PR3pnZVRMWGE5ZXRKL2pmSm93Vnp3WndraHlaNVFhcWZPWTJ5Y1lvYWxXUzNnZU1UU1M1S2N2YkFjVi9CWEFBQTBCRVU2QUFBUUN2dGx1UzBKRDJsZzNTWngxS3R2RlNlVjBZbjJUL0pVYW5LYzc4TE44ZkVWSVhsb2FuSzlIT1RuSm5reDBtV0ZjeEY5NWlSNUNXcFN2UHQwdDJsK2RNWmtiK1g2ZitkNUJ1cGZpNWZGTnN4QUFEQWNybUlCUUFBdE1yMEpGK0szenVHVzErcW92aUMwa0hhd1BaSlBwWGt6aVJucFJyVHJqeHZqWWxKamt5MUl2M1BTVDZhWktPaWlhaXJScW95K0d0SmJrM3lvVmh4dnFMR0pIbFJxcDhQMXlWNVE1SkpSUk1CQUVBYmNpRUxBQUJvbGROU2pYdG1lTDA2VmJIVXJhWW5lWE9TYTVOY2tlU1ZTYVlXVGRSOVppWjVYYXAvZysra0tqdGhxQ1luZVdPcTR2ZkhTUTVMTmFxY3dka3d5WWRUM1lUd2dWVDd4Z01BQUhIblBRQUEwQm92VDNKUTZSQmQ2TDFKUGwwNlJDRjdKRGsyeVFGUnFyV0xScXBWLy9zbXVTSEpKMVBkV0dOckFWYkdyQ1FuSkhsRnJKWnVoY21wYmpvNkljbVhrN3dyeVMxRkV3RUFiVy95MkZIcGFUUXlaZHlvTk5MSTFQSEwveFhzaVdWOXVmL2h4M0wvdzQvbGtjZVhEbk5LR0R3Rk9nQjBweG1wVm9YT1RyTFdrOTZma1dwQ3plUlUreVZPU25XK01QRXBINzhvMVo2Smp5WlovS1JqVVpMN1U0MXV2U1hKYlFQSGZTMzkyd0R0WnFOVTQ1c1pYcDlQOHM3U0lZYlpxRlQ3Yjc4NnlZTENXZmpuMWsvMWZlRk5xVzcwK0h5U3g0c21vdDF0bStUZmt6d3ZKaWdPaDVHcHR2OTRVWkxUVTczMkM0c21BZ0NHM2RSeG96TjM1dVNzTVdWOFprOGRuem5USm1UMmxBbC9lMy9tNUxIcDdSbmNxZG1TSjVaVlpmb2pTM0xIb2tkeTV3T1A1UFpGRCtldUJ4N05UZmN0enUvdlhKU2I3M3N3eS9yNm0veTNncFduUUFlQWVwdVRaRjZTelpQTUgzaC8zU1NqaC9pOEt6c0tkMUdTNjU5MFhKZmtsMG4rbUdxdlhxQStScWRhd1RhdWRKQXU4NDFVcXpPNzVVckQyRlIvM3hPVHJGNDRDeXRuZHBKVGtydzF5WHRTRlhWUEZFMUV1MWtueVgra0tuSVY1OE52WktwcEhvY2tPVG5WMSt1eW9va0FnS1liMGRQSWhqTW1aOTRhMHpOLzl2UnN2c2EwekpzOUxYT21UV2paNXh3emNrUm1UUm1YV1ZQR1piTlowNWI3bUNWUExNdDFkeTNLZFhjdHlpOXZ1eTlYMzNwdnJyNzEzdHozOEpLVzVZTGxVYUFEUUgyTVNMVlM1N2xKZGsxVmxyZkxucTlUVW1YYjlpbC8vbENxSXYyYUpEOU5ja0dTZTRZM0d0Qms3MG15WmVrUVhlYW5TVjZTN2lnNHh1WHZ4Zm5Nd2xrWW1qbEpUazFWcEw4N3lSZmpwcnB1dDA2Uzk2Y3FiaFhuNVUxUDh2RlVXN0ljbCtTeXNuRUFnS0hhYk5hMDdMbkpHdGx6NDluWlpjUFZNMjVVKzFXRVkwYU95QlpyVHM4V2EwN1BFZHV1OTdjL3YvWCtoM0w1alF2emsrdnV5RS8rY0h0dXVIdHh3WlIwZy9iNzZnQUFWc2JNSkh1bktzMzNUSFdocTVOTVNMTFR3UEdhVkNzbmY1UGt4MG5PVDFBV0U2TUFBQ0FBU1VSQlZGV29QMVlzSGJDeTlrM3lodElodXN5dmt1eVhha3VOT3B1U2FuL2UxeVJaL2xJRk90VTZTYjZRNUMycC9vMi9YellPQlV4SWRWUE02d2ZlcDcxc251VGlKSjlJdFUzSXcyWGpBQUFyYXVLWWtYbit2TFd5MXlhenM5Y21zN1A2NU00ZEZEZG4yb1RNbVRZaGgyOVRsZXEzM3Y5UWZ2VDcyM1BlYjIvTitkZitPUTh1TWRTSzVsS2dBMERuV1RYSkMxS050ZHdoU2FOc25LWnFwRm81UHkvVlJkVEZTYjZYNUp0SnpodjRiNkE5elVoVmd0WHBlMUs3dXlYVlRRc1BsQTdTUW8wa1J5YjVyeGpWWG5kelUvMnNQek5WbVg1SDJUZ01neEZKWHAzazM5SjVONEYybXhHcGJuQTVLTlh2SUZhakEwQ2I2dTNweVo2YnJKR1hiTDlCRHR4aTdiWmNaZDRNYzZaTnlORTd6czNSTzg3TjQwdjdjdEgxZCtUYnY3bzFaMTkxWSs1YS9FanBlTlJBUGI5eWdNSHFUWEowNlJBZDZnOUpMaW9kNGltT1NES3BkSWdPZEhlcXNyYmRURWh5WUpJWEp0a3IzZk16ZkZLU3d3ZU9KYWt1ckg4NXlYY0gvaHRvRDQxVSt4aXZWanBJRjdrNzFlU1IyMHNIYWFIdFU0MFAzcTUwRUlaTkk5VjJCQWVtR3V2K2tTUkxpeWFpVlhaSXRhSjVxOUpCV0NscnBmcTk5ejJwOXFtMzdRTFUxR2RldkhQV1c5VWxwWlYxNi8wUDVXVmZhcmZMZzAvdnhMM25aOCtOWjVlTzBaR2UrL0h6c3F5dnYzU01mekJ2OXJUODZ3NXpjOFMyNjJYbXBNNWRhVDRZbzNwN3N1ZkdzN1BueHJQemtjT2VsUi84N3M4NTQ0cnI4NjFmM1p3bFQzVERUbWUwUXJkY2ZBZFd6TWhVK3hDeThyNlE5aXZRVDA2eVlla1FIZWpLdEZlQnZsNlMxeVg1MXhocE9TYkp3UVBIQTBuT1NYSktrcXRLaGdLU0pLOUtzay9wRUYzazRTVFBUM0o5NlNBdHNrNnE0bnkvMGtFb1prS3F2YkNQVEhXRDc1Vmw0OUJFRTFKTmxEZysxYXBtT2s5dmtuY2wyU3pKVVRIU0hXcHArM1ZXeXhackdnNnlzbjUvNTZMU0VWYkszQmxUc3NmR2E1U08wWkVhYWFUYWhiQndqa2J5dk0zbTVQVjdiSjdkTi9Kdm1WUXI4UGZkZkU3MjNYeE9GajN5ZVA3bjhqL2tVeGYrenA3cHJEUUZPa0I5MmZpbGN6VlNsUVp2U2JKajRTenRhbktxQytwSEo3a215V2VTbkpINjd3RU03V2gra2crVkR0RkZscWFheWxISFFuRkVxcHZHVG82YnhxaHNtdVNucVZhN3ZqZk9ienZkZmtrK0c5c3gxTVVocWJaZTJEL0pUWVd6QURBSVMvc01FdWxVWTBmMjVsK2V0VUZldjhmbTJXam1sTkp4MnRhVWNhTnl3dTZiNTdXN2JaYnpmbk5iUHY2VDMrWkgxLzA1L2VYdmZhQUQ5SlFPQUVETEdIZlptZlpNY25tUy80M3lmRVZ0bVdwNnhoK1R2Q2JWU25WZ2VJeE50YTNDNk5KQnVrUi9rcGVtMnNhaWJqWlB0YWZ1aDZNODV4K05USEpTa3A4bjJhSnNGQVpwYktxdjdXOUZlVjQzbXlXNU5NbTJwWU1Bc1BLZVdLWkE3elM5UFQwNWZwZE5jdk4vdlRDbnZtUm41ZmtLNm1rMHN0KzhPVG4vaE9mbEYyOC9PQWZNWHp1TlJ1bFV0RHNGT2tCOVdhSFRXWFpJVlJ5Y24yclBWMWJlN0ZRamYvK2M2a0s3M3lLZzlUNlFaSlBTSWJySTI1S2NXVHBFazAxSThyRWtWOGRlNS94ejgxT1Y2RzhwSFlTVnNuV3E3WGJlRU5lZzZtcjFKRDlPc25QcElBQ3NuS1hMTE1QdEpQdlBYeXUvZWRlaE9lVkZPMlcxaVdOTHgrbFlXODFaSmQ5ODVWNjU1cDJINU9BdDExR2s4N1Q4OGdKUVgxYWdkNGJWazV5VzVPSWtDd3BucVl2cHFmWmx2RGJKTWJHL0pyVEsvcW4yUG1kNGZDVFZudEIxc2lEVktQclh4dlppckpqZUpPOUxjbnFxVmMyMHI1NVVOelJla1dUanNsRVlCaE9UL0REVm1INEFPb1FWNkoxaHF6bXI1SUkzN3BkdnZYSnZLODZiYVA3czZUbm51RDF6MllrSFpzRzZNMHJIb1EwcDBBSHF5d3IwOXRhVHFuajZRNVM4cmZMWG14T3VTckpINFN4UU43T1NmRDZKZTdXSHh4ZVR2S2wwaUNZYW1XclYrYVZSckRFNEwwMXlUYXJ4MGJTZnFVbStudXFHUmpmSGRJL1JTYjZXWk5mQ09RQllRZlpBYjI5alIvYm0vUWR2bjUrOTdjRHN1dUdzMG5GcTYxbnJycFpMVHp3Z1gzMzU3bGw3K3NUU2NXZ2pDblNBK3JJQ3ZYMXRtT1RDSko5TXRWcUQxcHFmYWtYTU4xT05lUWVHcGlmSi95UlpwWENPYnZIOUpDOVB0Zjk1SGN4SzhvTlVxODdkZ01GUXpFMXlTWks5U2dmaEgyeWZha3VHZzBvSG9ZaHhxYzY1M2R3QzBBR3NRRzlmZTIweU85ZWUvSUtjdVBmODlQYW84VnF0MFVnTzMyYTkvUEhkaCtkOUIyK1gwYjNXT2FGQUI2Z3pLOURiVDIrcWZUdC9GWHNFbG5CQXFySHVyNDV6SUJpS055VFpzM1NJTG5GNWtrTlNuNS9wUnlUNWZaTG5sQTVDYlV4SmRaUEpTWVZ6VUhsdGtwOG1XYnR3RHNxYW5PVDhKR3VWRGdMQVAyY0ZldnNaTjZvM3A3eG9wM3ovdGMrekdycUFrU042OHBhOXQ4alAzblpndGwxNzFkSnhLTXpGWTRENnFzdkY5cnFZbGVSSHFmYnRIRk00U3plYm1PUVRxY1lHYjFRNEMzU2k3Wks4dDNTSUxuRmRxbjNtSHlrZHBBbDZrM3dveVplVFRDcWNoZnBwcEJvVi9wSFlFcWVVbmlRZlNMVTFnNUh0Sk5WV1N1ZW1XcEVPUUp1eUFyMjliRFJ6U243MnRnTnovQzZicEdGV1YxSHpaMC9QNVc4NU1POC9lUHVNNmxXamRpdi84Z0QxWllSNyszaGVrbDhuMmFWMEVQN21XVWwrbVdvaWdQTWhXREVUazV5WmF2OXFXdXUyVkdPcDd5MGRwQW1tSnZsdWtqZkd5SFphNi9XcENydnhwWU4wbWFtcHBnQzh1WFFRMnM2V1NiNVFPZ1FBVDIvcHNycnNFdFg1WHJmN1pybm1uWWRrczFuVFNrZGh3SWllUms3Y2UzNnVlZWNobVQ5N2V1azRGT0NDTVVCOUtkREw2MG55NzBuK040a3pyZll6T3RWRWdMT1QrQTBGbnRsSGtxeGZPa1FYK0V1cUc2OXVLeDJrQ2JaS2RRT1pQYW9aTHM5UGNsR2NkdzJYTlpOY0hOdDY4UFFPVC9MaTBpRUFXRDRyME1zYjFkdVRVMTYwVXo1NjJBNFpNOUl3cFhhMHllcFRjK21KQitUb0hlZVdqc0l3VTZBRDFKY1I3bVdOVFZYTW5oempSTnZkd1VtdVNiSkY2U0RReG81SWNrenBFRjFnU1pJRGsveTJkSkFtT0NoVmtUbTdkQkM2enRhcHRzMVpwWFNRbXB1YmFyL3p6VW9Ib2UxOUpzbXJrc3dzSFFTQWYyUVA5TEpXblRnbUY3MXgveHkveXlhbG8vQU14by91emVlUDNDVmZQbWEzakIxcHg2SnVvVUFIcUM4RmVqbHJKdmxacW1LV3pqQW55UlZKamlvZEJOclFXa2srWFRwRUYxaWFhcVhleGFXRE5NRnJVdDFFTnFGMEVMcldGa2wrRUN2UlcyV0hKSmVuT24rQ1p6SWh5U2RqaWcxQTI3RUN2Wnk1TTZiazhyY2NtR2V0dTFycEtLeUVGMjY3Zm43eWh2MHljOUs0MGxFWUJncDBnUG95d3IyTXVVa3VUTEo1NFJ5c3ZORkpUay95cnRpbkYvNXFSSkl6a2t3cEhhUUx2Q3JWbGgrZHJKSGtQVWsrSHROWEtHK3JKQmNrV2JWMGtKclpPOG41cWZZK0J3QTZtRDNReTloNnJWVnl3UnYzeTNxclRpb2RoVUY0MXJxcjViSzNISkJOWnprZHJqc0ZPa0I5V1lFKy9MWktjbW1TZFVzSFlkQWFTVTVLOGo5SlJoWk5BdTNoYlVsMkxoMmlDNXlVNUxPbFF3elJ5RlEzVzd5OWRCQjRrczJUL0NUSzNtYlpPOG01U2NhWERnSUFESjBWNk1OdnQ0MW01ZUkzN1ovVkoxdkIzTW5XV1dWaXJuanJnZGw3VXp1VzFaa0NIYUMrckVBZlhndFNyWEl5S3JRZWprdzErblZ5NlNCUTBJSlVFeGxvclk4bk9ibDBpQ0VhbDZwVWUzSHBJTEFjbXlVNUwwcmZvWHArcWlrWlkwc0hBUUNhd3g3b3cydUg5V2JrM09QM3lyaFI5dEN1Z3dtalIrYmM0L2ZLQWZQWExoMkZGbEdnQTlUWHN0SUJ1c2cyU2I2YnhPeWxlbmxPcWhHbHE1UU9BZ1ZNU25KbUVyL1p0OWJaU1Y1Zk9zUVFUVWp5N1NUN2xnNEMvOFN6a253eHRoWVlySDJUZkQzSnFOSkJBSURtV2RabmhQdHcyWEc5bWZuK2E1K1hTV09jVHRYSjJKRzlPZWU0UFhQMGpuTkxSNkVGRk9nQTllVTIwdUd4WlpJZnhtalF1dG91eVkrU1RDc2RCSWJacDVLc1V6cEV6ZjB3eVV2UzJUK3Z4NlVxejNjckhRUld3Q0ZKVGlrZG9nUHRudXBtSDFkN0FhQm0rcU5BSHc3YnJiMWF2dmZhZlRKeGpKMEM2MmhFVHlPbi9jdXpjOVNDRFV0SG9ja1U2QUQxNVN5NDllYW1La0NtbEE1Q1M4MlA4ZngwbDVjTUhMVE9OVWtPVGZKNDZTQkRNQ0hWbEk1ZEMrZUFsWEZza25lVUR0RkJ0azIxUFlPeDdRQlFRLzJ1SExiY0ZtdE96L2tuUEU5NVhuTTlqVVpPUDJyWEhMdnp4cVdqMEVRS2RJRDZjaHJjV2pPVGZDOUsxVzR4TDFhaTB4MDJTUExwMGlGcTd2b2tleWRaWERySUVJeEpWYXJ0V0RvSURNSi9KRG1nZElnT3NGR3FjOTJKcFlNQUFLMmhRRyt0TmFhTXp6ZVAzenVUeHhyazB3MGFqZVJUTDlveGgyeGxtRjlkS05BQjZzdHBjT3VNUy9MTkdHL2NiYlpJOHJVa2JodW1ya2FtMnZkOFF1a2dOYll3eVQ1Sjdpa2RaQWhHcC9vWnVFZnBJREJJUFVuK1g1TE5Td2RwWXpPVG5CYzNpZ0pBcmZWcDBGdG04dGhSK2NIcm5wZTFwdnYxdXB2MDl2VGt6SmZ0bHAwM21GazZDazJnUUFlb3IwN2VVN1dkalVoeVRwTHRTd2VoaUQxU1hYUnZsQTRDTGZEdnFjYjEwaG9QSnRrM3laOUtCeG1DUnBKVFU2MmdoMDQySWNuWFl4dWU1Wm1RNUR0eG95Z0ExSjQ5MEZ1anQ2Y241eHkzWnphZE5iVjBGQW9ZM1RzaTMzbjFjek52dGlHV25VNkJEbEJmem9KYjR6MUpubHM2QkVVZGx1VGRwVU5Ba3owbnlkdExoNml4eDFLTmpMNnFkSkFoZW5lU28wcUhnQ2JaTU1uL3hFMXhUOWFUNUV0SnRpNGRCQUJvUFF2UVcrUDloMnlYM1RkYW8zUU1DcG8wWmxUT2U4MCttVDExZk9rb0RJRUNIYUMrbkFZMzMrRkpUaXdkZ3JidzlpUkhsQTRCVFRJdFZXSGlkNFBXNkV2eTBpUVhGTTR4Vks5TDhvN1NJYURKRGtqeXh0SWgyc2o3a2h4VU9nUUFNRHdVNk0xM3hMYnI1Zlc3enlzZGd6YXd4cFR4K2ZMTGRzL0lFUzYxZENyL2NnRDE1VFM0dWVZbCtVS3NVcUxTU1BLNUpKdVZEZ0pOY0ZxUzJhVkQxTmhya255MWRJZ2hPalRKUjBxSGdCYjVyeVFMU29kb0EwY2tlWFBwRUFEQThESEN2Ym0yWEhPVm5IN1VybW00Y3NpQW5UZVltWThldGtQcEdBeVNBaDJndnB3Rk44L2tKTjlJTXE1MEVOcksrRlI3aEU0dkhRU0c0R1ZKRGk0ZG9zYmVsK1NVMGlHR2FOdFVZNjc5N2toZDlTYjVZcEtKcFlNVXRGV3FHMFVCZ0M3U1p3bDYwMHdhTXlwZk8zYjNqQms1b25RVTJzd3JkOTBrTDkxaHc5SXhHQVFYUVFEcXE2OTBnQnI1WEpMMVNvZWdMYTJWNnFLN2N5bzYwVVpKUGxZNlJJMTlQcDIvci96TUpPZW11bUVJNm15REpKOHNIYUtRVlZMZEtEcTJkQkFBWUhqcHo1dm5vNGN2eUFhclRTNGRnemIxaVNOMnpNYXJUeWtkZzVYa1lpOUFmVGtOYm82alU0MnVoYWV6YjVKWGxnNEJLMmxVa2pPakdHMlZjNU84SXAzOXMzaDBrbThtV2FOMEVCZ21SNmI3Sm5MOGRVdWF0VW9IQVFDR253SzlPVjY0N2ZyNTF4M21sbzVCRzVzd2VtVE9mTmx1R2RXcmt1MGsvclVBNnN0cDhOQnRrT1FUcFVQUUVUNlVaRjdwRUxBUy9qUFZ5RjZhNzZkSlhweGtXZWtnUS9UWkpOdVhEZ0hEN0ZOSnBwVU9NWXhlbStTQTBpRUFnRExzZ1Q1MGM2Wk55S2RmdkZQcEdIU0FMZGRjSmU4OWNMdlNNVmdKQ25TQStuSVdQRFFqVXUzNWF0OXpWc1RvVktQY1I1VU9BaXRnenlSdkxCMmlwbjZkWkw4a2o1WU9Na1N2U0xVYUY3ck56Q1FmS1IxaW1NeFA4djdTSVFDQWNxeEFINXBHSS9uQ1VidGs4bGlYZ2xneHI5OWo4enhuN3F6U01WaEJDblNBK25JYVBEU3ZTckpENlJCMGxDM1MrZnNkVTM4emtwd1J2d2Uwd2kxSm5wZmtnZEpCaG1pckpCOHRIUUlLT2pMSjdxVkR0TmpZSkY5T2RRTWdBTkNsK2pUb1EzTDBEaHRsOTQzc2VNV0s2MmswY3RxL1BEdmpSdldXanNJS2NPRU1vTDZjQlEvZVpraytVRG9FSGVrZHFZcDBhRWVOSktlbkt0RnBydnRUbGVlM2x3NHlST05UbFdwalNnZUJnaHBKUHBONlQ1WDVZSkpOU29jQUFNclNudy9lQmpNbTVXT0hXM2ZEeWx0djFVazUrZm5ibEk3QkNsQ2dBOVJYWCtrQUhXcGtxbEhjVnVRd0dMMUpQcG5xNGp1MG0xY20yYWQwaUJwNk9OWHJlbTNwSUUzd3lTUnpTNGVBTnJCK2tqZVhEdEVpdTZUNmVRQUFkRGw3b0E5T2YzL3k2UmZ0blBHanJTSm1jRjY3MjJiWmVQVXBwV1B3REJUb0FQWGxMSGp3dGlvZGdJNjJZNUlYbHc0QlR6RXZ5WWRLaDZpaHBVa09UM0psNlNCTmNFU1NsNVlPQVczazdVbm1sQTdSWk9PVC9FL2M2QWNBeEFyMHdmcmRuZmRuNXcxbWxvNUJCeHZWMjVOUHZYQ25OSnlWdHpXM3lBRFVsOVBnd2RteWRBQnE0WU5KdnBOa1Vla2drTC92ZFdzc2QzUDFKL25YSk44dEhhUUpaaVg1Uk9rUVhlVGVKRGNrdVNYSjNRUEhQVm4rdWR1NEpLc21tVG53ZHQyQlkreXdKTzF1NDVLY25PcnJ2QzcrTGNuYXBVTUFBTzNCQ3ZUQjJXeld0TklScUlIbnpKMlZJN1paUDEvNStRMmxvL0EwRk9nQTllVXNHTXFabWVvaTlSdExCNEVrNzA2eWFla1FOWFJ5a3Y5WE9rUVROSktjbm1TVjBrRnE2czRrUDBweVZaS3JrL3c2eVFOTmVONDVTUllrMlNuSnJrazJhOEp6OG44ZG1lU1VKRDh2SGFRSnRvcnpFZ0RnU2Zwcy9naEZmZkRRN2ZPdFg5MmNSeDVmV2pvS3kyR0VPMEI5T1EyR3NsNmRhcFVnbExSdmtqZVVEbEZESDBsVm9OZkJ5NUxzVlRwRXpmd215VHVTekUrMXV2L0lKQjlMY2ttYVU1NG55YTFKdnBia05VazJUN0pHcXBYUzMwcnlXSk0rQjlVMWsvZVhEdEVFSTVLY0dvc29BSUFuc1FJZHlscGp5dmk4YWxmckhkcVZBaDJndnB3RlExbWprcnlyZEFpNjJvd2tYNGk5YnB2dGkwbmVWRHBFazZ5UjVFT2xROVRFd2xTdjVXWko1aVY1YjZyVjVzUGxqbFI3V3grWWFnckt5NVA4ZGhnL2Y1MDlKNTEvazhuTGtteFRPZ1FBMEY3c2dRN2x2WDJmTFROdC9PalNNVmdPQlRwQWZUa05odkpla21TTDBpSG9XcWNtV2ExMGlKcjVmcXBpc2k0L1l6K2RaSExwRUIzdTJpUXZUckpta2pmL2YvYnVPOHl1c3ZyYitEMnBoRkJDaDRCVTZRaFNsQ0tLb0lBb1lnT3hLMWdBUVlxS1lFRlJVTUdDQlZSRUVGQkJVVVN4MEVTcDRxc2cwbXVBaEJZZ0NRbHBKSk9aeWZ2SE0veElTRTR5Yzg3ZWUrMXlmNjdyWElFazV6emZUR1ltejlscnIvVUFkOGZHQVdBYWNEYXBrTDhQY0dOc25GcjRPdFc5R1drVjRKVG9FSklrcVh6c1FKZmlqVmwyQko5KzQ5YlJNYlFZRnRBbHFiN2NCVXZ4aGdCZmlBNmhSdm80OExib0VEWHpMK0Jkd0x6b0lCbDVIL0RXNkJBVjlqaXBjUDRLNEVMSytYa3huM1RUeDJ0SkhkUzN4OGFwdEIyQWQwYUhhTk1Kd0VyUklTUkpVdmw0QnJwVURzZTg4UldzdHZ3eTBUSDBFaGJRSmFtK0xLQkw1YkEvYWFTdlZKUk5nZTlGaDZpWis0SDlnTm5SUVRLeUt1bE1iZzNlSE5KNDlzMUloZk9xWEhiOEc2a0lmQnoxK1R3dTJrbFU3eHJLbHNEaDBTRWtTVkk1MllFdWxjT3lJNGJ4cWQyOWRGZzJWWHZ6SjBrYXVLcGMwSlhxcmd2NFhIUUlOY1lJNEFKZ2RIU1FHcGxJR29NOU9UcElocjVHS3FKcmNQNUN1aUhxaThDczRDenQ2QUcrQld3TDNCU2NwWW8ySjUweFh5WGZCb1pGaDVBa1NlWGtHZWhTZVJ5NXgxYXNPR3BFZEF3dHdBSzZKTldYMjJDcFBONEh2RHc2aEJyaHk4RDIwU0ZxWkNwcDlQVWowVUV5dEJWcHhMOEdyaHY0Rkduay9VUEJXYkx3QVBBNlVrZTErOFhCT1RZNndDRHNUcnI1Ui9Yd1BPbmZwS2xVOHdZZVNWSUoyWUV1bGNlS28wWnc2T3UyaUk2aEJYZ25zaVRWbDd0Z3FUeUdBa2YyUDZTOHZCNzRmSFNJR3BrRHZBTzRLenBJeGs3RDk0R0Q4U2p3YnVEZjBVRXkxa3U2NGVadTRGeGdWR3ljeXRpSmRQUEI5ZEZCQnVCcjBRRTBZRThCdDVCdTBIbWsvekdKTlBua2FXQjZpK2V0U1ByYTNRRFlpSFN6NXN1QnJZRXRTUHRQU1pKYXNnTmRLcGRQN2JFbHAxMTlCL042SFN4YkJsNDRrYVQ2Y2hzc2xjdEJ3QW5BYzlGQlZFc3JrSXBnVHBqS1JnOXdJSEJkZEpDTXZSWFlNenBFaFZ3RnZKOTZqZTkvcVl0SXh4VDhpVlNNMDlJZFMva0w2SHNDdTBhSFVFdjNrZjU5dVo1MG5NTDRObC9udWY3SFU4Qy9YdkpyeTVFbTByd0tlQ093QnpDOHpYVWtTVFhWWndWZEtwVzF4NHhtLyswMjVOYzNqNHVPSXJ6QUprbDE1aTVZS3BmbFNJVVlLUTluQU90SGg2aVJ3MGtGeFRvWkFYd25Pa1NGWEFpOGhYb1h6MTl3UGFtNDVnMWVBL01XVW5kdm1aMFlIVUFMNlFOdUlFMGlXZ2ZZSERpVTlIMW1mRTVyemlRVjZiOER2QWxZQS9nd2NDbnBXQXBKa2lTVjBDZGV0MWwwQlBXemdDNUprbFNjVHdGZDBTRlVPKzhGUGhnZG9rYStDcHdWSFNJSGh3R2JSSWVvaU84Qkh5Qk5JbWlLVzRHOVNFVTNMVmtYY0ZSMGlDWFlHOWdsT29TQU5JYjltOENHcE5IL3B3TlBCR1daQ3Z3Q2VEdnBocnV2a2NiRFM1SWtxVVJldjhsWXRsdDMxZWdZd2dLNkpFbFNrVFlqZGZsSldWa1ArSEYwaUJyNUlmWHMzRndlK0ZKMGlJbzRIdmcwelp6azh4L2dIY0RjNkNBVjhEN0tPL0wreE9nQTRtSGdFOERMZ0M4QUUyTGpMR0lpOEJYU0h1SWpwTFBYSlVtU1ZCS0h2Rzd6NkFqQ0Fyb2tTVkxSUGhvZFFMVXhGUGdsTUNZNlNFMzhEamdtT2tST2pnQzhoWDNwVGdkT2pRNFI3R3JTRVFaYXN1Vkkwei9LWm5kZ3ArZ1FEZllZY0JDd0tmQXp5bjh6eWx6Z2ZOSkkrVStTQ3V1U0pFa0tkdUFPRzdITThLSFJNUnJQQXJva1NWS3gzb0VGVDJYak04QnJvMFBVeE45SUk3djdvb1BrWUJYZ3VPZ1FGWEFoNVI3TFhhUnpnRE9qUTFUQWtaVHZXSlpQUndkb3FKbWtLUitiQXVkUnZlTWY1Z0UvQVRZR1R1Ny9mMG1TSkFWWmNkUUkzdjdLOWFOak5KNEZkRW1TcEdJdEE3d3pPb1FxNzFXa2k5enEzUCtBL1lIdTZDQTUrUXpsSFRWZEZyZVF4aTAzY1d4N0s4Y0NEMGFIS0xuTmdaMmpReXhnYTJEZjZCQU5kREdwOFB4MTRQbmdMSjJhQlp3QWJBRmNFNXhGa2lTcDBkNy82bzJqSXpTZUJYUkprcVRpdlQ4NmdDcHRXZExJMWVIUlFXcmdFZUF0d1BUb0lEbFpsZFFscTlZZUJkNUtLaHpwUlROSjUzemJpYnBrQjBVSFdJQ2o5NHMxZzNSKytBSEFVN0ZSTWpjTzJJdDBmbnZWdXVrbFNaSnFZZTh0MTJIVjVaYUpqdEZvRnRBbFNaS0s5M3BnbmVnUXFxeHZrVG9mMVptbmdUMnA5NW12aHdPam8wT1VXQytwU0Z5MzRsZFdiZ0ZPaWc1UmN2dVRKc3RFV3hQNGNIU0lCcmtSMkpKME0xdGQ5UURmSkUxWm1CQ2NSWklrcVhHR0R4M0N1N2JiSURwR28xbEFsNlQ2S3R1WmpKSmVOQVRIdUtzOSt3S2ZqQTVSQXpOSkg4dUhvb1BrYURrODAzdHB2Z0w4TXpwRXlaMEtQQkFkb3NUR0FQdEZod0ErRG95TUR0RVE1d0p2QkI2TERsS1FXNEJkZ2Y4WEhVU1NsTDB1THgxS3BYYmdEaHRGUjJnMEMraVNKRWt4M2g0ZFFKV3pKdkJ6dkVHcVUzT0J0NUdLQW5YMlVXQ2w2QkFsZGcycHUxSkwxZzBjRngyaTVLS1BaUmxLS3FBclgzM0FaNEdEU2YrT05Nbmp3QnVBeTZPRFNKSWtOY2xyTjE2VGxaYjFQdGtvRnRBbFNaSml2QmFMV3hxNExsTFgyMnJSUVNxdWozUm03VCtDYytSdEtKNTl2aVF6Z1krUlBoKzBkSDhFYm9nT1VXSjdBeXNIcnY5bTRHV0I2emZCUE9BOXdIZWpnd1NhRGJ5VnRCZVJKRWtsTjNQdVBKNmUvandQVDU3T3c1T25NMm5HSEo2ZjF4TWRTNE0wYk1nUTl0N1NFeUNqRElzT0lFbVNXcG9BM0FtTTcvL3Y4Y0EwMHBtRU14YjRmYU5JNTIrdUFBd0gxZ2MySVoyUnZDbXhGM1hWMmpEU1JmZmZSQWRSSlJ3Q3ZDazZSQTE4aW1aOHplMFBiQmdkb3NST0FoNk9EbEV4bndIK0V4MmlwRWFTcHNyOFBHajlqd1N0MnhUelNGTUdmaGNkcEFSNlNkTU9oZ0lmQ3M0aVNWTGpQVFoxSmpjOTlEUzNQanFaQ1ZObU1uN0tEQ1pNbWNsVDAyZTNmTTdRSVYyc3NNd0kxbHB4V1RaYmN3eWJyTEVpbTY0eGhzM1hHc01yWDdZS0k0Y05MZkJQb0lIWWI1djErTTNOZFQ1OXJyd3NvRXVTVkI3amdEOERONUxPR1h3eW85ZGRnM1JXNDF1QXZZQlZNbnBkZFc0L21sSE1VMmMybzlsZGIxazVGZmh4ZElpQ0hCTWRvTVR1QUU2TERsRkJOd05Ya2ZZUld0UzdpQ21najZVY1o3RFhWUTl3QUhCcGRKQVM2UVVPSXQzQWUwQndGa21TR21YR25IbGNmdGRqL1BHMjhWei80RVNlbURacjBLL1IyemVmcWJQbk1uWDJYTzZaT0hXaFh4czljaGk3YlR5V3ZiZGNoNzIyV0lmTjFoeVRWWFIxWUo4dDEyWDQwQ0hNNjNXQVd0RXNvRXVTRkdzYzhBdlNlTlE3YzFyamFlQ0Mvc2RRWUVmZ0EvMlA1WE5hVXdQekp0TGZTVzkwRUpYV0NOTFg3ckxSUVNydTU4RG5vME1VWkh2Uzkza3RhajV3T0trb3BzSDdEaGJRVzNrRGFVODFZMm0vTVdQdngrczZlWmtQSElyRjg4WHBBejRNckFYc0dweEZrcVJhNisyYnoxL3VuTURaTjk3SDFmYyt3Wng1K1YwK21qVzNoOHZ1ZXBUTDdub1VnQzNIcnNTUmUyekZCM2JjbUdWSHVPV01NbWJaRWV5ODRScGMvK0RFNkNpTjR4bm9raVFWcncvNEsrbk15azFKbzJUektwNi9WQzl3RS9CSllCM1NPT043QzFwYmkxb0oyQzQ2aEVydFJQd2M2ZFFmZ0UrUWlpRk44TEhvQUNWMkNXbktpOXB6TlhCWGRJaVNHZ25zR2JEdXdRRnJOc1ZYZ1hPaVE1VFk4NlRwQnc5R0I1RWt0YStyS3pxQldubnUrVzVPdmZJMlh2NmwzL0QySDEvRlgrNTROTmZpK2VMYy9lUlVEdm5WRGF4Ny9JVjgvZy8vWWVKenJVZkRLMTk3YkRZMk9rSWpXVUNYcFBweUcxdys4MGtYNzdjQjlnVXVKeFhUbzB3SHpnQzJCTjRIUEJHWXBjbjJpQTZnMHRvZE9DNDZSTVhkU09yUWJNcVVoeFZJZjE0dHFnLzRjblNJaXBzUGZDODZSSW05cmVEMWRpQWQ4YUhzblVVcW9HdkpwcExlMDB5UERpSkpVbDFNbTkzTjhaZjhoM1dPdTREakwva1A0NmNVUGVCb1VWTm16ZUdVSzI1ai9TOWN5TkcvdllucGM3cWpJelhPR3pkZk96cENJMWxBbHlTcEdOZVNMblMraS9KMWI4MEhmazI2Q0hzS01EYzJUdU5ZUU5maXJFUTYzc0g5ZXZ2dUFkNU82cEpyQ28vbWFPMTNwTThKZGVaaW12VTFOUmh2SVIzTFVwUjNGcmhXazl3T0hCVWRva0llQUk2TURpRkpVdFhObncvbjNmUUFtMzc1SWs2OThqWm16cDBYSFdrUjNUMTkvT0R2ZDdIMTF5N210N2M4SEIyblVWNjEzdXFNSHVrWS9hSjVRVTZTcEh4TkJnNGlGVWx2RGM2eU5ETkpad1J2aTBXR0l1MUtPdWRhV3REcHBHTVcxSjRKcExPYXAwUUhLZGdub2dPVVZCL3B1QlIxYmpydzUrZ1FKYlVLNldiSm9yeTd3TFdhWWdicDR6b25Pa2pGbkErY0Z4MUNrcVNxdXUrcGFleHgybDg0NlB4cmVXWkcrZTlWblRCbEpnZis3R29PT3Y5YW5wL1hFeDJuRVVZTUc4SnJObG96T2tialdFQ1hKQ2svbHdHYmt5NG9WZW5zM1h1QkhZSGZSQWRwaUdWSkgyL3BCZS9ETWR5ZGVCWjRNODA3bG1KcjBoRWhXdFR2Z2J1alE5VEloZEVCU3F5b2M5QzNCellxYUswbU9aelVVYTNCT3dhWUdCMUNrcVNxT2ZlbSs5bnU1RXU0OW9Fbm82TU0ybmszUGNBdXAxN0tRNU04emFVSXI5L0VjOUNMWmdGZGtxVHM5UUlua000RW5CeWNwVjB6Z2ZjQ1J4TjdUbnRUN0J3ZFFLV3hIdkRqNkJBVk5vdFVQRy9pRkExdnVtanRoOUVCYXVaeTB0bkhXbFJSQmZUM0ZMUk9rL3dCK0dWMGlBcWJCbndzT29Ra1NWVXhaMTR2SC8vbDlSeDgvbldWN3VLKzdiRXA3UENOUzdoeDNGUFJVV3B2eHcxV2o0N1FPQmJRSlVuSzFuUlM0ZnhrcXRWMTNzb1BUWGZvRkFBQUlBQkpSRUZVZ0lPeGlKNjNWMGNIVUNrTUJYNEZyQmdkcEtKNmdBT0JmMGNIQ1RDVWRQNjVGblVyY0dOMGlKcnBKaFhSdGFoZEtPWjd1T2VmWjJzRzZhWlJkZVl5NEpMb0VKSWtsZDFqVTJleTR5bC80T3diNzR1T2tvbHBzN3ZaK3dlWFZiS0x2a3BldmNGcURCM1NGUjJqVVN5Z1M1S1VuZnRKSXpXdmlBNlNzZk5KblU3VnZTVzIvQnpoTG9CamdWMmpRMVRVZk9BZzRLL1JRWUs4Rm5DZTIrTDlQRHBBVGYwdE9rQkpEUU5lbC9NYVd3TWI1cnhHMDN3R2VEUTZSRTE4R3BnYkhVS1NOREJkMXVJS2QrdWprOW5wbEQ5eXgrUFBSa2ZKMU96dUh2WTk0d3B1ZU5CTzlMd3NOM0k0bTYrNVVuU01SckdBTGtuMTVUYTRXUGNDdXdQam9vUGs1SGZBSjZORDFOZzZ3SnJSSVJUcTFjQkowU0VxN0l1azd2Mm1jbno3NHMzRWtjeDV1Wko2VE5ySncyNDV2LzQrT2I5KzAxd05uQjBkb2tZbUFEK0tEaUZKVWhuZC92Z1U5dnIrWlR3NWJYWjBsRnpNbXR2RE8zNXlGZU9lOFV6MHZHeS8zcXJSRVJyRkFyb2tTWjI3aTNTeGRHSjBrSno5RERndE9rU043UlFkUUdHV0pVMTZHQllkcEtLK0Izd3pPa1NnNFRqT3VaVkxTVWVyS0hzVGdUdWlRNVRVTGptLy9sNDV2MzZUOUFKSDRjMGdXVHNGdi9kS2tyU1FXeVpNNHZYZi9UTlRaczJKanBLcktiUG1zTzhaVnpCanpyem9LTFcwMDRhZWcxNGtDK2lTSkhWbUFxa1RhRkowa0lKOG5tYWVMMXlFYmFNREtNekp3R2JSSVNycUV0TG8reWJiSFZnNU9rUkovVFk2UU0zZEVCMmdwSFlnM1JpVmgrWHhxSThzWFFqY0V4MmloaVlCUDQ0T0lVbFNXWXlmTW9PM25uRWwwMlozUjBjcHhQMVBUK1BJaS80WkhhT1d0bGxubGVnSWpXSUJYWktrOWswSDlnVWVqdzVTb0c3Z0FHQnlkSkFhMmlvNmdFSzhDVGc2T2tSRlhRbThoOVJCMkdSdml3NVFVcytSUGtlVW4xdWlBNVRVY0dEN25GNzdqY0NJbkY2N2FicUJFNkpEMU5nUFNSOWpTWklhN2JubnU5bjNqQ3Q0YW5vOXg3YTNjdDVORDNET1ArK0xqbEU3VzZ5MUVsMGUybG9ZQytpU0pMV25CemlRTkw2OWFSNGpqYnRVdHJhSURxRENyVVE2ZDlXM1A0UDNMOUxZOHFiUGhlc0MzaDRkb3FUK0FzeU5EbEZ6TjBjSEtMRzh4cmg3L25sMnppVk5rbEkrSmdJWFJZZVFKQ2xTYjk5OER2eloxZHo5NU5Ub0tDRSs4N3YvMTdnYkIvSzI0cWdSckRObXVlZ1lqV0VCWFpLazlod0hYQkVkSXRDRk5QdlBuNGVOZ1ZIUklWU283d05yUjRlb29QdUIvUURmaWNOMndOam9FQ1gxbCtnQURYQS9NQ3M2UkVudG1OUHJ2aUduMTIyYWJ0STUzY3JYajZJRFNKSVU2VXVYM3N5VmR6ZHBhT1hDbm51K202TXV1aWs2UnUxc3RmWkswUkVhd3dLNkpOV1hIWTM1K1FQd3ZlZ1FKWEFrZHZkbGFTaXdhWFFJRldaLzRFUFJJU3BvSXFrRDAyTWtFc2UzTDk1ODRCL1JJUnFnRjdnM09rUkpiWnZEYTQ0Rk5zemhkWnZvWEdCOGRJZ0crRGZnN0ZaSktyRXVMeDNtNWsrM1QrRFVLMitMamhIdXQ3Yzh6R1YzUFJvZG8xYTJIR3NCdlNnVzBDVkpHcHluZ0UrUUxzNDMzWVBBbWRFaGFtYno2QUFxeEJyQVQ2SkRWTkJVWUcvZ2tlZ2dKZkxXNkFBbGRSdndUSFNJaG5nZ09rQkpyUStzblBGcnZpN2oxMnVxK2NDM28wTTB5QVhSQVNSSkt0cXpzK1p5NkFVM01OOHJod0FjOS92LzBPY0hJek5ickdVQnZTZ1cwQ1ZKR3B6RHNQTnhRYWNBYzZKRDFJZ2Q2TTN3VTJEVjZCQVZNd2Q0QjNCbmRKQVNXUjNZSmpwRVNWMGRIYUJCSG93T1VHSlpmMzN1bXZIck5kVzF3RVBSSVJya1FyenhXSkxVTUlkZGVBTVRuL1BFc1JmYzllU3pYUEkvNzRQUHlzYXJyeGdkb1RFc29FdVNOSEMvQnY0WUhhSmtuZ0xPaXc1UkkrdEhCMUR1UG9CanR3ZXJGemdRdUM0NlNNbnNqc2UxdEhKRGRJQUdHUmNkb01TMnp2ajFYcFB4NnpYVjJkRUJHdVpoNFBib0VKSWtGZVV2ZHp6S2IyOTVPRHBHNlh6M2IzZEVSNmlOOVZaWkxqcENZMWhBbHlScFlKNERqb29PVVZLbkFqM1JJV3JDczAzcmJWM2dqT2dRRlhRNDhLZm9FQ1cwZDNTQUV2dFBkSUFHZVN3NlFJbGxlUTc2R0xJdnlEZlJNOERGMFNFYTZQTG9BSklrRldGMmR3K0hYZWk5dkl2ei94NStocXZ2ZlNJNlJpMnNQV1kwSTRjTmpZN1JDQmJRSlVrYW1HOERrNkpEbE5SNDRQZlJJV3BpdmVnQXlrMFhjQTdnckszQitTcHA1TDBXdFVkMGdKS2FDRHdkSGFKQjNCdTF0bVdHcjdVVFhyL0p3aStCN3VnUURmU1A2QUNTSkJYaGgvKzRpOGVuem9xT1VWby8rSWNuc21WaFNGY1hMMXQ1ZEhTTVJ2QU5tQ1JKUy9jNGNGcDBpSkk3S3pwQVRhd05ESThPb1Z3Y0Nyd3hPa1RGbkE2Y0dCMmlwRGJCRzI1YXVUVTZRTU04RXgyZ3hEYko4TFYyeVBDMW1zeng3VEZ1Qko2UERpRkpXbFNYQjBKbFp2TE1PWHpqOHY5Rnh5aTFLKzU2bktlbnV5WEl3dnFyTEI4ZG9SRXNvRXRTZmJrTnpzNkplTkZuYWE0aG5YR296Z3pGb2xnZGJVeWFZcUdCdXhnNEpqcEVpZTBhSGFERWJvc08wRERQQXIzUklVcHFCV0JzUnErMVRVYXYwMlIzQWZkRmgyaW9PY0ROMFNFa1NjclRkLzkyQnpQbXpJdU9VV285ZlgzOCt1WngwVEZxd1FKNk1TeWdTNUswWk9OSjR4NjFaUE9CaTZKRDFNVGEwUUdVcWFIQWVZRHp0UWJ1ZXVDRFdKUmJrdGRFQnlpeEI2TURORXdmTURzNlJJbHRtdEhyWkhtZWVsTmRFaDJnNFp6WktrbXFyU216NXZDamErK09qbEVKdi9xM2I5ZXlNSGJNc3RFUkdzRUN1aVJKUzNZcW5wVTRVTCtJRGxBVGEwUUhVS1lPQTNhSkRsRWg5d0x2SkhXcnFUVS9wMXB6R2tyeC9IcHRMWXNDK29yQWhobThUdE5kR2gyZzRhd3FTSkpxNnlmWDNXUDMrUUQ5ZDhKazdwMDRMVHBHNWEyeHZBWDBJbGhBbHlTcHRhbllmVDRZOTVIR1k2b3pGdERyWTJQU1RUZ2FtUEdrYytLbkJPY291ekZrZTdaeTNUd1NIYUNCNWtZSEtMR05NM2lOcmZCb3BrNDlEbmdvYWF4N293TklrcFNIdVQyOW5QNFA3eE1iakQvZU5qNDZRdVd0dWVLbzZBaU5NQ3c2Z0NSSkpmWnpZRlowaUlxNWluU2hWKzJ6Z0Y0UFhjRFBBRzhMSHBpbmdUMkJKNk9EVk1CT2VDUDBrcHhQR2l1dTRxd1NIYURFMXMvZ05SemYzcmsva0k0YlVwekhvd05Ja3BTSFMyK2J3RE16bm8rT1VTbC92KzhKUHIvUEs2TmpWTnJxeTF0QUw0SUZkRW1TV2pzek9rQUZYUWw4T2pwRXhWbEFyNGZEZ04yaVExVEVUR0JmWUZ4MGtJcllPVHBBeWUwUkhVQmF3TG9adk1Zck1uaU5wdnRMZEFEeFRIUUFTWkx5OFBPYjdvdU9VRGszakp2SXpMbnpXRzdrOE9nb2xiWEdDaGJRaTJEbmdpUkppL2MvTE9hMDQwWWM1ZHFwMWFNRHFHTmpnVzlFaDZpSUh1Qjl3QzNSUVNyRWJsU3BPdGJMNERVMnkrQTFtcXdidUNFNmhKZ096SWtPSVVsYVdKZW54SFJreXF3NS9PTStoNmdOVm5kUEh6ZU9leW82UnFYWmdWNE1DK2lTVkYvdWdqdno1K2dBRlRXYlZFUlgrMWFMRHFDTy9SQllNVHBFQmZRQkg4THZ0NE8xVFhRQVNRTzJLdERwMWEyWFp4R2t3ZTRBbkt0YURzOUdCNUFrS1V0L3UrY0o1dlY2ZWxRNy9uN2ZFOUVSS20zRlVTTVlOc1R5YnQ3OENFdVN0SGhYUmdlb3NKdWlBMVRjQ3RFQjFKRTNBKytLRGxFUlJ3Sy9qZzVSTVN1UnpVaG9TY1hvQWw3V3dmT1hKMDAxVWZ2c1BpK1A3dWdBa2lSbDZlcDdMUUszNitieGs2SWpWTjd5eXpnQ1AyOFcwQ1ZKV2xRUDhOL29FQlYyZTNTQWlscytPb0E2Y254MGdJcVlBSndaSGFLQ3Rvd09JR25RMXU3Z3VSdGxscUs1L2hrZFFQK25KenFBSkVsWnVtV0NSZUIyL2UvUktmVE5ueDhkbzlKV0dHVUJQVzhXMENWSld0UTRQTWU3RTk1ODBCazcwS3ZOdjcrQldRLzRTblNJQ25wbGRBQkpnN1o2QjgvZE9MTVV6ZVhSUXVVeEx6cUFKRWxaNmVucjQ3Nm5wa1hIcUt6cGM3cDVhTkwwNkJpVnR2eklFZEVSYXM4Q3VpUkppN283T2tERmpRZW1SSWVvc09WSkkxK2x1dnNpc0Z0MGlJclpLanFBcEVGYnRZUG5ldjU1Wng0R25vNE9vZjlqQVYyU1ZCdmpucG5PM0o3ZTZCaVZkdXVqazZNalZKb2ozUE5uQVYyU3BFWGRFeDJnQnU2SURsQmhRNEZSMFNHa0Fnd0J6c1d1L2NIWUpEcUFwRUhycEFQZEVlNmR1VFU2Z0JiaUNIZEpVbTNjTzlIdTgwN2Q4Zml6MFJFcXpRSjYvaXlnUzFKOTJjSGFQZ3ZvbmJzdk9rREZlUTY2bW1JRDRBZlJJU3JFYmxTcGVsYnI0TGt2eXl4Rk03bW5MeGM3MENXcFpMcThjdGcyeDdkMzdzRm5ub3VPVUduTGpiU0FuamNMNkpJa0xlcUo2QUExOEhCMGdJb2JHUjFBS3RCSGdBT2pRMVRBS0dDZDZCQ1NCcTJUQXZxYW1hVm9wdnVqQTJnaGRxQkxrbXJqNlJtem95TlVubWVnZDJia3NLSFJFV3JQQXJva1NZdWFGQjJnQml5Z2Q4YmJTTlUwWndMclJvY291UTF3dW94VVJTdDE4Tnl4bWFWb3BudWpBMmdoODZNRFNKS1VsY2t6NTBSSHFMeUhKMXRBNzhTd29WNGV5SnNGZEVtU0ZqVTVPa0FOUEJJZG9PS0dSUWVRQ2pZR09BZmZueXlKNTU5TDFkVHVzU3dqZ0ZXeUROSXdmZGlCTGttU2NtSUJ2WFBUWm5jemRmYmM2QmlWTld5SWwwL3k1a2RZa3FTRjlRTFBSb2VvQVR2UU8yTUh1cHJvamNCUjBTRktiSVBvQUpMYXNseWJ6MXNEcDA1MDRqSEEyYXFTSkNrWFUyWmErTTNDSTVOblJFZW9yT0ZETGUvbXpZK3dKRWtMbTBicVdGRm5uZ05tUm9lb01EdlExVlRmQkxhSkRsRlNhMGNIa05TV2RqdlFQZis4TTNhZlM1S2szRXlaWlFkNkZpWSs1LzJPN1hLRWUvNHNvRXVTdExCWjBRRnF4Rkg0N2JNRFhVMDFFcmdRR0JVZHBJUThDMW1xcG5ZTDZHdGxtcUo1SG8wT0lFbVM2bXZPdk43b0NMWGdqUWp0c3dNOWYzNkVKYW0rdkEydFBmT2lBOVNJby9EYlp3ZTZtbXdMNE92UklVcklZcHBVVGFQYmZONnFtYVpvbnFlaUEwaVNWSFpkWGpsczI3eGVoMWRtNGRsWmpzSnYxOUF1eTd0NTh5TXNTZExDdXFNRDFJZ2Q2TzN6YmF5YTdtaGduK2dRSldNSHVsUk53NEdoYlR4dnhheUROTXpUMFFFa1NWSjlkZmRZUU0rQ1o4bTN6eHRnOG1jQlhaS2toZG1CbnAwcDBRRWtWVllYY0Rhd1NuU1FFckdBTGxWWE81TmxWc2c4UmJOWVFKY2tTYm14QXowYmpuQlhtVmxBbHlScFlSYlFzK01JZDBtZEdBdjhMRHBFU1l3R2xvc09JYWx0N1JUUTJ6MDdYWWtGZEVtU2xCc0w2Tm1ZTnR0Qm9Db3ZDK2lTSkMyc056cEFqY3lPRGlDcDh0NEJmQ1E2UkFtTWlRNGdxU1BEMjNpT0hlaWRzWUF1U1pKeU01LzUwUkZxWVU1UFQzUUVxU1VMNkpJa0tTL2VSaW9wQzZjREcwZUhDT1paeUZLMU9jSzllTTlFQjVBa1NkS1NlWmE4eXN3Q3VpUkp5b3NGZEVsWldBNDREeGdhbkNPU0JYU3AydHI1L3VYWGZXZW1Sd2VRSktuc3V1aUtqcUNHczRDdU1yT0FMa24xNVM1WTBTeWdTOHJLTHNBWG9rTUVjb1M3VkczejJuak9jcG1uYUk0ZVBKWkpraVNwOUxwNzNiS3B2Q3lnUzVLa3ZGaEFsNVNsTHdNN1JZY0lZaWVxVkcxejIzaE9PK2VtSzVrVEhVQ1NKRWxMWndlNnlzd0N1aVJKeW9zRmRFbFpHZ2I4Q2xnK09raUFKdjZacFRwcHA0RGU1R01yT3RYT3gxdVNKRWtGc3dOZFpXWUJYWklrNVdWK2RBQkp0Yk1SOE4zb0VBRkdSQWVRMUxaZTBranh3YktBM2o0NzBDVkpraVIxeEFLNkpFbVNwQ3I1T0xCL2RJaUNPY3BacXE1MkovSU15elJGczlpQkxrbVNKS2tqRnRBbFNaSWtWYzFQZ0xXaVF4VElBcnBVWGUwV2MrMUFiNThkNkpJa1NaSTZZZ0Zka3Vxckt6cUFKRWs1V1JVNGorYjhXMmNCWGFxdWRvdTVGdERiNXpGQ2tpUU5RRmRUM2sxSlVoc3NvRXVTSkVtcW9yMkF3Nk5ERk1RQ3VsUmQ3WGFnTzhLOWZjdEVCNUFrU1pKVWJSYlFKVW1TSkZYVnQ0RlhSSWNvZ08vYnBPcnlQTzdpV1VDWEpFbVMxQkV2eEVpU0pFbXFxbVdBODRFUjBVRnkxaE1kUUZMYlpyWDV2SG1acG1pV1VkRUJKRW1TSkZXYkJYUkpraVJKVmJZdDhMWG9FRG5yamc0Z3FXMlQyM3llQmZUMjJZRXVTWklrcVNNVzBDVkpraVJWM2JIQUh0RWhjbVFoVGFxdUtXMCt6Ni83OWxsQWx5UkprdFFSQytpU0pFbVNxbTRJYVpUN3l0RkJjbUloVGFvdUMrakZHMEw5ai9hUUpFbVNsQ01MNkpKVVgxM1JBU1JKS3RBNndPblJJWEppSVUycUxndm9NWmFORGlCSlV0bDFlZWxRa2xxeWdDNUpraVNwTHQ3WC82Z2JDMmxTZFZsQWo3RkdkQUJKa2lSSjFXVUJYWklrU1ZLZC9CaFlMenBFeHJxakEwaHFXN3NGOURtWnBtaWVOYU1EU0pJa1Nhb3VDK2lTSkVtUzZtUkY0RmZBME9nZ0dYb3VPb0NrdGsxdTgzbCszWGRtN2VnQWtpUkprcXJMQXJva1NaS2t1dGtWK0d4MGlBeFpTSk9xcTkwT2RML3VPek0yT29Ba1NaS2s2cktBTGttU0pLbU9UZ0plRlIwaUk5T2lBMGhxMnhOdFBzK3YrODZzRlIxQWtpUkpVblZaUUpja1NaSlVSOE9CODRGbG80Tmt3RUthVkUxemdhZmJmTzcwTElNMGtBWDA4dW1LRGlCSldsaVgzNWtscVNVTDZKSlVYMjZESlVsTnR6bndyZWdRR2JDQUxsWFQ0MEJmbTg5MWhIdG5IT0ZlUHNPaUEwaVNKRWtEWlFGZGt1ckxBcm9rU2ZCSllOL29FQjJhUWZ0Rk9FbHhIdTNndWQ0NDA1bk5vZ05vRVNPaUEwaVNGbVlIdWlTMVpnRmRrdXJMYmJBa1NlbmZ3M09BTmFLRGRLQVB1MUdsS25xc2crYyttMW1LWmxvRFdEVTZoQlppQVYyU1NxYkxTNGVTMUpJRmRFbXFMM2ZCa2lRbHF3Tm5SWWZvMEpQUkFTUU4yb1FPbnZ0RVppbWFhK3ZvQUZxSUJYUkpLaGs3MENXcE5Rdm9rbFJmYm9NbFNYclJmc0Fub2tOMHdBSzZWRDJQZC9EY3B6SkwwVnhiUmdmUVFwYUpEaUJKV3BnZDZKTFVtZ1YwU2FvdmQ4R1NKQzNzTkdEVDZCQnRzaHRWcXA1eEhUeDNFdENkVlpDR2VrVjBBQzFrcGVnQWtxU0YyWUV1U2ExWlFKZWsrbkliTEVuU3drWURGd0REbzRPMHdRSzZWRDBQZFBEYytkaUYzaWtMNk9VeEhGZ3VPb1FrYVdFVzBDV3BOUXZva2lSSlVqbk5qZzVRVTlzRHgwZUhhSU1qM0tWcW1Vbm5ONzVNekNKSWcyMkIxNzNLWWt4MEFFblNvaHpoTGttdCtVWkNrdXJMWGJBa1ZWYzNzQ2Z3NStnZ05YVWlzRnQwaUVHeWdDNVZ5NE9rTHZKT1dFRHZ6QXJBMXRFaEJGaEFsNlJTc2dOZGtscXpnQzVKOWVVMldKS3E2M1BBVGNBUndLemdMSFUwQkRpWFZGeXBpc2VpQTBnYWxFN09QMy9CSXhtOFJ0UHRHUjFBQUt3VEhVQ1N0Q2c3MENXcHRXSFJBU1JKdVhFWExFblZkQzd3Zy83L2ZoVDRKbkJ5WEp6YTJnRDRJZkNSNEJ3RDlXQjBnSXI0S2ZENW5GNTdLUG5lZERHRy9QWnZvNEVST2IzMmlQN1h6ME1YK1hhdUxrOSsxMFZ1enVBMS9McnYzTzdBdDZORGlIV2pBMGlTSkVtRFlRRmRrdXJMQXJva1ZjOHR3Q2RmOG5QZkJqNEFiRlo4bk5yN01IQTVjRkYwa0FHWVRocmpQalk2U01tdEJrek44ZlVuNS9qYTBrdGwwY1hlZEs4ajNlVFJIUjJrNFN5Z1MxSUpPY0pka2xwemhMc2sxWmZiWUVtcWxrbkF1NEE1TC9uNWJ1QlR4Y2RwakRPcHpvWDlCNklEVklCamdsVW5GdEE3TnhyWVBqcUUvTjRzU1dWa0FWMlNXck9BTGtuMTVUWllrcXFqQjNndmFXVDc0bHdOL0xhNE9JMHlCamlIYXJ3M3VpODZRQVZzSEIxQXl0QUVGcjJwU29Qbk9lanhObzBPSUVsYWxHZWdTMUpyVmJoSUpFbHFqN3RnU2FxT0x3Si9YOHJ2T1FwNHJvQXNUZlJHNE9qb0VBTmdCL3JTclFTc0hSMUN5a2dmTUQ0NlJBMjhLVHFBMkNJNmdDUnBVWGFnUzFKckZ0QWxxYjdjQmt0U05WeEVPdWQ4YVo0Q1RzbzVTNU45QTlnbU9zUlNQQmdkb0NLMmpBNGdaY2diWnpxM0U3QkJkSWdHV3gxWUxUcUVKR2xSZHFCTFVtc1cwQ1dwdnR3RlMxTDUzUWw4RkpnL3dOLy9BK0QyL09JMDJramdRbUJVZEpBbDhPOStZSGFPRGlCbDZNN29BRFhRQmJ3bk9rU0RlVk9USkpXVUhlaVMxSm9GZEVtU0pDbkdGR0EvWU5ZZ250TURITUhBQys0YW5DMkFyMGVIV0lMSGdFblJJU3JnTmRFQnBBejlMenBBVFh3b09rQ0Q3Um9kUUpLMGVCYlFKYWsxQytpU1ZGOXVneVdwdkhxQjk5TGUyYlkzQXIvSU5JMFdkRFN3VDNTSUpiZ3RPa0FGN0FnTWl3NGhaY1RKRTluWUROZzZPa1JEdlNFNmdDUnA4UnpoTGttdFdVQ1hwUHB5Rnl4SjVYVWk4TGNPbnY4NVlHbzJVZlFTWGNEWndDclJRVnE0SlRwQUJhd0E3QllkUXNySVE4RDA2QkExOGQ3b0FBMDBHby9Wa0tUU3NnTmRrbHF6Z0M1SjllVTJXSkxLNldJNkh4UCtEUENsRExKbzhjWUNQNHNPMGNLdDBRRXE0bTNSQWFTTXpBZnVqZzVSRSs4SGhrZUhhSmpYQUNPaVEwaVNKRW1EWlFGZGt1ckxBcm9rbGM4OXdFRmtjNGI1bWNDL00zZ2RMZDQ3Z0k5RWgxZ01SN2dQek52dy9hN3F3M1BRcy9FeVVoRmR4ZGsvT29Ba3FUVkh1RXRTYTE1UWtLVDZjaGNzU2VYeUhLa29Pek9qMStzRERpZWRwNjU4bkFGc0hCM2lKUjRDbm8wT1VRSHI0cm03cWc4blQyVG5hSHlmVkpUaHBIMlBKS21rSE9FdVNhMVpRSmVrK25JYkxFbmwwUWQ4Q0hnZzQ5ZjlMK1VkTlY0SG80SHpnR0hCT1JZMEg3Z3hPa1JGSEJ3ZFFNckk5ZEVCYW1RYjRFM1JJUnBpYjJEVjZCQ1NwTllzb0V0U2F4YlFKYW0rM0FaTFVubDhBL2hUVHEvOUJkS1o2TXJITHFTUGNabGNFeDJnSXZZSDFvc09JV1ZnSERBcE9rU05IQk1kb0NFT2pBNGdTVm95UjdoTFVtc1cwQ1dwdnR3RlMxSTUvQlg0U282dlB4VTRQc2ZYRjV3QTdCUWRZZ0hYUlFlb2lHSEFVZEVocEF6TUIyNktEbEVqZXdMYlJvZW91YldBQTZKRFNKS1d6QTUwU1dyTkFyb2sxWmZiWUVtS053NzRBR21FZTU3T3c2SnFub1lCdndLV2p3N1M3dzVnZW5TSWl2Z29zRXAwQ0NrRE4wUUhxSmt6OFAxU25qNE5qSXdPSVVsYU1qdlFKYWsxQytpU0pFbFNQcVlEYndXbUZiRFdmT0FJWUY0QmF6WFZSc0IzbzBQMDY4VXprUWRxQmVCTDBTR2tEUHd6T2tETjdBSzhLenBFVFkwQkRva09JVWxhT2p2UUphazFDK2lTVkY5dWd5VXB6bnpnSThCOUJhNTVGL0NqQXRkcm9vK1R6dFV1QTd0UkIrNFFZSjNvRUZLSGJnVm1SWWVvbVc4QUk2SkQxTkFobEdkaWl5UnBDU3lnUzFKckZ0QWxxYjdjQmt0U25HOERmd2hZOTh2QUV3SHJOc2xQU0dlN1J2dExkSUFLR1FXY0ZSMUM2bEEzOEkvb0VEV3pNV25VdUxLekprNzlrS1RLY0lTN0pMVm1BVjJTNnN0ZHNDVEZ1QUw0Zk5EYU00RFBCcTNkRkt1U3pweVAvbmYySG1COGNJWXEyUWZZTnpxRTFLRy9SUWVvb2VPQTFhSkQxTWdYZ2VXaVEwaVNKRW1kc29BdVNmVVZmV0Zma3Byb2NlRERRRjlnaG92d2ZPeTg3VVVhNXg3dDB1Z0FGWE1Pc0VaMENLa0RWMFlIcUtFeHdCblJJV3BpTXp6N1hKSXF4Ukh1a3RTYUJYUkpxaSszd1pKVXZJOER6d1JubUE4Y0Rzd0x6bEYzcHdHYkJHZHdqUHZnckE3OE5EcUUxSUVIZ0llaVE5VFF1NEgzUjRlb3VPSEFCZjAvU3BJcXdoSHVrdFNhQlhSSnFpOTN3WkpVdkluUkFmcmRCWHduT2tUTmpRWitBNHdJekhBRGFXeS9CdTV0d0tIUklhUU9PTVk5SDk4SFhoWWRvc0tPQkxhTERpRkpHaHc3MENXcE5Rdm9rbFJmYm9NbHFkbE9BaDZKRGxGejI1SSt6bEhtQWxjRnJsOVZQd1JlR3gxQ2F0TmwwUUZxYWxYU1RWRjJVQS9lNXNESjBTRWtTWU5uQVYyU1dyT0FMa24xNVRaWWtwcnRlZURUMFNFYTRMUEFIb0hyWHhTNGRsVU5CMzVQL0FoK3FSMS9BNlpIaDZpcFhZQnZSNGVvbU9WSU54NHNFeDFFa2pSNGpuQ1hwTllzb0V0U2Zia0xsaVQ5RWMvSnp0c1E0SHhnNWFEMUx3V2VEVnE3eWxZRHJnRTJqQTRpRGRJYzB0ZTk4bkVVOEtub0VCVXhGTGdZMkRvNlNNMTU3VlpTYnV4QWw2VFdoa1VIYUpBaHdOam9FS3FFV2NCejBTRWtTVkp0SEVIcWtGNDJPa2lOclFQOEZEZ2dZTzF1MG8wU0J3ZXNYWFZqZ2N1QjNZRW5nN05JZy9FSDRJUFJJV3JzdThCOWVONzgwcHdBN0IwZG9nRXNvRXZLalIzb2t0U2FCZlRpckF3OEVSMUNsZkJUNE5Eb0VLb0ZkOEdTSklBSndLbkFWNk9EMU56K3dQdUJDd0xXL2dVVzBOdTFDWEFUcVlqK1NIQVdhYUN1QUdhU3htY3JlOE5KTnluc1JmcitvRVVkREh3NU9rUkRXRUNYbEJzNzBDV3BOVGRoa2xSZmJvTWxTUzg0QmJnL09rUUQvQWhZUDJEZEc0REhBOWF0aS9XQXE0R3Rvb05JQS9RODhOZm9FRFUzR3JnTTJDRTZTQWtkQUp5Rjd6ZUw0clZiU2JteGdDNUpyYmtKazZUNmNoc3NTWHBCTjU3cFdvUVZnVitTem9VdFVoOXdZY0ZyMXMyR3BFN1R0MFlIa1Fib045RUJHbUJGNE8vQWJ0RkJTbVFmNEZjVS8rOWNrM250VnBJa0tZQ2JNRW1xTHd2b2txUUYvUTI0T0RwRUErd0tIQnV3N3Bta1FycmF0enh3S1dsaWcrK1ZWWGFYQVpPaVF6VEFDc0Rsd0g3UlFVcmcvYVRSOWlPaWd6U00veDVKeW8xbm9FdFNhMjdDSkttKzNBVkxrbDdxR05LNXVjclgxNEJYRjd6bUk2UXg1T3BNRjNBY3FjTnloZUFzMHBKMGt5WmVLSCtqZ0Q4Q0p3Ym5pRElFK0FIcCsrTEk0Q3hONUxWYlNibHhoTHNrdGVZbVRKTHF5MjJ3Sk9tbEhpY1ZkNVd2NGNENXdMSUZyM3Q2d2V2VjJYdUJCNEMzUndlUmxzQUNlbkc2Z0srUXp2NGVGWnlsU0tPQW53TkhSZ2RwTUsvZFNzcU5IZWlTMUpxYk1FbXFMM2ZCa3FURitSNXdSM1NJQnRnTStGYkJhMTVHNmtSWE50WWdqU3YrTGJCeWNCWnBjVzREYm84TzBUQWZCLzROYkJFZHBBQmJBUDhCUGh3ZHBPRThiMTVTYnV4QWw2VFdMS0JMVW4yNURaWWtMVTRQY0Rnd1B6cElBM3dTMkxmQTlmcUFjd3RjcnlrT0FHNEczaEFkUkZxTTg2SUROTkFyZ0Z1QVQxUFA2MnBkd0VkSjMvZTJDczZpZW42T1NTb0pDK2lTMUpxYk1FbXFMN2ZCa3FSV2JpU2RaYXA4ZFpGRzM2NVI0Sm8vQStZVXVGNVRiRWc2WS82dnBPS1o2bUVJc0hGMGlBNzlBcGdkSGFLQlJnSGZCYTREdGduT2txVXRnWDhBWjFQOE1TUmFQSy9kU3NxTkk5d2xxVFUzWVpJa1NWSXpIUXRNaXc3UkFLdVJ1c0tMdWpyMUZPbU1YdVhqemFTUjJiOEZYaDZjUmUxWkFmZ1E2ZTl3RW1rY2Q1V3ZIajhMWEJBZG9zRjJCZjVMdW5scHJlQXNuVmlSZEVQQS80RFh4MGJSUzNqdFZsSnU3RUNYcE5iY2hFbFNmYmtObGlRdHlkUEFDZEVoR21JZjRCTUZybmNhTUsvQTlacW1pelRXL1U3U3gzcjkwRFFhaUpXQkR3SVhBMDhBNTVQK0RsY0dWZ0xXaTR1V2lkT2pBelRjVU9CandEamdWR0NWMkRpRHNoendSZUFSMGtqNjRiRnh0QmhldTVXVUd6dlFKYWsxTjJHU1ZGL3VnaVZKUy9OajREL1JJUnJpTkdEVGd0YWFnQ1A2aTdBTWNBeXBhSFlKZG0yV3lUQlNaL0JYZ090Sk53ejlBbmdYcVdENFV0c1hGeTBYZHdMWFJJY1F5d0tmSTMwUC9nbHBISHBaclFZY1R5cWNuMHk2a1VUbDVMVmJTYm14QTEyU1duTVRKa24xNVRaWWtyUTBmY0RoL1Q4cVg4dVN4aXlQS0dpOVU0RGVndFpxdXFIQU8wZ0Z6TnVCajdMNElxM3kwMFU2bS80WTRDL0FWT0FHNEVUZ3RhU0MrcEpVdllBTzhNUG9BUG8vbzRGRFNUYzJYQTk4dVAvbm9uVUJld0MvQmg0RHZnbXNHcHBJQTlHRjcrMGxTWklLWndGZGt1ckxOOW1TcElHNEJUZ25Pa1JEYkU5eFkvTWZBSDVYMEZwNjBkYkEyY0F6d0VYQTI0R1JvWW5xYVNTd00zQTA2ZU04RWJpRE5PbmhMUXorQm9ZNkZORC9ERHdjSFVJTDZTTGR3SEVlYVFyQzc0R0RLZmFzOUdXQmZVa2Q4Uk9BdndQdndlOUxWVE0wT29Da2VySURYWkphVzlwZDJKS2s2bkliTEVrWkIwY3dBQUFaOUVsRVFWUWFxT05KaGI3Vm9vTTB3QmVBcTRIckNsanJLNlNSMVo1cFc3eFJ3THY3SDlOSUk5NHZJbldqemduTVZWVWJBanNCTy9ZL3RpWGJhUTdiWmZoYVVYcEpIY1UvaXc2aXhSb052TFAvQWVrbXB4dUFmd08za2JyVnMvamVzRHJwYTJTbi9zZk9wTzlIcWpZYm9DVGx3alBRSmFrMUMraVNWRi91Z2lWSkEvVXM4SGxTNTZ6eU5RUTRGM2dsTUQzbnRSNEFmZ29ja2ZNNldySXhwSzdUZzRIbmdSdEpOMUZjVFNxY2VZVENpMFlBVzVBNitiY0d0dWwvNUgxeno2ckFlcVFPM1NvN0gvZ1M2YytpY3R1ay8vSFIvdi92QVI0RnhnRVBBWk5KUnhFOEM4eCt5WE9IQWN1VHVwTFhCalpZNExGbTNzRVZ3Z0s2cEZ6WWdTNUpyVmxBbDZUNmNoc3NTUnFNbjVNdTVPOGNIYVFCTmlDZFYveVJBdGI2R3ZBaFlJVUMxdExTalFMMjdIOEFUQ0dkbmY1djRML0FyY0J6TWRFS05acjBkYkFoc0JrdkZzdzNJMjVpd3ZaVXY0QStEemdadTlDcmFCanA2MkhENkNBcUpRdm9rbkpoQjdva3RXWUJYWkxxeTEyd0pHa3c1Z09Ia0FwNHZrL0kzNGVCSzREZjVMek9KT0JVNE9zNXI2UDJyQUxzMy8rQTlIWDRJS21ZZmd0d042a2pkUUtwUTdVcVZpT05rbDZMaGJ0algzaXNIaGV0cGUxSm8vYXI3bnpTVVJFYlJBZVJsQmtMNkpKeVlRZTZKTFhtaFRGSnFpKzN3Wktrd2JvVCtERndaSFNRaHZnSmNCTnBiRytldmc4Y0JxeVQ4enJxWEJjdmpuWis3d0kvUHc5NGhGUk1md0I0bURUaWVWTC9ZM0wvWTI3R2VWWWtUUzk0NldPbC9oL1hZdUZpK1dyOWp5cGVhOWcrT2tCRzVnSGZCYzZJRGlJcE14YlFKZVhDQXJva3RWYkZON1dTSkVtUzhuTUNxUnQyYkhTUUJoaERHcDIvRi9tZWd6MGJPQTY0SU1jMWxLL2h2RmhZZi9NU2Z0OE0wbGo0Rno2ZjVwRE9YVzlsS0l1Tzl4L1cvM05qMmtwYVhYVXBvQVA4RkRnYzJEdzZpS1JNaklnT0lLbWVIT0V1U2ExWlFKZWsrbklYTEVscXgzVGdXQ3kyRnVVTndOSEFhVG12Y3lHcG8zbmZuTmRSck9YN0h4cThWWUgxZ2ZHeE1UTFJRN29aNnVMb0lKSXlZUUZkVWk3c1FKZWsxaHdCSkVuMTVUWllrdFN1QzRGL1JJZG9rRzhBMnhTd3poSEFyQUxXa2FxcVRsM292d2YrR1IxQ1VpWXNvRXZLaFIzb2t0U2FCWFJKcWk5M3daS2tUaHhHOXVjcGEvRkdrbTVhR0pYek9oT0FVM0plUTZxeU9oWFFBVDRMekk4T0lhbGpGdEFsU1pJS1pnRmRrdXJMQXJva3FSTVBBTitQRHRFZ1c1QTYwZlAyTGVEZUF0YVJxcWh1QmZUL0IvdzFPb1NramxsQWw1UUxSN2hMVW1zVzBDV3B2dHdHUzVJNjlUWHFjUjV3VlJ3RjdKUHpHdDNBSjRHK25OZVJxbWpiNkFBNThPZ0dxZm9zb0V2S2hRVjBTV3JOQXJvazFaZmJZRWxTcDJZRG40a08wU0Jkd05uQUtqbXZjeTN3elp6WGtLcG9OV0M5NkJBWm13Q2NHaDFDVWtjc29FdktoV2VnUzFKckZ0QWxxYjdjQlV1U3NuQUpqZ0F1MGxoU0VUMXZKd0wvTG1BZHFXcnFOc1lkVWdIOXZ1Z1FrdHBtQVYxU0x1eEFsNlRXTEtCTFVuMjVEWllrWmVVb1lFNTBpQVo1TzNCUXptdjBBQjhBWnVhOGpsUTFkU3lnZHdPZmlnNGhxVzBXMENYbHdnNTBTV3JOQXJvazFaZTdZRWxTVmg3Q0VjQkZPeDNZT09jMXhnR2Z5M2tOcVdycVdFQUh1Sm8wVVVSUzlWaEFsNVFMTzlBbHFUVUw2SklrU1pJRzRwdkFBOUVoR21RMGNENHdMT2QxemdRdXpYa05xVXEyalE2UW8wT0FwNk5EU0JvMEMraVNjbUVCWFpKYXM0QXVTZlhsTmxpU2xLVzVPQUs0YURzRFg4aDVqZm5BKzRFN2MxNUhxb3JWZ2ZXaVErUmtNdkNKNkJDU0JzMEN1cVJjT01KZGtscXpnQzVKOWVVdVdKS1V0YXR3QkhEUlRnQjJ5bm1OV2NCK3BPS2FwUHFPY1FmNEUzQmVkQWhKZzJJQlhWSXU3RUNYcE5Zc29FdFNmYmtObGlUbDRXaGdablNJQmhrR1hBQXNuL002NDRIM0FyMDVyeU5WUVowTDZBQkhBUk9pUTBnYU1Bdm9raVJKQmJPQUxrbjFaUUZka3BTSHg0Q1RvME0wekliQWFRV3Njelh3MVFMV2tjcXV6dWVnQTB3bmpYTHZpdzRpYVVDR1J3ZVFWRStPY0plazFpeWdTMUo5dVF1V0pPWGxlOEE5MFNFYTVtUEFBUVdzY3hMd293TFdrY3JzVmRFQkNuQVYzakFqVmNYSTZBQ1M2c2tSN3BMVW1nVjBTYW92dDhHU3BMeDBBNGNDODZPRE5NeVBnYlVLV09jbzRJOEZyQ09WMWFyQXV0RWhDdkIxNEpyb0VHcThId0NINEJFaVMySUh1cVJjV0VDWHBOWXNvRXRTZmJrTmxpVGw2UWJnMTlFaEdtWlY0RHp5L3plK0YzZ2Y4SytjMTVIS3JPN25vRVA2V2o4UWVDSTZpQnJyNzhBeHdGbkE1T0FzWldZSHVxUmNPTUpka2xxemdDNUo5ZVV1V0pLVXQwOEQwNkpETk14ZXdCRUZyUE04c0Ivd1lBRnJTV1hVaEFJNndDVGdnOWo5cStKMWt5YWV2REROWmxKZ2xyS3pBMTFTTHV4QWw2VFdMS0JMVW4yNURaWWs1ZTFwNEN2UklScm9XOEFyQ2xobk1xbUkvbFFCYTBsbHMyMTBnQUpkQXh3YkhVS044MjNnN2dYKy81bW9JQlV3SWpxQXBIcXlBMTJTV3JPQUxrbVNKS2tUUHdMK0Z4MmlZWllCenFlWUMrcjNBVHNENHd0WVN5cVRWMGNIS05qM2dOT2pRNmd4N2dHKzlwS2Zlem9pU0VXTWlnNGdxWjdzUUplazFpeWdTMUo5dVEyV0pCV2hGemdFNklzTzBqRGJBaWNWdE5aNFlIY3NvcXRaVmdWZUZoMmlZSjhoZGFOTGVlb0REaWVOY0YrUUhlaXRXVUNYbEFzTDZKTFVtZ1YwU2FvdnQ4R1NwS0xjREp3YkhhS0JQZ3ZzVWRCYTQ0RTlnY2NMV2s4cWc2YWNnLzZDZWNEYmdMdWlnNmpXVGdTdVhjelBXMEJ2YmRub0FKSWtTVTFqQVYyUzZzc0N1aVNwU0o4am5abXQ0Z3dCZmdHc1hOQjY0NEM5Z0VjTFdrK0sxcVJ6MEY4d0EzZ25Gak9Wanh1QWI3YjROVC9uV3JNRFhWSXVQQU5ka2xxemdDNUo5ZVV1V0pKVXBHZUJMMFNIYUtDMWdiTUtYTzllWUR2Z1h3V3VLVVY1VlhTQUlBK1NwbHRNaVE2aVdua0tPQURvYWZIckZ0QmJzd05kVWk0YzRTNUpyVmxBbDZUNmNoc3NTU3JhT1ZoWWpmQXU0UDBGcmplRk5NNzlyd1d1S1VWbzJnajNCZDBON0VQcVNKYzZOUjg0Q0hoNkNiOW5TYi9XZEhhZ1M4cUZIZWlTMUpvRmRFbXFMM2ZCa3FTaTlRRkhBTDNSUVJyb1I4RDZCYTQzaTNSVzhrOExYRk1xMnVyQU90RWhBdDBNN0E5MFJ3ZFI1WjBFWExHVTN6T3BpQ0FWWlFlNnBGellnUzVKclZsQWw2VDZjaHNzU1lwd0svQ1Q2QkFOdENMd1MyQm9nV3YyQW9jQko1TzZDNlU2Mmk0NlFMQ3JnSGRqRVYzdCt4Vnc0Z0IrbnlQY1c3TURYVkl1TEtCTFVtc1cwQ1dwdnR3R1M1S2lmQkdZR0IyaWdYWUZqaTE0emZuQUNjQmJnR2tGcnkwVllZZm9BQ1Z3S2JBWE1ETTZpQ3JuS3VCZ0JuYVQxVXpTZEJNdHlnNTBTYmx3aExza3RXWUJYWkxxeTEyd0pDbktkT0M0NkJBTmRSTHc2b0IxTCs5Zjk5NkF0YVU4TmZrYzlBVmRSem9UZlhwMEVGWEc3YVFqQU9ZTjRqbDJvUytlSGVpU2NtRUh1aVMxWmdGZGtpUkpVaDUrQ1Z3VEhhS0JoZ0huRTlPdDlpQ3dJNmxiVmFvTEMrZ3Z1aEhZRDVnUkhVU2w5eWp3ZGdiL3VXSUJmZkVzb0V2S2hSM29rdFNhQlhSSnFpOTN3WktrYUVjd3VNNHpaV016NE50QmE4OGdkUngrRmVnSnlpQmxhUTFnYkhTSUVya09lQVB3ZEhRUWxkWUU0UFhBK0RhZWF3Rjk4UnpoTGlrWGRxQkxVbXNXMENXcHZ0d0dTNUtpM1FOOFB6cEVReDBHN0J1MGRnOXdJckF0Y0VkUUJpbExyNG9PVURJM0E5c0J0MFVIVWVuY0Erd0VQTkxtODcweFkvR1d3ZmYza2lSSmhiS0FMa24xNVJ0c1NWSVpuRWpxUmxPeHVvQ2ZBMnNHWnJpTE5OTDlWS0F2TUlmVUtjZTRMK3BKWUhmZzJ1QWNLbys3Z1QyQXB6cDREVHZRRjY4THg3aEx5b0VkNkpMVW1nVjBTYW92dDhHU3BES1lEWHcyT2tSRHJRYWNTK3llWUE1d1BQQk9ZR0pnRHFrVDIwWUhLS2xwd0p1QjMwY0hVYmk3Z0RmUmVRZjVwQXl5MUpVRmRFbVo4d3gwU1dyTkFyb2sxWmU3WUVsU1dWd01YQllkb3FIZUJId2lPZ1J3S2ZCeVVqZDZiM0FXYWJBYzRkN2E4OEQrd0NIQXZPQXNpbkVwYVd6NzR4bThsaVBjVy9NY2RFbVpzd05ka2xxemdDNUo5ZVUyV0pKVUprZVJ1cEZWdk5PQVRhTkRrS1lSSEEvc1FEcERXYXFLTllDMW8wT1UzRm1rOGQxT21taVdVNEYzQWJNeWVqMUh1TGRtQjdxa3pObUJMa210V1VDWHBQcHlGeXhKS3BOeHdMZWlRelRVc3NDRndJam9JUDF1QTNZRlRpQjFyMHBWNEJqM3Bic1IyQm40YjNRUTVhNFBPSTUwVTFTV1UwVWM0ZDZhSGVpU01tY0h1aVMxWmdGZGt1ckxiYkFrcVd4T0FSNk9EdEZRMndGZmpnNnhnRzdnWkdBalV1ZXFZOTFWZG81eEg1Z0p3R3VBNzVDS3JLcWZ5Y0IrNUhOVG5DUGNXMXN1T29DaytyR0FMa210V1VDWHBQcHlHeXhKS3B2bmdVOUdoMml3endPN1JZZDRpWW1rczVOZkJWd2JHMFZhb3UyakExVElYT0JZVWpmNmc4RlpsSzNMZ1MyQXYrYjArcFB4aHFwV1ZvZ09JS2wrSE9FdVNhMVpRSmNrU1pKVXBDdUJQMGFIYUtnaHdMbVU4eUw4LzBqbko3K1AxTUVxbFkwajNBZnZQOEEyd0Eramc2aGo4NENqZ2JlUTc1ajFYbUJLanE5ZlpjdEhCNUJVUDNhZ1MxSnJGdEFscWI3Y0JrdVN5dXBJWUZaMGlJYmFBRGc5T2tRTDg0RmZBNXNBaDJFaFhlVXlGeGdkSGFLQ25nZU9BdDRHUEJxY1JlMFpEK3dOL0lEMGZUcHZub08rZUJiUUpXWE9EblJKYXMwQ3VpVFZsN3RnU1ZKWlBRWjhQVHBFZzMwSWVFOTBpQ1hvQnM0RU5nVGVEZHdYRzBjTk5nczRDOWlCOVBub2pUL3QreE93S2ZCVjBzMElLcis1d1BHa201cXVLWEJkejBGZnZESk9qNUVrU2FvdEMraVNWRjhXMENWSlpmWmQ0TjdvRUEzMkUyRGQ2QkJMMFFmOER0Z2FPQmk0UHphT0d1UU80RE9raVEySEFQK05qVk1iYzRBVGdWY0QvNHlOb3FYNEw3QUxjQ3BwZkh1UjdFQmZQRHZRSldYT0VlNlMxSm9GZEVtcUw3ZkJrcVF5NndZT3BaaHhzRnJVR09DWFZPTTk0VHpTMmUyYmtUcUJmd24waENaU0hkMVA2clpkajNSdTkybFl5TXZMSGNCclNaTXdIZ25Pb29WTkJUNE43QWpjR3BUaG1hQjF5ODRPZEVtWnM0QXVTYTFWNFdLSkpLazlib01sU1dWM1BYQlJkSWdHZXgxd1RIU0lRZm92YVFUOUZzQVBnZW14Y1ZSeFR3QS9BbllqZlU2ZGl1ZDBGMlUrNmZ2L0pxUXVmOGQyeDVwT3VvSGtaY0QzZ043QUxINHVMSjRkNkpJeTV4bm9rdFNhQlhSSnFpOTN3WktrS2pnR2VDNDZSSU45bmRSdFd6VVBBa2NCNjVDS2IvL0VhUVlhbUllQjc1REdVNjhMSEVHNm1hY3ZNbFNEOVpET21kK1MxUFh2T2ZQRjZnUE9CMTVCdW9Ha0RCOS9POUFYenc1MFNabXpBMTJTV3JPQUxrbjE1VFpZa2xRRlQ1SE94RldNa2NDRndLam9JRzJhUVNxKzdVcnFaUDBham9UV3ducUE2NERqU0VYQ2pZQmpnWDloMGJ4TXB2RGl1ZlBmeE9rU2Vlc0ZmZ084RXZnSTVacThZQUY5OGV4QWw1UTVPOUFscVRVTDZKSlVYKzZDSlVsVmNUcHdXM1NJQnRzQytFWjBpQXlNQTc1Q0twRHVCdndVbUJpYVNGSEdBZWNBN3daV0ExNFBmQXU0S3pDVEJtWVM4QVZnZmRMTlZaTWp3OVRRSE9CTTBnMUg3d1h1akkyeldCYlFGODhDdXFUTTJZRXVTYTFaUUplaytuSWJMRW1xaWw3U0dHVkhjTWM1Q25oemRJaU16Q2VONUQ0VUdBdHNSVHJiMXpIdjlUU1A5SGQ3S3JBbmFjenh4c0RIZ044QjArS2lxUU5UZ2ErU3p1UStDTGdsTms3bFBRdWNRcm94NFREU1VRWmxaUUY5OFJ6aExpbHpGdEFscWJWaDBRRWtTWklraVZRQU80OVVLRkh4dW9DZkFWdVRSaW5YeWQzOWoxTko1eXkvRGRnYjJCa1lIcGhMN2VrRDdpRGRKSEVkY0FPcGExbjFOSWYwYjhONXdJNmttNjMyQjVhSmkxUVo4NEZyZ2JPQlMwZ2Z5eXF3Z0w1NGRxQkx5cHdqM0NXcE5Rdm9rbFJmN29JbFNWVnpMUEJXWU5Yb0lBMDFsbFJvZVVkMGtCeTlVRXovQnJBY3NEdXBhM2t2WU5QQVhHcnRZZUIvd0szOVAvNEx1OHFiNnQvOWowOEJCd0lmQW5ZSlRWUk9FMGszSFB5Y2RKeEIxY3dBbmdkR1JRY3BHVHZRVmFqcGM3cVpPbnR1ZEl6S21UNm5PenJDb016dTd2SHZXYUY2ZXVmN09kaW1PZk42b3lQVVhqdkZsYTJCbGJNT0l1bi9QQWs4RUxUMkVHRGJvTFdyYmpJd0lUckVTMndGakl3T1VVR3pnUHVpUTlURWFzQzYwU0VxNm41Z1p1RDZhd0pyQjY1ZlpmZVFMdnFxZlJzQ0swV0hhTGpiZ1o3b0VBSFdKUlhVZHlZVjViYkVZOCtLMUV0NkgvUkNvZnlGSHkyV2EwazJBVDVJT3U5K2srQXNrU2FRdXN3dkFXNGlUV3Fvc3ExeFFzaEw5WkcrSjJxZ0R2anRVRmFhMnNUOWpDUkpXcktyT091UXZaZjJtK3hPbENSSmtpUnBVU3NBTzVFSzZqc0JPK0IwaEN4MEErTkpuYkVQa29ybXQ1RnUzSmdWRjBzMXNERnBpc20rd0s3VXV3RGJCOXdKL0pWVU5QOXZiQnlwaEN5Z1M1S2t4UnRRQWQwUjdwSWtTWklrTFdvNmNGWC80d1Vya0lwMFd3SmJMUERqQm5pRCtvS21rNHJqOTVCRzVqKzh3R05xWUM3VjI0UEFhZjJQTWFTSkVyc0Jyd1cyQVliR1JjdkVQY0ExL1kvclNGUFFKRW1TSk9YQUFyb2tTWklrU1FNem5kVHArZEp1enpXQWpZQ1g5Lys0NEdPMUlnTVdZRGJ3T09tYzVjZjZmM3lpLy9Gay82ODlRUnJKTGtXWkJ2eWgvd0hwNXBmWDlEKzJKUlhVeTN4Y3phT2tjZDB2SEdkd00vQlVhQ0pKa2lTcFFTeWdTNUlrU1pMVW1hZjdIemN0NXRkR0EydVNpdXlydmVTLzF3QldKblhMamdGVzdIL2tQWHI2ZVdCRy8yTWE2Y2FBR1FzOG51dC92UEQvQ3hiSlBaTmNWVFFkdUx6LzhZTFZnRmYyUHpZR05pVGQ5UEl5aXVsVzcrSEY0d3dlV09CeEt6Q2xnUFVsU1pJa3RXQUIvZiszZDMraGRaNEZITWQvVDJMYnRkWENObThjWHNndUJHK0dPSEVnaUFqZURGYThXdkVQS3RNdENaczZOdkhDbTFHOGtURm9weGViU1ZlZElneFhHTXdWQktkdUZ6SWNvektaUXpNM0JRZlRMYlMxZjlLR2hwekhpNXl4VUhTY0pDZDVUdC96K2NBaGFYbmU5L3h1UXNQNXBqa0FBQUN3ZFJhVHZOWi9ER3B2M29ucGU5YjgvYTdML3J6V2NwTHovYzk3V1EzZ2IvdFBrdHIvL0Z4V3d4Mk11NFVrVC9jZmErMUk4cUVrSDB4eTdackhOZjNIZTVOY2xXUjNWcjhlZDYyNTlueFd2eFlYazF6cWZ6eVoxViszdnREL2VETEpXMG4rMFQ4TEFBQ01HQUVkQUFBQVJzdGkvL0ZHNnlFd2hwYXorbjdxZjJzOUJBQUFhR09pOVFBQUFBQUFBQUFBR0FVQ09nQUFBQUFBQUFCRVFBY0FBQUFBQUFDQUpBSTZBQUFBQUFBQUFDUVIwQUVBQUFBQUFBQWdpWUFPQUFBQUFBQUFBRWtFZEFBQUFBQUFBQUJJSXFBREFBQUFBQUFBUUJJQkhRQUFBQUFBQUFDU0NPZ0FBQUFBQUFBQWtFUkFCd0FBQUFBQUFJQWtBam9BQUFBQUFBQUFKQkhRQVFBQUFBQUFBQ0NKZ0E0QUFBQUFBQUFBU1FSMEFBQUFBQUFBQUVnaW9BTUFBQUFBQUFCQUVnRWRBQUFBQUFBQUFKSUk2QUFBQUFBQUFBQ1FSRUFIQUFBQUFBQUFnQ1FDT2dBQUFBQUFBQUFrRWRBQkFBQUFBQUFBSUltQURnQUFBQUFBQUFCSkJIUUFBQUFBQUFBQVNDS2dBd0FBQUFBQUFFQVNBUjBBQUFBQUFBQUFrZ2pvQUFBQUFBQUFBSkJFUUFjQUFBQUFBQUNBSkFJNkFBQUFBQUFBQUNRUjBBRUFBQUFBQUFBZ2lZQU9BQUFBQUFBQUFFa0VkQUFBQUFBQUFBQklJcUFEQUFBQUFBQUFRQklCSFFBQUFBQUFBQUNTQ09nQUFBQUFBQUFBa0VSQUJ3QUFBQUFBQUlBa0Fqb0FBQUFBQUFBQUpCSFFBUUFBQUFBQUFDQ0pnQTRBQUFBQUFBQUFTUVIwQUFBQUFBQUFBRWdpb0FNQUFBQUFBQUJBRWdFZEFBQUFBQUFBQUpJSTZBQUFBQUFBZE1teEF5dEpMcldlQVFDTW5BdURIQkxRQVFBQUFBRG9tdk90QndBQUk2YVdzNE1jRTlBQkFBQUFBT2lhZ1Y0Z0J3REdTS25uQmprbW9BTUFBQUFBMERVQ09nQnd1VE9ESEJMUUFRQUFBQURvbWxkYkR3QUFSa3d0cncxeVRFQUhBQUFBQUtCci90cDZBQUF3Y2diNi9rQkFCd0FBQUFDZ1cwcWRiejBCQUJneHZRa0JIUUFBQUFDQU1WVExuMXRQQUFCR3loczVldnVwUVE0SzZBQUFBQUFBZE10MS8zb3h5VUxyR1FEQWlLamxONE1lRmRBQkFBQUFBT2lXZ3dkN1NaNXRQUU1BR0JFVHZkOE9mSFFyZHdBQUFBQUFRQ1BQdEI0QUFJeUl5WldCdnk4UTBBRUFBQUFBNko3ZXhCTkpsbHZQQUFBYUsvVVBlZWl1MXdjOUxxQURBQUFBQU5BOWo5enhacEpmdDU0QkFEVDMwL1VjRnRBQkFBQUFBT2lxZGIxZ0RnQjB6c1hVOHRoNkxoRFFBUUFBQUFEb3BrczduMHF5MEhvR0FORE1rNW1iUHJPZUN3UjBBQUFBQUFDNjZkSGJscExjMzNvR0FOQkVMNzJKNzYzM0lnRWRBQUFBQUlBdWV6akpXNjFIQUFEYnJKWmY1SkU3L3JMZXl3UjBBQUFBQUFDNmEyNzZRcExEcldjQUFOdHFKYVYrZnlNWEN1Z0FBQUFBQUhUYjZhc1BKWG01OVF3QVlOczhtTG5wbHpaeW9ZQU9BQUFBQUVDM0hUdHdLY25Yay9SYVR3RUF0dHpmazl5MzBZc0ZkQUFBQUFBQXVtOXUrdm5VOHBQV013Q0FMVmJxdmYyM2NOa1FBUjBBQUFBQWdQR3d2T01iU2Y3VWVnWUFzRVZLL1VGbVo1N2N6QzBFZEFBQUFBQUF4c09qdHkybGxnTkp6cldlQWdBTTNYT3A1VHVidlltQURnQUFBQURBK0RneTlVcEt2YnYxREFCZ3FFNG4rVXJtcHBjM2U2UEpJWXdCQUFBQUFJQXJ4NG5qTCtiRy9hZVQzTng2Q2dDd2FlZFM2bWN6Ti9QeU1HNG1vQU1BQUFBQU1INU9ISDgrSDc5bFYxSSsxWG9LQUxCaFMwbjJaMjdtdVdIZFVFQUhBQUFBQUdBOG5YanFkN254eFB1VGZLTDFGQUJnM1paU3l4ZHpaUHBYdzd4cEdlYk5BQUFBQUFEZ2lqTTErNjBraDVOTXRKNENBQXpremRTeVAwZW1YaGoyalFWMEFBQUFBQUNZL3RFWFVzdVBrMXpWZWdvQThLNWV6ZVRLTFhuNHp2bXR1TG1mcGdNQUFBQUFnTm1aeHpLNTh0RWtmMnc5QlFENHYzNll2WXMzYkZVOFQvd1BkQUFBQUFBQWVNYzloM1puY2U4RFNlNk0xOUFCWUZTY1RhbDNaWGJtNTF2OVJQN3hCd0FBQUFDQXkwM05maXpKUTBsdWFqMEZBTVpZVFhJa0s1UGZ6ZEhiVDIzSEV3cm9BQUFBQUFEd3Ywek43a2d0ZDZmVSs1SzhyL1VjQUJnejh5bjFtNW1kZVhvN24xUkFCd0FBQUFDQWQvUGxuKzNObm90ZlNzMjNrM3k0OVJ3QTZMUlNqNmVXK3pNMy9mc21UOS9pU1FFQUFBQUE0SXB6NitNN2M4MnBBNm5scTBrK2syU3k5U1FBNklpektmV0oxSEswVlRoL200QU9BQUFBQUFEcjliV2oxMlhIOHVkVHkrZXkrajdwdTFwUEFvQXJ6TWtrejZiVVk5bHo0WmM1Zk8vRjFvTVNBUjBBQUFBQUFEYm5ua083YzJIUEoxUExwMVBMRFNuMUkwbXVUL0tlMXRNQVlFU2NUOGw4YXVhVHZKQlNuOGtIL3YxU0RoN3N0UjUyT1FFZEFBQUFBQUNHN2RiSGQrYnEwOWRub3Jjdks1UDdNdEhibDFyOHluY0F4a09wUzFtWlhFeHlKaE85aGN4Ti83UDFKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURZdVA4Q3FXT1BKUXZWTHVBQUFBQUFTVVZPUks1Q1lJST1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saW5rZWRpbi5wbmdcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9